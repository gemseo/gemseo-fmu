{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":"<p>All notable changes of this project will be documented here.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#develop","title":"Develop","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>The method   FMUDiscipline.set_default_execution   can be used to redefine some default settings, such as <code>do_step</code>, <code>final_time</code>, <code>restart</code> and <code>time_step</code>.</li> <li>TimeSteppingSystem   has a new argument <code>apply_time_step_to_disciplines</code> (default: <code>True</code>);   if <code>True</code>,   the value of its <code>time_step</code> argument is passed to the time-stepping disciplines;   otherwise,   the time-stepping disciplines use their own time steps.</li> <li>Any FMUDiscipline can use scalar input variables.</li> <li>A time-varying FMU model input can also be defined   as a time function of type <code>Callable[[TimeDurationType], float]</code>,   and not only a constant value or a   TimeSeries;   the documentation provides an example of this functionality.</li> <li>The method   FMUDiscipline.plot   draws the temporal evolution of output variables with lines.</li> <li>The components of   TimeSeries.time   can be either strings of characters such as <code>\"2h 34m 5s\"</code>,   or numbers expressed in seconds</li> <li>The arguments <code>initial_time</code>, <code>final_time</code> and <code>time_step</code> of   FMUDiscipline   can be strings of characters such as <code>\"2h 34m 5s\"</code>,   in addition to numbers expressed in seconds.</li> <li>TimeDuration   allows to define a time duration   based on a number expressed in seconds   or a string of characters such as <code>\"2h 34m 5s\"</code>.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>TimeSeries supports the <code>==</code> and <code>!=</code> operators.</li> <li>FMUDiscipline   stores the time evolution of its time-varying inputs   in its local_data   when <code>do_step</code> is <code>False</code>   and their values at current time otherwise.</li> <li>The installation page of the documentation no longer mentions the possibility   of installing via conda-forge.</li> <li>The installation page of the documentation no longer mentions the possibility   of using gemseo-fmu with Python 3.8.</li> <li>The readme file of the project now includes links to the documentation.</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>TimeSteppingSystem   can simulate up to the final time by adapting the last time step   in the case where the difference between the initial and final times is not a multiple of the time step.</li> <li>FMUDiscipline.set_next_execution   can be called several times before an execution.</li> <li><code>BaseFMUDiscipline._pre_instantiate</code> can now redefine time properties   relative to initial and final times, e.g. simulation time and current value.</li> <li>The points of a   TimeSeries   are interpreted as the starting points of the intervals of a stairs function   for FMU model inputs of causality <code>input</code>,   which is consistent with the FMU model input of causality <code>parameter</code>.</li> </ul>"},{"location":"changelog/#version-200-december-2023","title":"Version 2.0.0 (December 2023)","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Support for Python 3.11.</li> <li>The default behavior of   FMUDiscipline   is either simulating until the final time or during a time step;   it can also restart from initial time after each execution.</li> <li>FMUDiscipline.execute   can change the behavior of the   FMUDiscipline   temporarily, to simulate during a given simulation time, with a   different time step or from initial time.</li> <li>TimeSeries   allows to specify inputs as time series.</li> <li>gemseo-fmu.problems contains use cases,   either defined as FMUDiscipline   or simply as FMU files;   use get_fmu_file_path   to get a FMU file path easily.</li> <li>DoStepFMUDiscipline   is an FMUDiscipline   whose execution is only one time step ahead.</li> <li>TimeSteppingSystem   is a system of static and time-stepping disciplines   which executes them sequentially at each time step.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>The FMUDiscipline   relies on the library FMPy.</li> <li>FMUDiscipline   is in gemseo-fmu.disciplines.</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Support for Python 3.8.</li> </ul>"},{"location":"changelog/#version-101-june-2023","title":"Version 1.0.1 (June 2023)","text":"<p>Update to GEMSEO 5.</p>"},{"location":"changelog/#version-100-january-2023","title":"Version 1.0.0 (January 2023)","text":"<p>First release.</p>"},{"location":"getting_started/","title":"Getting started","text":""},{"location":"getting_started/#getting-started","title":"Getting started","text":"<p>GEMSEO-FMU is an extension of the open-source library GEMSEO for loading, interacting, and simulating Functional Mockup Unit models (FMUs). This extension is also open-source, under the LGPL v3 license.</p> <p>Installation</p>"},{"location":"getting_started/#fmu-discipline","title":"FMU discipline","text":"<p>The functional mock-up interface (FMI) is a popular free standard to exchange dynamic simulation models. This standard defines the notion of functional mock-up unit (FMU) through a ZIP file containg a mix of XML files, binaries and C code. GEMSEO-FMU proposes the FMUDiscipline as a particular MDODiscipline to simulate an FMU model.</p> <p>Read more Examples</p>"},{"location":"generated/examples/","title":"Examples","text":""},{"location":"generated/examples/#examples","title":"Examples","text":""},{"location":"generated/examples/disciplines/","title":"Disciplines","text":""},{"location":"generated/examples/disciplines/#disciplines","title":"Disciplines","text":""},{"location":"generated/examples/disciplines/#dynamic-fmu-discipline","title":"Dynamic FMU discipline","text":"<p>Info</p> <p>FMUDiscipline is an alias of DynamicFMUDiscipline and can be used to simulate both time-dependent and time-independent FMU models. Most of the time, the FMU model are dynamic and so this naming shortcut can be useful. However, to avoid any confusion, we prefer to use DynamicFMUDiscipline.</p> <p> Time as a character string. </p> <p> Plot a time evolution </p> <p> Use time stepping </p> <p> From initial time to final time </p> <p> Do not restart </p> <p> Use time functions </p> <p> Use time series </p> <p> Set evaluation time </p>"},{"location":"generated/examples/disciplines/#static-fmu-discipline","title":"Static FMU discipline","text":"<p> Static discipline </p> <p> Download all examples in Python source code: disciplines_python.zip</p> <p> Download all examples in Jupyter notebooks: disciplines_jupyter.zip</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/disciplines/dynamic/mg_execution_times/","title":"Computation times","text":"<p>00:03.116 total execution time for generated_examples_disciplines_dynamic files:</p> <p>+---------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_string_time (docs/examples/disciplines/dynamic/plot_string_time.py)                                                             | 00:00.952 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_plot_time_evolution (docs/examples/disciplines/dynamic/plot_plot_time_evolution.py)                                     | 00:00.456 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_time_series (docs/examples/disciplines/dynamic/plot_time_series.py)                                                             | 00:00.422 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_time_function (docs/examples/disciplines/dynamic/plot_time_function.py)                                                       | 00:00.398 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_evaluation_time (docs/examples/disciplines/dynamic/plot_evaluation_time.py)                                                 | 00:00.284 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_from_initial_time_to_final_time (docs/examples/disciplines/dynamic/plot_from_initial_time_to_final_time.py) | 00:00.263 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_restart_false (docs/examples/disciplines/dynamic/plot_restart_false.py)                                                       | 00:00.202 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_do_step (docs/examples/disciplines/dynamic/plot_do_step.py)                                                                         | 00:00.138 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/examples/disciplines/dynamic/plot_do_step/","title":"Plot do step","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/disciplines/dynamic/plot_do_step/#use-time-stepping","title":"Use time stepping","text":"<p>The DoStepFMUDiscipline can be used to simulate a co-simulation FMU model by manually advancing one step at a time.</p> <pre><code>from __future__ import annotations\n\nfrom matplotlib import pyplot as plt\n\nfrom gemseo_fmu.disciplines.do_step_fmu_discipline import DoStepFMUDiscipline\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\n</code></pre> <p>Let us create a discipline to simulate a mass damper defined in an FMU model from 0 to 1 second with a time step of 0.1 millisecond:</p> <p></p> <p>We only use the mass of the sliding mass [kg] and the spring constant [N/m] as inputs. The position of the mass [m] is used as output.</p> <pre><code>discipline = DoStepFMUDiscipline(\n    get_fmu_file_path(\"Mass_Damper\"),\n    [\"mass.m\", \"spring.c\"],\n    [\"y\"],\n    initial_time=0.0,\n    final_time=1.0,\n    time_step=0.0001,\n)\n</code></pre> <p>Then, we execute the discipline 10 times and create the graph as we go along with different point colors. In that case, executing the discipline 10 times means that we are advancing 10 times by one time step.</p> <pre><code>for _ in range(10):\n    discipline.execute()\n    plt.scatter(\n        discipline.time,\n        discipline.local_data[\"y\"],\n    )\nplt.xlabel(\"Time [s]\")\nplt.ylabel(\"Amplitude [m]\")\nplt.show()\n</code></pre> <p></p> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib/python3.9/site-packages/pydantic/main.py:509: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n</code></pre> <p>Note</p> <p>We can also do time stepping with DynamicFMUDiscipline by setting <code>do_step</code> to <code>False</code> and <code>restart</code> to <code>False</code>.</p> <p>Total running time of the script: ( 0 minutes  0.138 seconds)</p> <p> Download Python source code: plot_do_step.py</p> <p> Download Jupyter notebook: plot_do_step.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/disciplines/dynamic/plot_evaluation_time/","title":"Plot evaluation time","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/disciplines/dynamic/plot_evaluation_time/#set-evaluation-time","title":"Set evaluation time","text":"<p>Instead of simulating an FMU model from an initial time to a final time in one go, we may want to simulate it time window by time window.</p> <p>The DynamicFMUDiscipline makes this possible.</p> <pre><code>from __future__ import annotations\n\nfrom matplotlib import pyplot as plt\n\nfrom gemseo_fmu.disciplines.dynamic_fmu_discipline import DynamicFMUDiscipline\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\n</code></pre> <p>Let us create a discipline to simulate a mass damper defined in an FMU model from 0 to 1 second with a time step of 0.1 milliseconds:</p> <p></p> <p>We only use the mass of the sliding mass [kg] and the spring constant [N/m] as inputs. The position of the mass [m] is used as output.</p> <pre><code>discipline = DynamicFMUDiscipline(\n    get_fmu_file_path(\"Mass_Damper\"),\n    [\"mass.m\", \"spring.c\"],\n    [\"y\"],\n    initial_time=0.0,\n    final_time=1.0,\n    time_step=0.0001,\n)\n</code></pre> <p>Firstly, we execute the discipline setting a simulation time of 0.3 seconds with the default input values:</p> <pre><code>discipline.set_next_execution(simulation_time=0.3)\ndiscipline.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib/python3.9/site-packages/pydantic/main.py:509: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'mass.m': array([1.]), 'spring.c': array([10000.]), 'y': array([ 0.00000000e+00,  0.00000000e+00, -5.00000000e-05, ...,\n       -4.92042818e-01, -4.90752654e-01, -4.89464576e-01]), 'Mass_Damper:time': array([0.000e+00, 1.000e-04, 2.000e-04, ..., 2.998e-01, 2.999e-01,\n       3.000e-01])}\n</code></pre> <p>and store the results:</p> <pre><code>default_1 = (discipline.time, discipline.local_data[\"y\"])\n</code></pre> <p>Then, we repeat the experiment until the final time:</p> <pre><code>discipline.set_next_execution(restart=False)\ndiscipline.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib/python3.9/site-packages/pydantic/main.py:509: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\nThe cumulated simulation time (1.0) of the FMUDiscipline 'Mass_Damper' exceeds its final time set at instantiation (1.0); stop its simulation at final time.\n\n{'mass.m': array([1.]), 'spring.c': array([10000.]), 'y': array([-0.48946458, -0.48817871, -0.48689518, ..., -0.49567838,\n       -0.49564567, -0.49561344]), 'Mass_Damper:time': array([0.3   , 0.3001, 0.3002, ..., 0.9998, 0.9999, 1.    ])}\n</code></pre> <p>and store the results:</p> <pre><code>default_2 = (discipline.time, discipline.local_data[\"y\"])\n</code></pre> <p>Thirdly, we restart the discipline (default setting) and execute the discipline setting a simulation time of 0.3 seconds with custom input values:</p> <pre><code>discipline.set_next_execution(simulation_time=0.3)\ndiscipline.execute({\"mass.m\": 1.5, \"spring.c\": 1050.0})\n</code></pre> <p>Out:</p> <pre><code>{'mass.m': 1.5, 'spring.c': 1050.0, 'y': array([ 0.00000000e+00,  0.00000000e+00, -3.50000000e-06, ...,\n       -4.79620768e-01, -4.80116604e-01, -4.80612253e-01]), 'Mass_Damper:time': array([0.000e+00, 1.000e-04, 2.000e-04, ..., 2.998e-01, 2.999e-01,\n       3.000e-01])}\n</code></pre> <p>and store the results:</p> <pre><code>custom_1 = (discipline.time, discipline.local_data[\"y\"])\n</code></pre> <p>Then, we repeat the experiment until the final time with the same custom input values:</p> <pre><code>discipline.set_next_execution(restart=False)\ndiscipline.execute({\"mass.m\": 1.5, \"spring.c\": 1050.0})\n</code></pre> <p>Out:</p> <pre><code>The cumulated simulation time (1.0) of the FMUDiscipline 'Mass_Damper' exceeds its final time set at instantiation (1.0); stop its simulation at final time.\n\n{'mass.m': 1.5, 'spring.c': 1050.0, 'y': array([-0.48061225, -0.48110771, -0.48160297, ..., -0.48980401,\n       -0.48984827, -0.48989259]), 'Mass_Damper:time': array([0.3   , 0.3001, 0.3002, ..., 0.9998, 0.9999, 1.    ])}\n</code></pre> <p>and store the results:</p> <pre><code>custom_2 = (discipline.time, discipline.local_data[\"y\"])\n</code></pre> <p>Lastly, we use a chart to compare the default and custom results:</p> <pre><code>plt.plot(*default_1, label=\"Default 1/2\")\nplt.plot(*default_2, label=\"Default 2/2\")\nplt.plot(*custom_1, label=\"Custom 1/2\")\nplt.plot(*custom_2, label=\"Custom 2/2\")\nplt.xlabel(\"Time [s]\")\nplt.ylabel(\"Amplitude [m]\")\nplt.legend()\nplt.show()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  0.284 seconds)</p> <p> Download Python source code: plot_evaluation_time.py</p> <p> Download Jupyter notebook: plot_evaluation_time.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/disciplines/dynamic/plot_from_initial_time_to_final_time/","title":"Plot from initial time to final time","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/disciplines/dynamic/plot_from_initial_time_to_final_time/#from-initial-time-to-final-time","title":"From initial time to final time","text":"<p>The most obvious use of the DynamicFMUDiscipline is to simulate an FMU model from an initial time to a final time in one go.</p> <pre><code>from __future__ import annotations\n\nfrom matplotlib import pyplot as plt\n\nfrom gemseo_fmu.disciplines.dynamic_fmu_discipline import DynamicFMUDiscipline\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\n</code></pre> <p>Let us create a discipline to simulate a mass damper defined in a FMU model from 0 to 1 second with a time step of 0.1 millisecond:</p> <p></p> <p>We only use the mass of the sliding mass [kg] and the spring constant [N/m] as inputs and the position of the mass [m] as output.</p> <pre><code>discipline = DynamicFMUDiscipline(\n    get_fmu_file_path(\"Mass_Damper\"),\n    [\"mass.m\", \"spring.c\"],\n    [\"y\"],\n    initial_time=0.0,\n    final_time=1.0,\n    time_step=0.0001,\n)\n</code></pre> <p>Firstly, we simulate the FMU with the default input values:</p> <pre><code>discipline.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib/python3.9/site-packages/pydantic/main.py:509: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'mass.m': array([1.]), 'spring.c': array([10000.]), 'y': array([ 0.00000000e+00,  0.00000000e+00, -5.00000000e-05, ...,\n       -4.95678376e-01, -4.95645675e-01, -4.95613439e-01]), 'Mass_Damper:time': array([0.000e+00, 1.000e-04, 2.000e-04, ..., 9.998e-01, 9.999e-01,\n       1.000e+00])}\n</code></pre> <p>and store the time evolution of the position of the mass:</p> <pre><code>default_y_evolution = discipline.local_data[\"y\"]\n</code></pre> <p>Then, we repeat the experiment with custom values of the mass and spring constants:</p> <pre><code>discipline.execute({\"mass.m\": 1.5, \"spring.c\": 1050.0})\n</code></pre> <p>Out:</p> <pre><code>{'mass.m': 1.5, 'spring.c': 1050.0, 'y': array([ 0.00000000e+00,  0.00000000e+00, -3.50000000e-06, ...,\n       -4.89804005e-01, -4.89848274e-01, -4.89892585e-01]), 'Mass_Damper:time': array([0.000e+00, 1.000e-04, 2.000e-04, ..., 9.998e-01, 9.999e-01,\n       1.000e+00])}\n</code></pre> <p>Lastly, we use a chart to compare the positions of the mass:</p> <pre><code>plt.plot(discipline.time, default_y_evolution, label=\"Default\")\nplt.plot(discipline.time, discipline.local_data[\"y\"], label=\"Custom\")\nplt.xlabel(\"Time [s]\")\nplt.ylabel(\"Amplitude [m]\")\nplt.legend()\nplt.show()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  0.263 seconds)</p> <p> Download Python source code: plot_from_initial_time_to_final_time.py</p> <p> Download Jupyter notebook: plot_from_initial_time_to_final_time.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/disciplines/dynamic/plot_plot_time_evolution/","title":"Plot plot time evolution","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/disciplines/dynamic/plot_plot_time_evolution/#plot-a-time-evolution","title":"Plot a time evolution","text":"<p>The time evolution of a discipline output can easily be plotted, using the FMUDiscipline.plot method.</p> <pre><code>from __future__ import annotations\n\nfrom gemseo_fmu.disciplines.dynamic_fmu_discipline import DynamicFMUDiscipline\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\n</code></pre> <p>Let us create a discipline to simulate a mass damper defined in an FMU model from 0 to 1 second with a time step of 0.1 milliseconds:</p> <p></p> <p>We only use the mass of the sliding mass [kg] and the spring constant [N/m] as inputs. The position of the mass [m] is used as output.</p> <pre><code>discipline = DynamicFMUDiscipline(\n    get_fmu_file_path(\"Mass_Damper\"),\n    [\"mass.m\", \"spring.c\"],\n    [\"y\"],\n    initial_time=0.0,\n    final_time=1.0,\n    time_step=0.0001,\n)\n</code></pre> <p>Firstly, we execute the discipline:</p> <pre><code>discipline.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib/python3.9/site-packages/pydantic/main.py:509: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'mass.m': array([1.]), 'spring.c': array([10000.]), 'y': array([ 0.00000000e+00,  0.00000000e+00, -5.00000000e-05, ...,\n       -4.95678376e-01, -4.95645675e-01, -4.95613439e-01]), 'Mass_Damper:time': array([0.000e+00, 1.000e-04, 2.000e-04, ..., 9.998e-01, 9.999e-01,\n       1.000e+00])}\n</code></pre> <p>Then, we can easily access the local data, e.g the output <code>\"y\"</code>:</p> <pre><code>discipline.local_data[\"y\"]\n</code></pre> <p>Out:</p> <pre><code>array([ 0.00000000e+00,  0.00000000e+00, -5.00000000e-05, ...,\n       -4.95678376e-01, -4.95645675e-01, -4.95613439e-01])\n</code></pre> <p>But it is not very easy to read and plotting the time evolution of this variable is a better option:</p> <pre><code>discipline.plot(\"y\", save=False, show=True)\n</code></pre> <p></p> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to Dataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to Dataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n\n&lt;gemseo.post.dataset.lines.Lines object at 0x7f0d22e8f370&gt;\n</code></pre> <p>We can also restrict the view to a specific time window defined by the start time index:</p> <pre><code>discipline.plot(\"y\", time_window=3000, save=False, show=True)\n</code></pre> <p></p> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to Dataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n\n&lt;gemseo.post.dataset.lines.Lines object at 0x7f0d37649b20&gt;\n</code></pre> <p>or both the start and end time indices:</p> <pre><code>discipline.plot(\"y\", time_window=[3000, 7000], save=False, show=True)\n</code></pre> <p></p> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.9/site-packages/pandas/core/frame.py:706: DeprecationWarning: Passing a BlockManager to Dataset is deprecated and will raise in a future version. Use public APIs instead.\n  warnings.warn(\n\n&lt;gemseo.post.dataset.lines.Lines object at 0x7f0d1f3b26a0&gt;\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.456 seconds)</p> <p> Download Python source code: plot_plot_time_evolution.py</p> <p> Download Jupyter notebook: plot_plot_time_evolution.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/disciplines/dynamic/plot_restart_false/","title":"Plot restart false","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/disciplines/dynamic/plot_restart_false/#do-not-restart","title":"Do not restart","text":"<p>In some situations, we may want to configure the DynamicFMUDiscipline so that each execution starts where the previous one stopped.</p> <pre><code>from __future__ import annotations\n\nfrom matplotlib import pyplot as plt\n\nfrom gemseo_fmu.disciplines.dynamic_fmu_discipline import DynamicFMUDiscipline\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\n</code></pre> <p>Let us create a discipline to simulate a mass damper defined in an FMU model from 0 to 1 second with a time step of 0.1 milliseconds:</p> <p></p> <p>We only use the mass of the sliding mass [kg] and the spring constant [N/m] as inputs. The position of the mass [m] is used as output.</p> <pre><code>discipline = DynamicFMUDiscipline(\n    get_fmu_file_path(\"Mass_Damper\"),\n    [\"mass.m\", \"spring.c\"],\n    [\"y\"],\n    initial_time=0.0,\n    final_time=1.0,\n    time_step=0.0001,\n    restart=False,\n)\n</code></pre> <p>Note</p> <p>We had to set <code>restart</code> to <code>False</code> as the default behavior of the DynamicFMUDiscipline is to run each execution from the start time.</p> <p>Then, we execute the discipline setting a simulation time of 0.3 seconds with the default input values:</p> <pre><code>discipline.set_next_execution(simulation_time=0.3)\ndiscipline.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib/python3.9/site-packages/pydantic/main.py:509: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'mass.m': array([1.]), 'spring.c': array([10000.]), 'y': array([ 0.00000000e+00,  0.00000000e+00, -5.00000000e-05, ...,\n       -4.92042818e-01, -4.90752654e-01, -4.89464576e-01]), 'Mass_Damper:time': array([0.000e+00, 1.000e-04, 2.000e-04, ..., 2.998e-01, 2.999e-01,\n       3.000e-01])}\n</code></pre> <p>and store the time evolution of the position of the mass:</p> <pre><code>time_evolution_1 = (discipline.time, discipline.local_data[\"y\"])\n</code></pre> <p>We repeat this experiment with custom input values:</p> <pre><code>discipline.set_next_execution(simulation_time=0.3)\ndiscipline.execute({\"mass.m\": 1.5, \"spring.c\": 1050.0})\n</code></pre> <p>Out:</p> <pre><code>{'mass.m': 1.5, 'spring.c': 1050.0, 'y': array([-0.48946458, -0.48817871, -0.48689378, ..., -0.31740528,\n       -0.31748476, -0.31756546]), 'Mass_Damper:time': array([0.3   , 0.3001, 0.3002, ..., 0.5998, 0.5999, 0.6   ])}\n</code></pre> <p>store the results:</p> <pre><code>time_evolution_2 = (discipline.time, discipline.local_data[\"y\"])\n</code></pre> <p>and execute the discipline until the final time:</p> <pre><code>discipline.execute()\ntime_evolution_3 = (discipline.time, discipline.local_data[\"y\"])\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib/python3.9/site-packages/pydantic/main.py:509: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\nThe cumulated simulation time (1.0) of the FMUDiscipline 'Mass_Damper' exceeds its final time set at instantiation (1.0); stop its simulation at final time.\n</code></pre> <p>Lastly, we draw this trajectory on a chart:</p> <pre><code>plt.plot(*time_evolution_1, label=\"Default 1/3\")\nplt.plot(*time_evolution_2, label=\"Default 2/3\")\nplt.plot(*time_evolution_3, label=\"Default 3/3\")\nplt.xlabel(\"Time [s]\")\nplt.ylabel(\"Amplitude [m]\")\nplt.legend()\nplt.show()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  0.202 seconds)</p> <p> Download Python source code: plot_restart_false.py</p> <p> Download Jupyter notebook: plot_restart_false.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/disciplines/dynamic/plot_string_time/","title":"Plot string time","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/disciplines/dynamic/plot_string_time/#time-as-a-character-string","title":"Time as a character string.","text":"<p>Time information can often be specified either in seconds or as a string written in natural language, e.g. <code>\"2h 34m 1s\"</code> or <code>\"2 hours, 34 minutes and 1 second\"</code> (units include y, m, w, d, h, min, s, ms).</p> <pre><code>from __future__ import annotations\n\nfrom matplotlib import pyplot as plt\n\nfrom gemseo_fmu.disciplines.dynamic_fmu_discipline import DynamicFMUDiscipline\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\n</code></pre> <p>Let us create and use a discipline to simulate a mass damper defined in a FMU model from 0 to 1 second with a time step of 0.1 millisecond:</p> <p></p> <p>Here, we express the final time and time step in natural language with <code>\"1 second\"</code> and <code>\"0.1ms\"</code> instead of <code>1</code> and <code>0.0001</code>.</p> <pre><code>discipline = DynamicFMUDiscipline(\n    get_fmu_file_path(\"Mass_Damper\"),\n    [\"mass.m\", \"spring.c\"],\n    [\"y\"],\n    initial_time=0.0,\n    final_time=\"1 second\",\n    time_step=\"0.1ms\",\n)\ndiscipline.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib/python3.9/site-packages/pydantic/main.py:509: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'mass.m': array([1.]), 'spring.c': array([10000.]), 'y': array([ 0.00000000e+00,  0.00000000e+00, -5.00000000e-05, ...,\n       -4.95678376e-01, -4.95645675e-01, -4.95613439e-01]), 'Mass_Damper:time': array([0.000e+00, 1.000e-04, 2.000e-04, ..., 9.998e-01, 9.999e-01,\n       1.000e+00])}\n</code></pre> <p>We can plot the time-evolution of the position of the mass:</p> <pre><code>plt.plot(discipline.time, discipline.local_data[\"y\"])\nplt.xlabel(\"Time [s]\")\nplt.ylabel(\"Amplitude [m]\")\nplt.show()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  0.952 seconds)</p> <p> Download Python source code: plot_string_time.py</p> <p> Download Jupyter notebook: plot_string_time.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/disciplines/dynamic/plot_time_function/","title":"Plot time function","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/disciplines/dynamic/plot_time_function/#use-time-functions","title":"Use time functions","text":"<p>The input variables with <code>input</code> causality as well as some input variables with <code>parameter</code> causality can be set with time functions.</p> <pre><code>from __future__ import annotations\n\nfrom matplotlib import pyplot as plt\n\nfrom gemseo_fmu.disciplines.dynamic_fmu_discipline import DynamicFMUDiscipline\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\n</code></pre> <p>Let us create a discipline to simulate a mass damper defined in a FMU model from 0 to 1 second with a time step of 0.1 millisecond:</p> <p></p> <p>We only use the mass of the sliding mass [kg] and the spring constant [N/m] as inputs and the position of the mass [m] as output.</p> <pre><code>discipline = DynamicFMUDiscipline(\n    get_fmu_file_path(\"Mass_Damper\"),\n    [\"mass.m\", \"spring.c\"],\n    [\"y\"],\n    initial_time=0.0,\n    final_time=1.0,\n    time_step=0.0001,\n)\n</code></pre> <p>Firstly, we simulate the FMU with the default input values, and in particular a constant value for the mass:</p> <pre><code>discipline.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib/python3.9/site-packages/pydantic/main.py:509: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'mass.m': array([1.]), 'spring.c': array([10000.]), 'y': array([ 0.00000000e+00,  0.00000000e+00, -5.00000000e-05, ...,\n       -4.95678376e-01, -4.95645675e-01, -4.95613439e-01]), 'Mass_Damper:time': array([0.000e+00, 1.000e-04, 2.000e-04, ..., 9.998e-01, 9.999e-01,\n       1.000e+00])}\n</code></pre> <p>and store the time evolution of its position:</p> <pre><code>default_y_evolution = discipline.local_data[\"y\"]\ndefault_mass = discipline.local_data[\"mass.m\"]\n</code></pre> <p>Then, we repeat the experiment with a time linear function for the mass:</p> <pre><code>discipline.execute({\"mass.m\": lambda t: 4 - 3 * t})\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib/python3.9/site-packages/pydantic/main.py:509: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'mass.m': array([1.    , 3.9997, 3.9994, ..., 1.0006, 1.0003, 1.    ]), 'spring.c': array([10000.]), 'y': array([ 0.00000000e+00,  0.00000000e+00, -1.25000000e-05, ...,\n       -5.36841710e-01, -5.36575518e-01, -5.36305911e-01]), 'Mass_Damper:time': array([0.000e+00, 1.000e-04, 2.000e-04, ..., 9.998e-01, 9.999e-01,\n       1.000e+00])}\n</code></pre> <p>Lastly, we use a chart to compare the positions of the mass:</p> <pre><code>fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)\nax1.plot(discipline.time, default_y_evolution, label=\"Default\")\np = ax1.plot(discipline.time, discipline.local_data[\"y\"], label=\"Custom\")\nax1.set_ylabel(\"Amplitude [m]\")\nax1.legend()\nax2.axhline(default_mass, label=\"Default\")\nax2.plot(\n    discipline.time,\n    discipline.local_data[\"mass.m\"],\n    label=\"Custom\",\n    color=p[0].get_color(),\n)\nax2.set_ylabel(\"Mass [kg]\")\nplt.xlabel(\"Time [s]\")\nax2.legend()\nplt.show()\n</code></pre> <p></p> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.9/site-packages/matplotlib/cbook.py:1699: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return math.isfinite(val)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.398 seconds)</p> <p> Download Python source code: plot_time_function.py</p> <p> Download Jupyter notebook: plot_time_function.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/disciplines/dynamic/plot_time_series/","title":"Plot time series","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/disciplines/dynamic/plot_time_series/#use-time-series","title":"Use time series","text":"<p>The input variables with <code>input</code> causality as well as some input variables with <code>parameter</code> causality can be set with time series.</p> <pre><code>from __future__ import annotations\n\nfrom matplotlib import pyplot as plt\n\nfrom gemseo_fmu.disciplines.dynamic_fmu_discipline import DynamicFMUDiscipline\nfrom gemseo_fmu.disciplines.time_series import TimeSeries\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\n</code></pre> <p>Let us create a discipline to simulate a mass damper defined in a FMU model from 0 to 1 second with a time step of 0.1 millisecond:</p> <p></p> <p>We only use the mass of the sliding mass [kg] and the spring constant [N/m] as inputs and the position of the mass [m] as output.</p> <pre><code>discipline = DynamicFMUDiscipline(\n    get_fmu_file_path(\"Mass_Damper\"),\n    [\"mass.m\", \"spring.c\"],\n    [\"y\"],\n    initial_time=0.0,\n    final_time=1.0,\n    time_step=0.0001,\n)\n</code></pre> <p>Firstly, we simulate the FMU with the default input values, and in particular a constant value for the mass:</p> <pre><code>discipline.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib/python3.9/site-packages/pydantic/main.py:509: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'mass.m': array([1.]), 'spring.c': array([10000.]), 'y': array([ 0.00000000e+00,  0.00000000e+00, -5.00000000e-05, ...,\n       -4.95678376e-01, -4.95645675e-01, -4.95613439e-01]), 'Mass_Damper:time': array([0.000e+00, 1.000e-04, 2.000e-04, ..., 9.998e-01, 9.999e-01,\n       1.000e+00])}\n</code></pre> <p>and store the time evolution of both its position and the mass:</p> <pre><code>default_y_evolution = discipline.local_data[\"y\"]\ndefault_mass = discipline.local_data[\"mass.m\"]\n</code></pre> <p>Then, we repeat the experiment with a custom time series for the mass, characterized by a sharp change after 0.5 seconds.</p> <pre><code>time_series = TimeSeries(time=[0.0, 0.25, 0.5, 1.0], observable=[4.0, 2.0, 0.2, 0.1])\ndiscipline.execute({\"mass.m\": time_series})\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib/python3.9/site-packages/pydantic/main.py:509: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'mass.m': array([4. , 4. , 4. , ..., 0.2, 0.2, 0.1]), 'spring.c': array([10000.]), 'y': array([ 0.00000000e+00,  0.00000000e+00, -1.25000000e-05, ...,\n       -5.00001066e-01, -5.00001049e-01, -5.00001032e-01]), 'Mass_Damper:time': array([0.000e+00, 1.000e-04, 2.000e-04, ..., 9.998e-01, 9.999e-01,\n       1.000e+00])}\n</code></pre> <p>Lastly, we use a chart to compare the positions of the mass:</p> <pre><code>fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)\nax1.plot(discipline.time, default_y_evolution, label=\"Default\")\np = ax1.plot(discipline.time, discipline.local_data[\"y\"], label=\"Custom\")\nax1.set_ylabel(\"Amplitude [m]\")\nax1.legend()\nax2.axhline(default_mass, label=\"Default\")\nax2.plot(\n    discipline.time,\n    discipline.local_data[\"mass.m\"],\n    label=\"Custom\",\n    color=p[0].get_color(),\n)\nax2.set_ylabel(\"Mass [kg]\")\nplt.xlabel(\"Time [s]\")\nax2.legend()\nplt.show()\n</code></pre> <p></p> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.9/site-packages/matplotlib/cbook.py:1699: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return math.isfinite(val)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.422 seconds)</p> <p> Download Python source code: plot_time_series.py</p> <p> Download Jupyter notebook: plot_time_series.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/disciplines/static/mg_execution_times/","title":"Computation times","text":"<p>00:00.038 total execution time for generated_examples_disciplines_static files:</p> <p>+--------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_static_discipline (docs/examples/disciplines/static/plot_static_discipline.py) | 00:00.038 | 0.0 MB | +--------------------------------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/examples/disciplines/static/plot_static_discipline/","title":"Plot static discipline","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/disciplines/static/plot_static_discipline/#static-discipline","title":"Static discipline","text":"<p>The StaticFMUDiscipline can be used to simulate a time-independent FMU model.</p> <pre><code>from __future__ import annotations\n\nfrom gemseo_fmu.disciplines.static_fmu_discipline import StaticFMUDiscipline\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\n</code></pre> <p>Let us create a discipline based on an FMU model computing the output \\(y\\) from the inputs \\(u_1\\) and \\(u_2\\) as \\(y=f(u_1,u_2)=k_1u_1+k_2u_2\\):</p> <pre><code>discipline = StaticFMUDiscipline(get_fmu_file_path(\"add\"))\n</code></pre> <p>We can have a look to the default inputs:</p> <pre><code>discipline.default_inputs\n</code></pre> <p>Out:</p> <pre><code>{'add.k2': array([1.]), 'add.k1': array([1.]), 'u2': array([0.]), 'u1': array([0.])}\n</code></pre> <p>and see that they are equal to zero. We can also see that \\(k_1\\) and \\(k_2\\) are discipline inputs in the same way as \\(u_1\\) and \\(u_2\\). However, their causality is parameter while the causality of \\(u_1\\) and \\(u_2\\) is parameter:</p> <pre><code>discipline.causalities_to_variable_names\n</code></pre> <p>Out:</p> <pre><code>{'input': ['u1', 'u2'], 'output': ['y'], 'parameter': ['add.k1', 'add.k2'], 'local': ['add.u1', 'add.u2', 'add.y']}\n</code></pre> <p>Then, we can execute the discipline with the default input values</p> <pre><code>discipline.execute()\ndiscipline.get_output_data()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib/python3.9/site-packages/pydantic/main.py:509: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'y': array([0.])}\n</code></pre> <p>and check that the output is equal to 0 as expected. Then, we can execute this discipline with new input values:</p> <pre><code>discipline.execute({\"u1\": 2.0, \"u2\": 3.0})\ndiscipline.get_output_data()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib/python3.9/site-packages/pydantic/main.py:509: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'y': array([5.])}\n</code></pre> <p>and check that the output is equal to 5 as expected. Lastly, we can also change the values of the inputs with parameter causality:</p> <pre><code>discipline.execute({\"u1\": 2.0, \"u2\": 3.0, \"add.k1\": 4.0})\ndiscipline.get_output_data()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib/python3.9/site-packages/pydantic/main.py:509: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'y': array([11.])}\n</code></pre> <p>The output is equal to 11 as expected.</p> <p>Total running time of the script: ( 0 minutes  0.038 seconds)</p> <p> Download Python source code: plot_static_discipline.py</p> <p> Download Jupyter notebook: plot_static_discipline.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/time_stepping_systems/","title":"Time stepping systems","text":""},{"location":"generated/examples/time_stepping_systems/#time-stepping-systems","title":"Time stepping systems","text":"<p> Time stepping system. </p> <p> Time stepping system with multiple time steps. </p> <p> Download all examples in Python source code: time_stepping_systems_python.zip</p> <p> Download all examples in Jupyter notebooks: time_stepping_systems_jupyter.zip</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/time_stepping_systems/mg_execution_times/","title":"Computation times","text":"<p>00:11.429 total execution time for generated_examples_time_stepping_systems files:</p> <p>+-----------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_multiple_time_steps (docs/examples/time_stepping_systems/plot_multiple_time_steps.py) | 00:05.889 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_basic (docs/examples/time_stepping_systems/plot_basic.py)                                           | 00:05.540 | 0.0 MB | +-----------------------------------------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/examples/time_stepping_systems/plot_basic/","title":"Plot basic","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/time_stepping_systems/plot_basic/#time-stepping-system","title":"Time stepping system.","text":"<p>Sometimes, we may want to simulate a system of several FMU models coupled together. TimeSteppingSystem allows to perform this co-simulation task.</p> <pre><code>from __future__ import annotations\n\nfrom matplotlib import pyplot as plt\n\nfrom gemseo_fmu.disciplines.fmu_discipline import FMUDiscipline\nfrom gemseo_fmu.disciplines.time_stepping_system import TimeSteppingSystem\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\n</code></pre> <p>Let us consider a set of two mass-spring pairs connected to each other and modelled by two FMU models:</p> \\[ \\begin{cases} x_1' = v_1\\\\ v_1' = -\\frac{k_1+k_2}{m_1}x_1+\\frac{k_2}{m_1}x_2 \\end{cases} \\] <p>and</p> \\[ \\begin{cases} x_2' = v_2\\\\ v_2' = -\\frac{k_2+k_3}{m_2}x_2+\\frac{k_2}{m_2}x_1 \\end{cases} \\] <p>These models can be co-simulated by instantiating a TimeSteppingSystem:</p> <pre><code>system = TimeSteppingSystem(\n    (\n        get_fmu_file_path(\"MassSpringSubSystem1\"),\n        get_fmu_file_path(\"MassSpringSubSystem2\"),\n    ),\n    50,\n    0.01,\n)\n</code></pre> <p>and executing it from initial time to final time:</p> <pre><code>system.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib/python3.9/site-packages/pydantic/main.py:509: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'x2': array([1.        , 0.9998    , 0.999401  , ..., 1.23494196, 1.2589736 ,\n       1.2589736 ]), 'm2': array([1.]), 'k2': array([1.]), 'm1': array([1.]), 'k3': array([1.]), 'k1': array([1.]), 'x1': array([ 0.01      ,  0.0201    ,  0.030298  , ..., -0.35129848,\n       -0.35946757, -0.35946757]), 'MassSpringSubSystem1:time': array([1.000e-02, 2.000e-02, 3.000e-02, ..., 4.999e+01, 5.000e+01,\n       5.000e+01]), 'v1': array([ 1.01      ,  1.0198    ,  1.029396  , ..., -0.81690925,\n       -0.79753386, -0.79753386]), 'MassSpringSubSystem2:time': array([1.000e-02, 2.000e-02, 3.000e-02, ..., 4.999e+01, 5.000e+01,\n       5.000e+01]), 'v2': array([-0.02      , -0.0399    , -0.059695  , ...,  2.40316415,\n        2.37495232,  2.37495232])}\n</code></pre> <p>or with time stepping by setting <code>do_step</code> to <code>False</code> at instantiation. For this particular example, we also have a FMU model of the complete system:</p> <pre><code>reference = FMUDiscipline(\n    get_fmu_file_path(\"MassSpringSystem\"), final_time=50, time_step=0.01\n)\nreference.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib/python3.9/site-packages/pydantic/main.py:509: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'k1': array([1.]), 'k2': array([1.]), 'k3': array([1.]), 'm1': array([1.]), 'm2': array([1.]), 'v1': array([ 1.        ,  1.01      ,  1.0198    , ..., -0.83587438,\n       -0.81690925, -0.79753386]), 'v2': array([ 0.        , -0.02      , -0.0399    , ...,  2.43080622,\n        2.40316415,  2.37495232]), 'x1': array([ 0.        ,  0.01      ,  0.0201    , ..., -0.34293973,\n       -0.35129848, -0.35946757]), 'x2': array([1.        , 1.        , 0.9998    , ..., 1.21063389, 1.23494196,\n       1.2589736 ]), 'MassSpringSystem:time': array([0.000e+00, 1.000e-02, 2.000e-02, ..., 4.998e+01, 4.999e+01,\n       5.000e+01])}\n</code></pre> <p>Then, we can compare the solutions graphically in terms of position and velocity of the two masses and note that for this example, the co-simulation of the two subsystems is equivalent to that of the complete system.</p> <pre><code>fig, (ax1, ax2) = plt.subplots(2, 1)\ntime_1 = system.local_data[\"MassSpringSubSystem1:time\"]\ntime_2 = system.local_data[\"MassSpringSubSystem2:time\"]\nax1.plot(time_1, system.local_data[\"x1\"], label=\"x1\", color=\"red\")\nax1.plot(time_2, system.local_data[\"x2\"], label=\"x2\", color=\"blue\")\nax2.plot(time_1, system.local_data[\"v1\"], label=\"v1\", color=\"red\")\nax2.plot(time_2, system.local_data[\"v2\"], label=\"v2\", color=\"blue\")\n\ntime = reference.local_data[\"MassSpringSystem:time\"]\nax1.plot(time, reference.local_data[\"x1\"], label=\"x1[ref]\", linestyle=\"--\", color=\"red\")\nax1.plot(\n    time, reference.local_data[\"x2\"], label=\"x2[ref]\", linestyle=\"--\", color=\"blue\"\n)\nax2.plot(time, reference.local_data[\"v1\"], label=\"v1[ref]\", linestyle=\"--\", color=\"red\")\nax2.plot(\n    time, reference.local_data[\"v2\"], label=\"v2[ref]\", linestyle=\"--\", color=\"blue\"\n)\n\nax1.set_xlabel(\"Time (s)\")\nax1.set_ylabel(\"Position (m)\")\nax1.grid()\nax1.legend()\nax2.set_xlabel(\"Time (s)\")\nax2.set_ylabel(\"Velocity (m/s)\")\nax2.grid()\nax2.legend()\nplt.show()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  5.540 seconds)</p> <p> Download Python source code: plot_basic.py</p> <p> Download Jupyter notebook: plot_basic.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/time_stepping_systems/plot_multiple_time_steps/","title":"Plot multiple time steps","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/time_stepping_systems/plot_multiple_time_steps/#time-stepping-system-with-multiple-time-steps","title":"Time stepping system with multiple time steps.","text":"<p>Sometimes, we may want to simulate a system of several FMU models coupled together. TimeSteppingSystem allows to perform this co-simulation task, even in the presence of FMU models with variable time steps.</p> <pre><code>from __future__ import annotations\n\nfrom matplotlib import pyplot as plt\n\nfrom gemseo_fmu.disciplines.do_step_fmu_discipline import DoStepFMUDiscipline\nfrom gemseo_fmu.disciplines.fmu_discipline import FMUDiscipline\nfrom gemseo_fmu.disciplines.time_stepping_system import TimeSteppingSystem\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\n</code></pre> <p>Let us consider a set of two mass-spring pairs connected to each other and modelled by two FMU models:</p> \\[ \\begin{cases} x_1' = v_1\\\\ v_1' = -\\frac{k_1+k_2}{m_1}x_1+\\frac{k_2}{m_1}x_2 \\end{cases} \\] <p>and</p> \\[ \\begin{cases} x_2' = v_2\\\\ v_2' = -\\frac{k_2+k_3}{m_2}x_2+\\frac{k_2}{m_2}x_1 \\end{cases} \\] <p>These models can be modeled using the DoStepFMUDiscipline class. For illustration purposes, we use different time steps for these models:</p> <pre><code>sub_system_1 = DoStepFMUDiscipline(\n    get_fmu_file_path(\"MassSpringSubSystem1\"), time_step=0.004\n)\nsub_system_2 = DoStepFMUDiscipline(\n    get_fmu_file_path(\"MassSpringSubSystem2\"), time_step=0.01\n)\n</code></pre> <p>Note</p> <p>There is no need for one time step to be a multiple of the other.</p> <p>Then, these disciplines can be co-simulated by instantiating a TimeSteppingSystem.</p> <pre><code>system = TimeSteppingSystem(\n    (sub_system_1, sub_system_2), 50, 0.01, apply_time_step_to_disciplines=False\n)\n</code></pre> <p>and executing it from initial time to final time:</p> <pre><code>system.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib/python3.9/site-packages/pydantic/main.py:509: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'x2': array([1.        , 0.9998    , 0.999401  , ..., 1.03766458, 1.05780873,\n       1.05780873]), 'm2': array([1.]), 'k2': array([1.]), 'm1': array([1.]), 'k3': array([1.]), 'k1': array([1.]), 'x1': array([ 0.01003194,  0.02016259,  0.03038993, ..., -0.26450989,\n       -0.27054247, -0.27054247]), 'MassSpringSubSystem1:time': array([1.000e-02, 2.000e-02, 3.000e-02, ..., 4.999e+01, 5.000e+01,\n       5.000e+01]), 'v1': array([ 1.00993594,  1.0196706 ,  1.02920003, ..., -0.60827531,\n       -0.59256964, -0.59256964]), 'MassSpringSubSystem2:time': array([1.000e-02, 2.000e-02, 3.000e-02, ..., 4.999e+01, 5.000e+01,\n       5.000e+01]), 'v2': array([-0.02      , -0.03989968, -0.05969405, ...,  2.01441517,\n        1.99101678,  1.99101678])}\n</code></pre> <p>or with time stepping by setting <code>do_step</code> to <code>False</code> at instantiation.</p> <p>Note</p> <p>We set <code>apply_time_step_to_disciplines</code> to <code>False</code> at instantiation in order to let the disciplines use their own time steps. By default, the global time step passed at instantiation (0.1 in this example) is used by the disciplines.</p> <p>For this particular example, we also have a FMU model of the complete system:</p> <pre><code>reference = FMUDiscipline(\n    get_fmu_file_path(\"MassSpringSystem\"), final_time=50, time_step=0.01\n)\nreference.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib/python3.9/site-packages/pydantic/main.py:509: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'k1': array([1.]), 'k2': array([1.]), 'k3': array([1.]), 'm1': array([1.]), 'm2': array([1.]), 'v1': array([ 1.        ,  1.01      ,  1.0198    , ..., -0.83587438,\n       -0.81690925, -0.79753386]), 'v2': array([ 0.        , -0.02      , -0.0399    , ...,  2.43080622,\n        2.40316415,  2.37495232]), 'x1': array([ 0.        ,  0.01      ,  0.0201    , ..., -0.34293973,\n       -0.35129848, -0.35946757]), 'x2': array([1.        , 1.        , 0.9998    , ..., 1.21063389, 1.23494196,\n       1.2589736 ]), 'MassSpringSystem:time': array([0.000e+00, 1.000e-02, 2.000e-02, ..., 4.998e+01, 4.999e+01,\n       5.000e+01])}\n</code></pre> <p>Then, we can compare the solutions graphically in terms of position and velocity of the two masses and note that for this example, the co-simulation of the two subsystems is equivalent to that of the complete system.</p> <pre><code>fig, (ax1, ax2) = plt.subplots(2, 1)\ntime_1 = system.local_data[\"MassSpringSubSystem1:time\"]\ntime_2 = system.local_data[\"MassSpringSubSystem2:time\"]\nax1.plot(time_1, system.local_data[\"x1\"], label=\"x1\", color=\"red\")\nax1.plot(time_2, system.local_data[\"x2\"], label=\"x2\", color=\"blue\")\nax2.plot(time_1, system.local_data[\"v1\"], label=\"v1\", color=\"red\")\nax2.plot(time_2, system.local_data[\"v2\"], label=\"v2\", color=\"blue\")\n\ntime = reference.local_data[\"MassSpringSystem:time\"]\nax1.plot(time, reference.local_data[\"x1\"], label=\"x1[ref]\", linestyle=\"--\", color=\"red\")\nax1.plot(\n    time, reference.local_data[\"x2\"], label=\"x2[ref]\", linestyle=\"--\", color=\"blue\"\n)\nax2.plot(time, reference.local_data[\"v1\"], label=\"v1[ref]\", linestyle=\"--\", color=\"red\")\nax2.plot(\n    time, reference.local_data[\"v2\"], label=\"v2[ref]\", linestyle=\"--\", color=\"blue\"\n)\n\nax1.set_xlabel(\"Time (s)\")\nax1.set_ylabel(\"Position (m)\")\nax1.grid()\nax1.legend()\nax2.set_xlabel(\"Time (s)\")\nax2.set_ylabel(\"Velocity (m/s)\")\nax2.grid()\nax2.legend()\nplt.show()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  5.889 seconds)</p> <p> Download Python source code: plot_multiple_time_steps.py</p> <p> Download Jupyter notebook: plot_multiple_time_steps.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"reference/SUMMARY/","title":"Modules","text":"<ul> <li>gemseo_fmu<ul> <li>disciplines<ul> <li>base_fmu_discipline</li> <li>do_step_fmu_discipline</li> <li>dynamic_fmu_discipline</li> <li>fmu_discipline</li> <li>static_fmu_discipline</li> <li>time_series</li> <li>time_stepping_system</li> </ul> </li> <li>problems<ul> <li>fmu_files</li> </ul> </li> <li>utils<ul> <li>time_duration</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/gemseo_fmu/","title":"Code","text":""},{"location":"reference/gemseo_fmu/#gemseo_fmu","title":"gemseo_fmu","text":"<p>Entry point to gemseo fmu.</p>"},{"location":"reference/gemseo_fmu/disciplines/","title":"Disciplines","text":""},{"location":"reference/gemseo_fmu/disciplines/#gemseo_fmu.disciplines","title":"disciplines","text":"<p>Features to create a discipline from an FMU file.</p>"},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/","title":"Base fmu discipline","text":""},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline","title":"base_fmu_discipline","text":"<p>A base discipline wrapping a Functional Mockup Unit (FMU) model.</p>"},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline.BaseFMUDiscipline","title":"BaseFMUDiscipline","text":"<pre><code>BaseFMUDiscipline(\n    file_path: str | Path,\n    input_names: Iterable[str] | None = (),\n    output_names: Iterable[str] = (),\n    initial_time: TimeDurationType | None = None,\n    final_time: TimeDurationType | None = None,\n    time_step: TimeDurationType = 0.0,\n    add_time_to_output_grammar: bool = True,\n    restart: bool = True,\n    do_step: bool = False,\n    name: str = \"\",\n    use_co_simulation: bool = True,\n    solver_name: Solver = Solver.CVODE,\n    model_instance_directory: str | Path = \"\",\n    delete_model_instance_directory: bool = True,\n    **pre_instantiation_parameters: Any\n)\n</code></pre> <p>             Bases: <code>MDODiscipline</code></p> <p>A base discipline wrapping a Functional Mockup Unit (FMU) model.</p> <p>This discipline relies on FMPy.</p> <p>Initialize self.  See help(type(self)) for accurate signature.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>             (<code>str | Path</code>)         \u2013          <p>The path to the FMU model file.</p> </li> <li> <code>input_names</code>             (<code>Iterable[str] | None</code>, default:                 <code>()</code> )         \u2013          <p>The names of the FMU model inputs; if empty, use all the inputs and parameters of the FMU model; if <code>None</code>, do not use inputs.</p> </li> <li> <code>output_names</code>             (<code>Iterable[str]</code>, default:                 <code>()</code> )         \u2013          <p>The names of the FMU model outputs. if empty, use all the outputs of the FMU model.</p> </li> <li> <code>initial_time</code>             (<code>TimeDurationType | None</code>, default:                 <code>None</code> )         \u2013          <p>The initial time of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code>, use the start time defined in the FMU model if any; otherwise use 0.</p> </li> <li> <code>final_time</code>             (<code>TimeDurationType | None</code>, default:                 <code>None</code> )         \u2013          <p>The final time of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code>, use the stop time defined in the FMU model if any; otherwise use the initial time.</p> </li> <li> <code>time_step</code>             (<code>TimeDurationType</code>, default:                 <code>0.0</code> )         \u2013          <p>The time step of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>0.</code>, use the stop time defined in the FMU model if any; otherwise use <code>0.</code>.</p> </li> <li> <code>add_time_to_output_grammar</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the time is added to the output grammar.</p> </li> <li> <code>restart</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the model is restarted at <code>initial_time</code> after execution.</p> </li> <li> <code>do_step</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether the model is simulated over only one <code>time_step</code> when calling execute(). Otherwise, simulate the model from current time to final time in one go.</p> </li> <li> <code>name</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The name of the discipline. If empty, use the class name.</p> </li> <li> <code>use_co_simulation</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the co-simulation FMI type is used. Otherwise, use model-exchange FMI type. When <code>do_step</code> is <code>True</code>, the co-simulation FMI type is required.</p> </li> <li> <code>solver_name</code>             (<code>Solver</code>, default:                 <code>CVODE</code> )         \u2013          <p>The name of the solver to simulate a model-exchange model.</p> </li> <li> <code>model_instance_directory</code>             (<code>str | Path</code>, default:                 <code>''</code> )         \u2013          <p>The directory of the FMU instance, containing the files extracted from the FMU model file; if empty, let <code>fmpy</code> create a temporary directory.</p> </li> <li> <code>delete_model_instance_directory</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to delete the directory of the FMU instance when deleting the discipline.</p> </li> <li> <code>**pre_instantiation_parameters</code>             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>The parameters to be passed to <code>_pre_instantiate()</code>.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def __init__(\n    self,\n    file_path: str | Path,\n    input_names: Iterable[str] | None = (),\n    output_names: Iterable[str] = (),\n    initial_time: TimeDurationType | None = None,\n    final_time: TimeDurationType | None = None,\n    time_step: TimeDurationType = 0.0,\n    add_time_to_output_grammar: bool = True,\n    restart: bool = True,\n    do_step: bool = False,\n    name: str = \"\",\n    use_co_simulation: bool = True,\n    solver_name: Solver = Solver.CVODE,\n    model_instance_directory: str | Path = \"\",\n    delete_model_instance_directory: bool = True,\n    **pre_instantiation_parameters: Any,\n) -&gt; None:\n    \"\"\"\n    Args:\n        file_path: The path to the FMU model file.\n        input_names: The names of the FMU model inputs;\n            if empty, use all the inputs and parameters of the FMU model;\n            if `None`, do not use inputs.\n        output_names: The names of the FMU model outputs.\n            if empty, use all the outputs of the FMU model.\n        initial_time: The initial time of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None`, use the start time defined in the FMU model if any;\n            otherwise use 0.\n        final_time: The final time of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None`, use the stop time defined in the FMU model if any;\n            otherwise use the initial time.\n        time_step: The time step of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `0.`, use the stop time defined in the FMU model if any;\n            otherwise use `0.`.\n        add_time_to_output_grammar: Whether the time is added to the output grammar.\n        restart: Whether the model is restarted at `initial_time` after execution.\n        do_step: Whether the model is simulated over only one `time_step`\n            when calling\n            [execute()][gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.execute].\n            Otherwise, simulate the model from current time to final time in one go.\n        use_co_simulation: Whether the co-simulation FMI type is used.\n            Otherwise, use model-exchange FMI type.\n            When `do_step` is `True`, the co-simulation FMI type is required.\n        solver_name: The name of the solver to simulate a model-exchange model.\n        model_instance_directory: The directory of the FMU instance,\n            containing the files extracted from the FMU model file;\n            if empty, let `fmpy` create a temporary directory.\n        delete_model_instance_directory: Whether to delete the directory\n            of the FMU instance when deleting the discipline.\n        **pre_instantiation_parameters: The parameters to be passed\n            to `_pre_instantiate()`.\n    \"\"\"  # noqa: D205 D212 D415\n    self.__delete_model_instance_directory = delete_model_instance_directory\n    self.__executed = False\n    self.__names_to_time_functions = {}\n    self.__solver_name = str(solver_name)\n    self.name = self.__set_fmu_model(\n        file_path, model_instance_directory, do_step, use_co_simulation, name\n    )\n    self.__set_variable_names_references_and_causalities(input_names, output_names)\n    self.__set_initial_values()\n    self.__set_time(initial_time, final_time, time_step, do_step, restart)\n    self._pre_instantiate(**(pre_instantiation_parameters or {}))\n    super().__init__(\n        name=self.name,\n        cache_type=self.CacheType.NONE,\n        grammar_type=self.GrammarType.PYDANTIC,\n    )\n    self.__set_grammars(add_time_to_output_grammar)\n    self.default_inputs = {\n        input_name: self._initial_values[input_name]\n        for input_name in self.__input_names\n    }\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline.BaseFMUDiscipline-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline.BaseFMUDiscipline.causalities_to_variable_names","title":"causalities_to_variable_names  <code>property</code>","text":"<pre><code>causalities_to_variable_names: dict[str, list[str]]\n</code></pre> <p>The names of the variables sorted by causality.</p>"},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline.BaseFMUDiscipline.default_inputs","title":"default_inputs  <code>instance-attribute</code>","text":"<pre><code>default_inputs = {\n    input_name: _initial_values[input_name]\n    for input_name in __input_names\n}\n</code></pre> <p>The default inputs.</p>"},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline.BaseFMUDiscipline.model","title":"model  <code>property</code>","text":"<pre><code>model: FMUModel\n</code></pre> <p>The FMU model.</p>"},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline.BaseFMUDiscipline.model_description","title":"model_description  <code>property</code>","text":"<pre><code>model_description: ModelDescription\n</code></pre> <p>The description of the FMU model.</p>"},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline.BaseFMUDiscipline-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline.BaseFMUDiscipline.Solver","title":"Solver","text":"<p>             Bases: <code>StrEnum</code></p> <p>The solver to simulate a model-exchange model.</p>"},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline.BaseFMUDiscipline-functions","title":"Functions","text":""},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline.BaseFMUDiscipline.execute","title":"execute","text":"<pre><code>execute(\n    input_data: Mapping[\n        str,\n        ndarray\n        | TimeSeries\n        | Callable[[TimeDurationType], float],\n    ] = MappingProxyType({})\n) -&gt; DisciplineData\n</code></pre> <p>Execute the discipline.</p> <p>This method executes the discipline:</p> <ul> <li>Adds the default inputs to the <code>input_data</code>   if some inputs are not defined in input_data   but exist in :attr:<code>.MDODiscipline.default_inputs</code>.</li> <li>Checks whether the last execution of the discipline was called   with identical inputs, i.e. cached in :attr:<code>.MDODiscipline.cache</code>;   if so, directly returns <code>self.cache.get_output_cache(inputs)</code>.</li> <li>Caches the inputs.</li> <li>Checks the input data against :attr:<code>.MDODiscipline.input_grammar</code>.</li> <li>If :attr:<code>.MDODiscipline.data_processor</code> is not None, runs the preprocessor.</li> <li>Updates the status to :attr:<code>.MDODiscipline.ExecutionStatus.RUNNING</code>.</li> <li>Calls the :meth:<code>.MDODiscipline._run</code> method, that shall be defined.</li> <li>If :attr:<code>.MDODiscipline.data_processor</code> is not None, runs the postprocessor.</li> <li>Checks the output data.</li> <li>Caches the outputs.</li> <li>Updates the status to :attr:<code>.MDODiscipline.ExecutionStatus.DONE</code>   or :attr:<code>.MDODiscipline.ExecutionStatus.FAILED</code>.</li> <li>Updates summed execution time.</li> </ul> <p>Parameters:</p> <ul> <li> <code>input_data</code>             (<code>Mapping[str, ndarray | TimeSeries | Callable[[TimeDurationType], float]]</code>, default:                 <code>MappingProxyType({})</code> )         \u2013          <p>The input data needed to execute the discipline according to the discipline input grammar. If <code>None</code>, use the :attr:<code>.MDODiscipline.default_inputs</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DisciplineData</code>         \u2013          <p>The discipline local data after execution.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def execute(  # noqa:D102\n    self,\n    input_data: Mapping[\n        str, ndarray | TimeSeries | Callable[[TimeDurationType], float]\n    ] = MappingProxyType({}),\n) -&gt; DisciplineData:\n    self.__executed = True\n    full_input_data = self._filter_inputs(input_data)\n    self.__names_to_time_functions = {\n        name: value.compute\n        for name, value in full_input_data.items()\n        if isinstance(value, TimeSeries)\n    }\n    self.__names_to_time_functions.update({\n        name: value\n        for name, value in full_input_data.items()\n        if isinstance(value, Callable)\n    })\n    full_input_data.update({\n        name: array([value.observable[0]])\n        for name, value in full_input_data.items()\n        if isinstance(value, TimeSeries)\n    })\n    full_input_data.update({\n        name: array([value(self.__current_time)])\n        for name, value in full_input_data.items()\n        if isinstance(value, Callable)\n    })\n    return super().execute(full_input_data)\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline.BaseFMUDiscipline.set_default_execution","title":"set_default_execution","text":"<pre><code>set_default_execution(\n    do_step: bool | None = None,\n    final_time: TimeDurationType | None = None,\n    restart: bool | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None\n</code></pre> <p>Change the default simulation settings.</p> <p>Parameters:</p> <ul> <li> <code>do_step</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether the model is simulated over only one <code>time_step</code> when calling execute(). Otherwise, simulate the model from current time to final time in one go. If <code>None</code>, use the value considered at the instantiation.</p> </li> <li> <code>final_time</code>             (<code>TimeDurationType | None</code>, default:                 <code>None</code> )         \u2013          <p>The final time of the simulation; either a number in seconds or a string of characters (see TimeDuration); If <code>None</code>, use the value considered at the instantiation.</p> </li> <li> <code>restart</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to restart the model at <code>initial_time</code> before executing it; if <code>None</code>, use the value passed at the instantiation.</p> </li> <li> <code>time_step</code>             (<code>TimeDurationType | None</code>, default:                 <code>None</code> )         \u2013          <p>The time step of the simulation; either a number in seconds or a string of characters (see TimeDuration); If <code>None</code>, use the value considered at the instantiation.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def set_default_execution(\n    self,\n    do_step: bool | None = None,\n    final_time: TimeDurationType | None = None,\n    restart: bool | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None:\n    \"\"\"Change the default simulation settings.\n\n    Args:\n        do_step: Whether the model is simulated over only one `time_step`\n            when calling\n            [execute()][gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.execute].\n            Otherwise, simulate the model from current time to final time in one go.\n            If `None`, use the value considered at the instantiation.\n        final_time: The final time of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            If `None`, use the value considered at the instantiation.\n        restart: Whether to restart the model at `initial_time`\n            before executing it;\n            if `None`, use the value passed at the instantiation.\n        time_step: The time step of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            If `None`, use the value considered at the instantiation.\n    \"\"\"\n    if do_step is not None:\n        self.__do_step = do_step\n\n    if restart is not None:\n        self.__default_simulation_settings[self._RESTART] = restart\n\n    if final_time is not None:\n        final_time = TimeDuration(final_time).seconds\n        self._final_time = final_time\n\n    if time_step is not None:\n        time_step = TimeDuration(time_step).seconds\n        self.__default_simulation_settings[self._TIME_STEP] = time_step\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline.BaseFMUDiscipline.set_next_execution","title":"set_next_execution","text":"<pre><code>set_next_execution(\n    restart: bool | None = None,\n    simulation_time: TimeDurationType | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None\n</code></pre> <p>Change the simulation settings for the execution.</p> <p>Parameters:</p> <ul> <li> <code>restart</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to restart the model at <code>initial_time</code> before executing it; if <code>None</code>, use the value passed at the instantiation.</p> </li> <li> <code>simulation_time</code>             (<code>TimeDurationType | None</code>, default:                 <code>None</code> )         \u2013          <p>The duration of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code> and the <code>do_step</code> passed at instantiation is <code>False</code>, execute until the final time; if <code>None</code> and the <code>do_step</code> passed at instantiation is <code>True</code>, execute during a single time step.</p> </li> <li> <code>time_step</code>             (<code>TimeDurationType | None</code>, default:                 <code>None</code> )         \u2013          <p>The time step of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code>, use the value passed at the instantiation.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def set_next_execution(\n    self,\n    restart: bool | None = None,\n    simulation_time: TimeDurationType | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None:\n    \"\"\"Change the simulation settings for the execution.\n\n    Args:\n        restart: Whether to restart the model at `initial_time`\n            before executing it;\n            if `None`, use the value passed at the instantiation.\n        simulation_time: The duration of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None` and the `do_step` passed at instantiation is `False`,\n            execute until the final time;\n            if `None` and the `do_step` passed at instantiation is `True`,\n            execute during a single time step.\n        time_step: The time step of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None`, use the value passed at the instantiation.\n    \"\"\"  # noqa: D205 D212 D415\n    if not self.__simulation_settings:\n        self.__simulation_settings = self.__default_simulation_settings.copy()\n\n    if time_step is not None:\n        self.__simulation_settings[self._TIME_STEP] = TimeDuration(\n            time_step\n        ).seconds\n\n    if restart is not None:\n        self.__simulation_settings[self._RESTART] = restart\n\n    if simulation_time is not None:\n        simulation_time = TimeDuration(simulation_time).seconds\n        self.__simulation_settings[self._SIMULATION_TIME] = simulation_time\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/","title":"Do step fmu discipline","text":""},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline","title":"do_step_fmu_discipline","text":"<p>An FMU discipline whose execution simulates only one time step.</p>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline","title":"DoStepFMUDiscipline","text":"<pre><code>DoStepFMUDiscipline(\n    file_path: str | Path,\n    input_names: Iterable[str] | None = (),\n    output_names: Iterable[str] = (),\n    initial_time: TimeType | None = None,\n    final_time: TimeType | None = None,\n    time_step: TimeType = 0.0,\n    add_time_to_output_grammar: bool = True,\n    restart: bool = False,\n    name: str = \"\",\n    solver_name: Solver = FMUDiscipline.Solver.CVODE,\n    fmu_instance_directory: str | Path = \"\",\n    delete_fmu_instance_directory: bool = True,\n    **pre_instantiation_parameters: Any\n)\n</code></pre> <p>             Bases: <code>FMUDiscipline</code></p> <p>An FMU discipline whose execution simulates only one time step.</p> Notes <p>The time series are interpolated at the time steps resulting from the union of their respective time steps. Then, between two time steps, the time series for the variables of causality \"input\" are linearly interpolated at the integration time steps while for the variables of causality \"parameter\", the time series are considered as constant.</p> <p>Initialize self.  See help(type(self)) for accurate signature.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>             (<code>str | Path</code>)         \u2013          <p>The path to the FMU model file.</p> </li> <li> <code>input_names</code>             (<code>Iterable[str] | None</code>, default:                 <code>()</code> )         \u2013          <p>The names of the FMU model inputs; if empty, use all the inputs and parameters of the FMU model; if <code>None</code>, do not use inputs.</p> </li> <li> <code>output_names</code>             (<code>Iterable[str]</code>, default:                 <code>()</code> )         \u2013          <p>The names of the FMU model outputs. if empty, use all the outputs of the FMU model.</p> </li> <li> <code>initial_time</code>             (<code>TimeType | None</code>, default:                 <code>None</code> )         \u2013          <p>The initial time of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code>, use the start time defined in the FMU model if any; otherwise use 0.</p> </li> <li> <code>final_time</code>             (<code>TimeType | None</code>, default:                 <code>None</code> )         \u2013          <p>The final time of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code>, use the stop time defined in the FMU model if any; otherwise use the initial time.</p> </li> <li> <code>time_step</code>             (<code>TimeType</code>, default:                 <code>0.0</code> )         \u2013          <p>The time step of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>0.</code>, use the stop time defined in the FMU model if any; otherwise use <code>0.</code>.</p> </li> <li> <code>add_time_to_output_grammar</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the time is added to the output grammar.</p> </li> <li> <code>restart</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether the model is restarted at <code>initial_time</code> after execution.</p> </li> <li> <code>name</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The name of the discipline. If empty, use the class name.</p> </li> <li> <code>solver_name</code>             (<code>Solver</code>, default:                 <code>CVODE</code> )         \u2013          <p>The name of the solver to simulate a model-exchange model.</p> </li> <li> <code>fmu_instance_directory</code>             (<code>str | Path</code>, default:                 <code>''</code> )         \u2013          <p>The description is missing.</p> </li> <li> <code>delete_fmu_instance_directory</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>The description is missing.</p> </li> <li> <code>**pre_instantiation_parameters</code>             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>The parameters to be passed to <code>_pre_instantiate()</code>.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/do_step_fmu_discipline.py</code> <pre><code>def __init__(  # noqa: D107\n    self,\n    file_path: str | Path,\n    input_names: Iterable[str] | None = (),\n    output_names: Iterable[str] = (),\n    initial_time: TimeType | None = None,\n    final_time: TimeType | None = None,\n    time_step: TimeType = 0.0,\n    add_time_to_output_grammar: bool = True,\n    restart: bool = False,\n    name: str = \"\",\n    solver_name: FMUDiscipline.Solver = FMUDiscipline.Solver.CVODE,\n    fmu_instance_directory: str | Path = \"\",\n    delete_fmu_instance_directory: bool = True,\n    **pre_instantiation_parameters: Any,\n) -&gt; None:\n    do_step = pre_instantiation_parameters.get(self._DO_STEP, None)\n    if do_step is False:\n        msg = \"DoStepFMUDiscipline has no do_step parameter.\"\n        raise ValueError(msg)\n\n    if do_step is True:\n        del pre_instantiation_parameters[self._DO_STEP]\n\n    super().__init__(\n        file_path,\n        input_names=input_names,\n        output_names=output_names,\n        initial_time=initial_time,\n        final_time=final_time,\n        time_step=time_step,\n        add_time_to_output_grammar=add_time_to_output_grammar,\n        restart=restart,\n        do_step=True,\n        name=name,\n        use_co_simulation=True,\n        solver_name=solver_name,\n        fmu_instance_directory=fmu_instance_directory,\n        delete_fmu_instance_directory=delete_fmu_instance_directory,\n        **pre_instantiation_parameters,\n    )\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline.TimeUnit","title":"TimeUnit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TimeUnit = TimeUnit\n</code></pre> <p>Time unit.</p>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline.causalities_to_variable_names","title":"causalities_to_variable_names  <code>property</code>","text":"<pre><code>causalities_to_variable_names: dict[str, list[str]]\n</code></pre> <p>The names of the variables sorted by causality.</p>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline.default_inputs","title":"default_inputs  <code>instance-attribute</code>","text":"<pre><code>default_inputs = {\n    input_name: _initial_values[input_name]\n    for input_name in __input_names\n}\n</code></pre> <p>The default inputs.</p>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline.initial_values","title":"initial_values  <code>property</code>","text":"<pre><code>initial_values: dict[str, NumberArray]\n</code></pre> <p>The initial input, output and time values.</p>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline.model","title":"model  <code>property</code>","text":"<pre><code>model: FMUModel\n</code></pre> <p>The FMU model.</p>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline.model_description","title":"model_description  <code>property</code>","text":"<pre><code>model_description: ModelDescription\n</code></pre> <p>The description of the FMU model.</p>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline.time","title":"time  <code>property</code>","text":"<pre><code>time: RealArray | None\n</code></pre> <p>The time steps of the last execution if any.</p>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline.Solver","title":"Solver","text":"<p>             Bases: <code>StrEnum</code></p> <p>The solver to simulate a model-exchange model.</p>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline-functions","title":"Functions","text":""},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline.execute","title":"execute","text":"<pre><code>execute(\n    input_data: Mapping[\n        str,\n        ndarray\n        | TimeSeries\n        | Callable[[TimeDurationType], float],\n    ] = MappingProxyType({})\n) -&gt; DisciplineData\n</code></pre> <p>Execute the discipline.</p> <p>This method executes the discipline:</p> <ul> <li>Adds the default inputs to the <code>input_data</code>   if some inputs are not defined in input_data   but exist in :attr:<code>.MDODiscipline.default_inputs</code>.</li> <li>Checks whether the last execution of the discipline was called   with identical inputs, i.e. cached in :attr:<code>.MDODiscipline.cache</code>;   if so, directly returns <code>self.cache.get_output_cache(inputs)</code>.</li> <li>Caches the inputs.</li> <li>Checks the input data against :attr:<code>.MDODiscipline.input_grammar</code>.</li> <li>If :attr:<code>.MDODiscipline.data_processor</code> is not None, runs the preprocessor.</li> <li>Updates the status to :attr:<code>.MDODiscipline.ExecutionStatus.RUNNING</code>.</li> <li>Calls the :meth:<code>.MDODiscipline._run</code> method, that shall be defined.</li> <li>If :attr:<code>.MDODiscipline.data_processor</code> is not None, runs the postprocessor.</li> <li>Checks the output data.</li> <li>Caches the outputs.</li> <li>Updates the status to :attr:<code>.MDODiscipline.ExecutionStatus.DONE</code>   or :attr:<code>.MDODiscipline.ExecutionStatus.FAILED</code>.</li> <li>Updates summed execution time.</li> </ul> <p>Parameters:</p> <ul> <li> <code>input_data</code>             (<code>Mapping[str, ndarray | TimeSeries | Callable[[TimeDurationType], float]]</code>, default:                 <code>MappingProxyType({})</code> )         \u2013          <p>The input data needed to execute the discipline according to the discipline input grammar. If <code>None</code>, use the :attr:<code>.MDODiscipline.default_inputs</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DisciplineData</code>         \u2013          <p>The discipline local data after execution.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def execute(  # noqa:D102\n    self,\n    input_data: Mapping[\n        str, ndarray | TimeSeries | Callable[[TimeDurationType], float]\n    ] = MappingProxyType({}),\n) -&gt; DisciplineData:\n    self.__executed = True\n    full_input_data = self._filter_inputs(input_data)\n    self.__names_to_time_functions = {\n        name: value.compute\n        for name, value in full_input_data.items()\n        if isinstance(value, TimeSeries)\n    }\n    self.__names_to_time_functions.update({\n        name: value\n        for name, value in full_input_data.items()\n        if isinstance(value, Callable)\n    })\n    full_input_data.update({\n        name: array([value.observable[0]])\n        for name, value in full_input_data.items()\n        if isinstance(value, TimeSeries)\n    })\n    full_input_data.update({\n        name: array([value(self.__current_time)])\n        for name, value in full_input_data.items()\n        if isinstance(value, Callable)\n    })\n    return super().execute(full_input_data)\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline.plot","title":"plot","text":"<pre><code>plot(\n    output_names: str | Iterable[str],\n    abscissa_name: str = \"\",\n    time_unit: TimeUnit = TimeUnit.SECONDS,\n    time_window: int | Sequence[int] = 0,\n    save: bool = True,\n    show: bool = False,\n    file_path: str | Path = \"\",\n) -&gt; Lines\n</code></pre> <p>Plot the time evolution of output variables.</p> <p>Parameters:</p> <ul> <li> <code>output_names</code>             (<code>str | Iterable[str]</code>)         \u2013          <p>The name(s) of the output variable(s).</p> </li> <li> <code>abscissa_name</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The name of the variable to be plotted on the x-axis. If empty, use the time variable.</p> </li> <li> <code>time_unit</code>             (<code>TimeUnit</code>, default:                 <code>SECONDS</code> )         \u2013          <p>The unit to express the time.</p> </li> <li> <code>time_window</code>             (<code>int | Sequence[int]</code>, default:                 <code>0</code> )         \u2013          <p>The time windows over which to draw the time evolution. Either the start time index (the end one will be the final time one) or both the start and end time indices.</p> </li> <li> <code>save</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to save the figure.</p> </li> <li> <code>show</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to show the figure.</p> </li> <li> <code>file_path</code>             (<code>str | Path</code>, default:                 <code>''</code> )         \u2013          <p>The path of the file to save the figure. The directory path and file format are deduced from it. If empty, save the file in the current directory, with the output name as file name and PNG format.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Lines</code>         \u2013          <p>The figure.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/fmu_discipline.py</code> <pre><code>def plot(\n    self,\n    output_names: str | Iterable[str],\n    abscissa_name: str = \"\",\n    time_unit: TimeUnit = TimeUnit.SECONDS,\n    time_window: int | Sequence[int] = 0,\n    save: bool = True,\n    show: bool = False,\n    file_path: str | Path = \"\",\n) -&gt; Lines:\n    \"\"\"Plot the time evolution of output variables.\n\n    Args:\n        output_names: The name(s) of the output variable(s).\n        abscissa_name: The name of the variable to be plotted on the x-axis.\n            If empty, use the time variable.\n        time_unit: The unit to express the time.\n        time_window: The time windows over which to draw the time evolution.\n            Either the start time index (the end one will be the final time one)\n            or both the start and end time indices.\n        save: Whether to save the figure.\n        show: Whether to show the figure.\n        file_path: The path of the file to save the figure.\n            The directory path and file format are deduced from it.\n            If empty,\n            save the file in the current directory,\n            with the output name as file name and PNG format.\n\n    Returns:\n        The figure.\n    \"\"\"\n    if isinstance(output_names, str):\n        output_names = [output_names]\n\n    time_name = f\"Time ({time_unit})\"\n    if not abscissa_name:\n        abscissa_name = time_name\n\n    if isinstance(time_window, int):\n        time_window = (time_window, self.time.size)\n\n    dataset = Dataset()\n    time_window = slice(*time_window)\n    time_duration = TimeDuration(self.time[time_window, newaxis])\n    dataset.add_variable(time_name, time_duration.to(time_unit))\n    for name in set(output_names).union({abscissa_name}) - {time_name}:\n        dataset.add_variable(name, self.local_data[name][time_window, newaxis])\n\n    figure = Lines(dataset, output_names, abscissa_variable=abscissa_name)\n    figure.execute(save=save, show=show, file_path=file_path)\n    return figure\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline.set_default_execution","title":"set_default_execution","text":"<pre><code>set_default_execution(\n    do_step: bool | None = None,\n    final_time: TimeDurationType | None = None,\n    restart: bool | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None\n</code></pre> <p>Change the default simulation settings.</p> <p>Parameters:</p> <ul> <li> <code>do_step</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether the model is simulated over only one <code>time_step</code> when calling execute(). Otherwise, simulate the model from current time to final time in one go. If <code>None</code>, use the value considered at the instantiation.</p> </li> <li> <code>final_time</code>             (<code>TimeDurationType | None</code>, default:                 <code>None</code> )         \u2013          <p>The final time of the simulation; either a number in seconds or a string of characters (see TimeDuration); If <code>None</code>, use the value considered at the instantiation.</p> </li> <li> <code>restart</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to restart the model at <code>initial_time</code> before executing it; if <code>None</code>, use the value passed at the instantiation.</p> </li> <li> <code>time_step</code>             (<code>TimeDurationType | None</code>, default:                 <code>None</code> )         \u2013          <p>The time step of the simulation; either a number in seconds or a string of characters (see TimeDuration); If <code>None</code>, use the value considered at the instantiation.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def set_default_execution(\n    self,\n    do_step: bool | None = None,\n    final_time: TimeDurationType | None = None,\n    restart: bool | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None:\n    \"\"\"Change the default simulation settings.\n\n    Args:\n        do_step: Whether the model is simulated over only one `time_step`\n            when calling\n            [execute()][gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.execute].\n            Otherwise, simulate the model from current time to final time in one go.\n            If `None`, use the value considered at the instantiation.\n        final_time: The final time of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            If `None`, use the value considered at the instantiation.\n        restart: Whether to restart the model at `initial_time`\n            before executing it;\n            if `None`, use the value passed at the instantiation.\n        time_step: The time step of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            If `None`, use the value considered at the instantiation.\n    \"\"\"\n    if do_step is not None:\n        self.__do_step = do_step\n\n    if restart is not None:\n        self.__default_simulation_settings[self._RESTART] = restart\n\n    if final_time is not None:\n        final_time = TimeDuration(final_time).seconds\n        self._final_time = final_time\n\n    if time_step is not None:\n        time_step = TimeDuration(time_step).seconds\n        self.__default_simulation_settings[self._TIME_STEP] = time_step\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline.set_next_execution","title":"set_next_execution","text":"<pre><code>set_next_execution(\n    restart: bool | None = None,\n    simulation_time: TimeDurationType | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None\n</code></pre> <p>Change the simulation settings for the execution.</p> <p>Parameters:</p> <ul> <li> <code>restart</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to restart the model at <code>initial_time</code> before executing it; if <code>None</code>, use the value passed at the instantiation.</p> </li> <li> <code>simulation_time</code>             (<code>TimeDurationType | None</code>, default:                 <code>None</code> )         \u2013          <p>The duration of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code> and the <code>do_step</code> passed at instantiation is <code>False</code>, execute until the final time; if <code>None</code> and the <code>do_step</code> passed at instantiation is <code>True</code>, execute during a single time step.</p> </li> <li> <code>time_step</code>             (<code>TimeDurationType | None</code>, default:                 <code>None</code> )         \u2013          <p>The time step of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code>, use the value passed at the instantiation.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def set_next_execution(\n    self,\n    restart: bool | None = None,\n    simulation_time: TimeDurationType | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None:\n    \"\"\"Change the simulation settings for the execution.\n\n    Args:\n        restart: Whether to restart the model at `initial_time`\n            before executing it;\n            if `None`, use the value passed at the instantiation.\n        simulation_time: The duration of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None` and the `do_step` passed at instantiation is `False`,\n            execute until the final time;\n            if `None` and the `do_step` passed at instantiation is `True`,\n            execute during a single time step.\n        time_step: The time step of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None`, use the value passed at the instantiation.\n    \"\"\"  # noqa: D205 D212 D415\n    if not self.__simulation_settings:\n        self.__simulation_settings = self.__default_simulation_settings.copy()\n\n    if time_step is not None:\n        self.__simulation_settings[self._TIME_STEP] = TimeDuration(\n            time_step\n        ).seconds\n\n    if restart is not None:\n        self.__simulation_settings[self._RESTART] = restart\n\n    if simulation_time is not None:\n        simulation_time = TimeDuration(simulation_time).seconds\n        self.__simulation_settings[self._SIMULATION_TIME] = simulation_time\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/dynamic_fmu_discipline/","title":"Dynamic fmu discipline","text":""},{"location":"reference/gemseo_fmu/disciplines/dynamic_fmu_discipline/#gemseo_fmu.disciplines.dynamic_fmu_discipline","title":"dynamic_fmu_discipline","text":"<p>A dynamic discipline wrapping a Functional Mockup Unit (FMU) model.</p>"},{"location":"reference/gemseo_fmu/disciplines/dynamic_fmu_discipline/#gemseo_fmu.disciplines.dynamic_fmu_discipline-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/","title":"Fmu discipline","text":""},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline","title":"fmu_discipline","text":"<p>A dynamic discipline wrapping a Functional Mockup Unit (FMU) model.</p>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline","title":"FMUDiscipline","text":"<pre><code>FMUDiscipline(\n    file_path: str | Path,\n    input_names: Iterable[str] | None = (),\n    output_names: Iterable[str] = (),\n    initial_time: TimeDurationType | None = None,\n    final_time: TimeDurationType | None = None,\n    time_step: TimeDurationType = 0.0,\n    add_time_to_output_grammar: bool = True,\n    restart: bool = True,\n    do_step: bool = False,\n    name: str = \"\",\n    use_co_simulation: bool = True,\n    solver_name: Solver = Solver.CVODE,\n    model_instance_directory: str | Path = \"\",\n    delete_model_instance_directory: bool = True,\n    **pre_instantiation_parameters: Any\n)\n</code></pre> <p>             Bases: <code>BaseFMUDiscipline</code></p> <p>A dynamic discipline wrapping a Functional Mockup Unit (FMU) model.</p> <p>This discipline relies on FMPy.</p> Notes <p>The time series are interpolated at the time steps resulting from the union of their respective time steps. Then, between two time steps, the time series for the variables of causality \"input\" are linearly interpolated at the integration time steps while for the variables of causality \"parameter\", the time series are considered as constant.</p> <p>Initialize self.  See help(type(self)) for accurate signature.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>             (<code>str | Path</code>)         \u2013          <p>The path to the FMU model file.</p> </li> <li> <code>input_names</code>             (<code>Iterable[str] | None</code>, default:                 <code>()</code> )         \u2013          <p>The names of the FMU model inputs; if empty, use all the inputs and parameters of the FMU model; if <code>None</code>, do not use inputs.</p> </li> <li> <code>output_names</code>             (<code>Iterable[str]</code>, default:                 <code>()</code> )         \u2013          <p>The names of the FMU model outputs. if empty, use all the outputs of the FMU model.</p> </li> <li> <code>initial_time</code>             (<code>TimeDurationType | None</code>, default:                 <code>None</code> )         \u2013          <p>The initial time of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code>, use the start time defined in the FMU model if any; otherwise use 0.</p> </li> <li> <code>final_time</code>             (<code>TimeDurationType | None</code>, default:                 <code>None</code> )         \u2013          <p>The final time of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code>, use the stop time defined in the FMU model if any; otherwise use the initial time.</p> </li> <li> <code>time_step</code>             (<code>TimeDurationType</code>, default:                 <code>0.0</code> )         \u2013          <p>The time step of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>0.</code>, use the stop time defined in the FMU model if any; otherwise use <code>0.</code>.</p> </li> <li> <code>add_time_to_output_grammar</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the time is added to the output grammar.</p> </li> <li> <code>restart</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the model is restarted at <code>initial_time</code> after execution.</p> </li> <li> <code>do_step</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether the model is simulated over only one <code>time_step</code> when calling execute(). Otherwise, simulate the model from current time to final time in one go.</p> </li> <li> <code>name</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The name of the discipline. If empty, use the class name.</p> </li> <li> <code>use_co_simulation</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the co-simulation FMI type is used. Otherwise, use model-exchange FMI type. When <code>do_step</code> is <code>True</code>, the co-simulation FMI type is required.</p> </li> <li> <code>solver_name</code>             (<code>Solver</code>, default:                 <code>CVODE</code> )         \u2013          <p>The name of the solver to simulate a model-exchange model.</p> </li> <li> <code>model_instance_directory</code>             (<code>str | Path</code>, default:                 <code>''</code> )         \u2013          <p>The directory of the FMU instance, containing the files extracted from the FMU model file; if empty, let <code>fmpy</code> create a temporary directory.</p> </li> <li> <code>delete_model_instance_directory</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to delete the directory of the FMU instance when deleting the discipline.</p> </li> <li> <code>**pre_instantiation_parameters</code>             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>The parameters to be passed to <code>_pre_instantiate()</code>.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def __init__(\n    self,\n    file_path: str | Path,\n    input_names: Iterable[str] | None = (),\n    output_names: Iterable[str] = (),\n    initial_time: TimeDurationType | None = None,\n    final_time: TimeDurationType | None = None,\n    time_step: TimeDurationType = 0.0,\n    add_time_to_output_grammar: bool = True,\n    restart: bool = True,\n    do_step: bool = False,\n    name: str = \"\",\n    use_co_simulation: bool = True,\n    solver_name: Solver = Solver.CVODE,\n    model_instance_directory: str | Path = \"\",\n    delete_model_instance_directory: bool = True,\n    **pre_instantiation_parameters: Any,\n) -&gt; None:\n    \"\"\"\n    Args:\n        file_path: The path to the FMU model file.\n        input_names: The names of the FMU model inputs;\n            if empty, use all the inputs and parameters of the FMU model;\n            if `None`, do not use inputs.\n        output_names: The names of the FMU model outputs.\n            if empty, use all the outputs of the FMU model.\n        initial_time: The initial time of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None`, use the start time defined in the FMU model if any;\n            otherwise use 0.\n        final_time: The final time of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None`, use the stop time defined in the FMU model if any;\n            otherwise use the initial time.\n        time_step: The time step of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `0.`, use the stop time defined in the FMU model if any;\n            otherwise use `0.`.\n        add_time_to_output_grammar: Whether the time is added to the output grammar.\n        restart: Whether the model is restarted at `initial_time` after execution.\n        do_step: Whether the model is simulated over only one `time_step`\n            when calling\n            [execute()][gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.execute].\n            Otherwise, simulate the model from current time to final time in one go.\n        use_co_simulation: Whether the co-simulation FMI type is used.\n            Otherwise, use model-exchange FMI type.\n            When `do_step` is `True`, the co-simulation FMI type is required.\n        solver_name: The name of the solver to simulate a model-exchange model.\n        model_instance_directory: The directory of the FMU instance,\n            containing the files extracted from the FMU model file;\n            if empty, let `fmpy` create a temporary directory.\n        delete_model_instance_directory: Whether to delete the directory\n            of the FMU instance when deleting the discipline.\n        **pre_instantiation_parameters: The parameters to be passed\n            to `_pre_instantiate()`.\n    \"\"\"  # noqa: D205 D212 D415\n    self.__delete_model_instance_directory = delete_model_instance_directory\n    self.__executed = False\n    self.__names_to_time_functions = {}\n    self.__solver_name = str(solver_name)\n    self.name = self.__set_fmu_model(\n        file_path, model_instance_directory, do_step, use_co_simulation, name\n    )\n    self.__set_variable_names_references_and_causalities(input_names, output_names)\n    self.__set_initial_values()\n    self.__set_time(initial_time, final_time, time_step, do_step, restart)\n    self._pre_instantiate(**(pre_instantiation_parameters or {}))\n    super().__init__(\n        name=self.name,\n        cache_type=self.CacheType.NONE,\n        grammar_type=self.GrammarType.PYDANTIC,\n    )\n    self.__set_grammars(add_time_to_output_grammar)\n    self.default_inputs = {\n        input_name: self._initial_values[input_name]\n        for input_name in self.__input_names\n    }\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.TimeUnit","title":"TimeUnit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TimeUnit = TimeUnit\n</code></pre> <p>Time unit.</p>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.causalities_to_variable_names","title":"causalities_to_variable_names  <code>property</code>","text":"<pre><code>causalities_to_variable_names: dict[str, list[str]]\n</code></pre> <p>The names of the variables sorted by causality.</p>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.default_inputs","title":"default_inputs  <code>instance-attribute</code>","text":"<pre><code>default_inputs = {\n    input_name: _initial_values[input_name]\n    for input_name in __input_names\n}\n</code></pre> <p>The default inputs.</p>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.initial_values","title":"initial_values  <code>property</code>","text":"<pre><code>initial_values: dict[str, NumberArray]\n</code></pre> <p>The initial input, output and time values.</p>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.model","title":"model  <code>property</code>","text":"<pre><code>model: FMUModel\n</code></pre> <p>The FMU model.</p>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.model_description","title":"model_description  <code>property</code>","text":"<pre><code>model_description: ModelDescription\n</code></pre> <p>The description of the FMU model.</p>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.time","title":"time  <code>property</code>","text":"<pre><code>time: RealArray | None\n</code></pre> <p>The time steps of the last execution if any.</p>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.Solver","title":"Solver","text":"<p>             Bases: <code>StrEnum</code></p> <p>The solver to simulate a model-exchange model.</p>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline-functions","title":"Functions","text":""},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.execute","title":"execute","text":"<pre><code>execute(\n    input_data: Mapping[\n        str,\n        ndarray\n        | TimeSeries\n        | Callable[[TimeDurationType], float],\n    ] = MappingProxyType({})\n) -&gt; DisciplineData\n</code></pre> <p>Execute the discipline.</p> <p>This method executes the discipline:</p> <ul> <li>Adds the default inputs to the <code>input_data</code>   if some inputs are not defined in input_data   but exist in :attr:<code>.MDODiscipline.default_inputs</code>.</li> <li>Checks whether the last execution of the discipline was called   with identical inputs, i.e. cached in :attr:<code>.MDODiscipline.cache</code>;   if so, directly returns <code>self.cache.get_output_cache(inputs)</code>.</li> <li>Caches the inputs.</li> <li>Checks the input data against :attr:<code>.MDODiscipline.input_grammar</code>.</li> <li>If :attr:<code>.MDODiscipline.data_processor</code> is not None, runs the preprocessor.</li> <li>Updates the status to :attr:<code>.MDODiscipline.ExecutionStatus.RUNNING</code>.</li> <li>Calls the :meth:<code>.MDODiscipline._run</code> method, that shall be defined.</li> <li>If :attr:<code>.MDODiscipline.data_processor</code> is not None, runs the postprocessor.</li> <li>Checks the output data.</li> <li>Caches the outputs.</li> <li>Updates the status to :attr:<code>.MDODiscipline.ExecutionStatus.DONE</code>   or :attr:<code>.MDODiscipline.ExecutionStatus.FAILED</code>.</li> <li>Updates summed execution time.</li> </ul> <p>Parameters:</p> <ul> <li> <code>input_data</code>             (<code>Mapping[str, ndarray | TimeSeries | Callable[[TimeDurationType], float]]</code>, default:                 <code>MappingProxyType({})</code> )         \u2013          <p>The input data needed to execute the discipline according to the discipline input grammar. If <code>None</code>, use the :attr:<code>.MDODiscipline.default_inputs</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DisciplineData</code>         \u2013          <p>The discipline local data after execution.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def execute(  # noqa:D102\n    self,\n    input_data: Mapping[\n        str, ndarray | TimeSeries | Callable[[TimeDurationType], float]\n    ] = MappingProxyType({}),\n) -&gt; DisciplineData:\n    self.__executed = True\n    full_input_data = self._filter_inputs(input_data)\n    self.__names_to_time_functions = {\n        name: value.compute\n        for name, value in full_input_data.items()\n        if isinstance(value, TimeSeries)\n    }\n    self.__names_to_time_functions.update({\n        name: value\n        for name, value in full_input_data.items()\n        if isinstance(value, Callable)\n    })\n    full_input_data.update({\n        name: array([value.observable[0]])\n        for name, value in full_input_data.items()\n        if isinstance(value, TimeSeries)\n    })\n    full_input_data.update({\n        name: array([value(self.__current_time)])\n        for name, value in full_input_data.items()\n        if isinstance(value, Callable)\n    })\n    return super().execute(full_input_data)\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.plot","title":"plot","text":"<pre><code>plot(\n    output_names: str | Iterable[str],\n    abscissa_name: str = \"\",\n    time_unit: TimeUnit = TimeUnit.SECONDS,\n    time_window: int | Sequence[int] = 0,\n    save: bool = True,\n    show: bool = False,\n    file_path: str | Path = \"\",\n) -&gt; Lines\n</code></pre> <p>Plot the time evolution of output variables.</p> <p>Parameters:</p> <ul> <li> <code>output_names</code>             (<code>str | Iterable[str]</code>)         \u2013          <p>The name(s) of the output variable(s).</p> </li> <li> <code>abscissa_name</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The name of the variable to be plotted on the x-axis. If empty, use the time variable.</p> </li> <li> <code>time_unit</code>             (<code>TimeUnit</code>, default:                 <code>SECONDS</code> )         \u2013          <p>The unit to express the time.</p> </li> <li> <code>time_window</code>             (<code>int | Sequence[int]</code>, default:                 <code>0</code> )         \u2013          <p>The time windows over which to draw the time evolution. Either the start time index (the end one will be the final time one) or both the start and end time indices.</p> </li> <li> <code>save</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to save the figure.</p> </li> <li> <code>show</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to show the figure.</p> </li> <li> <code>file_path</code>             (<code>str | Path</code>, default:                 <code>''</code> )         \u2013          <p>The path of the file to save the figure. The directory path and file format are deduced from it. If empty, save the file in the current directory, with the output name as file name and PNG format.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Lines</code>         \u2013          <p>The figure.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/fmu_discipline.py</code> <pre><code>def plot(\n    self,\n    output_names: str | Iterable[str],\n    abscissa_name: str = \"\",\n    time_unit: TimeUnit = TimeUnit.SECONDS,\n    time_window: int | Sequence[int] = 0,\n    save: bool = True,\n    show: bool = False,\n    file_path: str | Path = \"\",\n) -&gt; Lines:\n    \"\"\"Plot the time evolution of output variables.\n\n    Args:\n        output_names: The name(s) of the output variable(s).\n        abscissa_name: The name of the variable to be plotted on the x-axis.\n            If empty, use the time variable.\n        time_unit: The unit to express the time.\n        time_window: The time windows over which to draw the time evolution.\n            Either the start time index (the end one will be the final time one)\n            or both the start and end time indices.\n        save: Whether to save the figure.\n        show: Whether to show the figure.\n        file_path: The path of the file to save the figure.\n            The directory path and file format are deduced from it.\n            If empty,\n            save the file in the current directory,\n            with the output name as file name and PNG format.\n\n    Returns:\n        The figure.\n    \"\"\"\n    if isinstance(output_names, str):\n        output_names = [output_names]\n\n    time_name = f\"Time ({time_unit})\"\n    if not abscissa_name:\n        abscissa_name = time_name\n\n    if isinstance(time_window, int):\n        time_window = (time_window, self.time.size)\n\n    dataset = Dataset()\n    time_window = slice(*time_window)\n    time_duration = TimeDuration(self.time[time_window, newaxis])\n    dataset.add_variable(time_name, time_duration.to(time_unit))\n    for name in set(output_names).union({abscissa_name}) - {time_name}:\n        dataset.add_variable(name, self.local_data[name][time_window, newaxis])\n\n    figure = Lines(dataset, output_names, abscissa_variable=abscissa_name)\n    figure.execute(save=save, show=show, file_path=file_path)\n    return figure\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.set_default_execution","title":"set_default_execution","text":"<pre><code>set_default_execution(\n    do_step: bool | None = None,\n    final_time: TimeDurationType | None = None,\n    restart: bool | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None\n</code></pre> <p>Change the default simulation settings.</p> <p>Parameters:</p> <ul> <li> <code>do_step</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether the model is simulated over only one <code>time_step</code> when calling execute(). Otherwise, simulate the model from current time to final time in one go. If <code>None</code>, use the value considered at the instantiation.</p> </li> <li> <code>final_time</code>             (<code>TimeDurationType | None</code>, default:                 <code>None</code> )         \u2013          <p>The final time of the simulation; either a number in seconds or a string of characters (see TimeDuration); If <code>None</code>, use the value considered at the instantiation.</p> </li> <li> <code>restart</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to restart the model at <code>initial_time</code> before executing it; if <code>None</code>, use the value passed at the instantiation.</p> </li> <li> <code>time_step</code>             (<code>TimeDurationType | None</code>, default:                 <code>None</code> )         \u2013          <p>The time step of the simulation; either a number in seconds or a string of characters (see TimeDuration); If <code>None</code>, use the value considered at the instantiation.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def set_default_execution(\n    self,\n    do_step: bool | None = None,\n    final_time: TimeDurationType | None = None,\n    restart: bool | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None:\n    \"\"\"Change the default simulation settings.\n\n    Args:\n        do_step: Whether the model is simulated over only one `time_step`\n            when calling\n            [execute()][gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.execute].\n            Otherwise, simulate the model from current time to final time in one go.\n            If `None`, use the value considered at the instantiation.\n        final_time: The final time of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            If `None`, use the value considered at the instantiation.\n        restart: Whether to restart the model at `initial_time`\n            before executing it;\n            if `None`, use the value passed at the instantiation.\n        time_step: The time step of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            If `None`, use the value considered at the instantiation.\n    \"\"\"\n    if do_step is not None:\n        self.__do_step = do_step\n\n    if restart is not None:\n        self.__default_simulation_settings[self._RESTART] = restart\n\n    if final_time is not None:\n        final_time = TimeDuration(final_time).seconds\n        self._final_time = final_time\n\n    if time_step is not None:\n        time_step = TimeDuration(time_step).seconds\n        self.__default_simulation_settings[self._TIME_STEP] = time_step\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.set_next_execution","title":"set_next_execution","text":"<pre><code>set_next_execution(\n    restart: bool | None = None,\n    simulation_time: TimeDurationType | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None\n</code></pre> <p>Change the simulation settings for the execution.</p> <p>Parameters:</p> <ul> <li> <code>restart</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to restart the model at <code>initial_time</code> before executing it; if <code>None</code>, use the value passed at the instantiation.</p> </li> <li> <code>simulation_time</code>             (<code>TimeDurationType | None</code>, default:                 <code>None</code> )         \u2013          <p>The duration of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code> and the <code>do_step</code> passed at instantiation is <code>False</code>, execute until the final time; if <code>None</code> and the <code>do_step</code> passed at instantiation is <code>True</code>, execute during a single time step.</p> </li> <li> <code>time_step</code>             (<code>TimeDurationType | None</code>, default:                 <code>None</code> )         \u2013          <p>The time step of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code>, use the value passed at the instantiation.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def set_next_execution(\n    self,\n    restart: bool | None = None,\n    simulation_time: TimeDurationType | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None:\n    \"\"\"Change the simulation settings for the execution.\n\n    Args:\n        restart: Whether to restart the model at `initial_time`\n            before executing it;\n            if `None`, use the value passed at the instantiation.\n        simulation_time: The duration of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None` and the `do_step` passed at instantiation is `False`,\n            execute until the final time;\n            if `None` and the `do_step` passed at instantiation is `True`,\n            execute during a single time step.\n        time_step: The time step of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None`, use the value passed at the instantiation.\n    \"\"\"  # noqa: D205 D212 D415\n    if not self.__simulation_settings:\n        self.__simulation_settings = self.__default_simulation_settings.copy()\n\n    if time_step is not None:\n        self.__simulation_settings[self._TIME_STEP] = TimeDuration(\n            time_step\n        ).seconds\n\n    if restart is not None:\n        self.__simulation_settings[self._RESTART] = restart\n\n    if simulation_time is not None:\n        simulation_time = TimeDuration(simulation_time).seconds\n        self.__simulation_settings[self._SIMULATION_TIME] = simulation_time\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/","title":"Static fmu discipline","text":""},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline","title":"static_fmu_discipline","text":"<p>A static discipline wrapping a Functional Mockup Unit (FMU) model.</p>"},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline.StaticFMUDiscipline","title":"StaticFMUDiscipline","text":"<pre><code>StaticFMUDiscipline(\n    file_path: str | Path,\n    input_names: Iterable[str] | None = (),\n    output_names: Iterable[str] = (),\n    name: str = \"\",\n    use_co_simulation: bool = True,\n    model_instance_directory: str | Path = \"\",\n    delete_model_instance_directory: bool = True,\n    **pre_instantiation_parameters: Any\n)\n</code></pre> <p>             Bases: <code>BaseFMUDiscipline</code></p> <p>A static discipline wrapping a Functional Mockup Unit (FMU) model.</p> <p>This discipline relies on FMPy.</p> <p>Initialize self.  See help(type(self)) for accurate signature.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>             (<code>str | Path</code>)         \u2013          <p>The path to the FMU model file.</p> </li> <li> <code>input_names</code>             (<code>Iterable[str] | None</code>, default:                 <code>()</code> )         \u2013          <p>The names of the FMU model inputs; if empty, use all the inputs and parameters of the FMU model; if <code>None</code>, do not use inputs.</p> </li> <li> <code>output_names</code>             (<code>Iterable[str]</code>, default:                 <code>()</code> )         \u2013          <p>The names of the FMU model outputs. if empty, use all the outputs of the FMU model.</p> </li> <li> <code>name</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The name of the discipline. If empty, use the class name.</p> </li> <li> <code>use_co_simulation</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the co-simulation FMI type is used. Otherwise, use model-exchange FMI type. When <code>do_step</code> is <code>True</code>, the co-simulation FMI type is required.</p> </li> <li> <code>model_instance_directory</code>             (<code>str | Path</code>, default:                 <code>''</code> )         \u2013          <p>The directory of the FMU instance, containing the files extracted from the FMU model file; if empty, let <code>fmpy</code> create a temporary directory.</p> </li> <li> <code>delete_model_instance_directory</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to delete the directory of the FMU instance when deleting the discipline.</p> </li> <li> <code>**pre_instantiation_parameters</code>             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>The parameters to be passed to <code>_pre_instantiate()</code>.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/static_fmu_discipline.py</code> <pre><code>def __init__(  # noqa: D107\n    self,\n    file_path: str | Path,\n    input_names: Iterable[str] | None = (),\n    output_names: Iterable[str] = (),\n    name: str = \"\",\n    use_co_simulation: bool = True,\n    model_instance_directory: str | Path = \"\",\n    delete_model_instance_directory: bool = True,\n    **pre_instantiation_parameters: Any,\n) -&gt; None:\n    super().__init__(\n        file_path=file_path,\n        input_names=input_names,\n        output_names=output_names,\n        name=name,\n        use_co_simulation=use_co_simulation,\n        model_instance_directory=model_instance_directory,\n        delete_model_instance_directory=delete_model_instance_directory,\n        do_step=True,\n        add_time_to_output_grammar=False,\n        **pre_instantiation_parameters,\n    )\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline.StaticFMUDiscipline-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline.StaticFMUDiscipline.causalities_to_variable_names","title":"causalities_to_variable_names  <code>property</code>","text":"<pre><code>causalities_to_variable_names: dict[str, list[str]]\n</code></pre> <p>The names of the variables sorted by causality.</p>"},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline.StaticFMUDiscipline.default_inputs","title":"default_inputs  <code>instance-attribute</code>","text":"<pre><code>default_inputs = {\n    input_name: _initial_values[input_name]\n    for input_name in __input_names\n}\n</code></pre> <p>The default inputs.</p>"},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline.StaticFMUDiscipline.model","title":"model  <code>property</code>","text":"<pre><code>model: FMUModel\n</code></pre> <p>The FMU model.</p>"},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline.StaticFMUDiscipline.model_description","title":"model_description  <code>property</code>","text":"<pre><code>model_description: ModelDescription\n</code></pre> <p>The description of the FMU model.</p>"},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline.StaticFMUDiscipline-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline.StaticFMUDiscipline.Solver","title":"Solver","text":"<p>             Bases: <code>StrEnum</code></p> <p>The solver to simulate a model-exchange model.</p>"},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline.StaticFMUDiscipline-functions","title":"Functions","text":""},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline.StaticFMUDiscipline.execute","title":"execute","text":"<pre><code>execute(\n    input_data: Mapping[\n        str,\n        ndarray\n        | TimeSeries\n        | Callable[[TimeDurationType], float],\n    ] = MappingProxyType({})\n) -&gt; DisciplineData\n</code></pre> <p>Execute the discipline.</p> <p>This method executes the discipline:</p> <ul> <li>Adds the default inputs to the <code>input_data</code>   if some inputs are not defined in input_data   but exist in :attr:<code>.MDODiscipline.default_inputs</code>.</li> <li>Checks whether the last execution of the discipline was called   with identical inputs, i.e. cached in :attr:<code>.MDODiscipline.cache</code>;   if so, directly returns <code>self.cache.get_output_cache(inputs)</code>.</li> <li>Caches the inputs.</li> <li>Checks the input data against :attr:<code>.MDODiscipline.input_grammar</code>.</li> <li>If :attr:<code>.MDODiscipline.data_processor</code> is not None, runs the preprocessor.</li> <li>Updates the status to :attr:<code>.MDODiscipline.ExecutionStatus.RUNNING</code>.</li> <li>Calls the :meth:<code>.MDODiscipline._run</code> method, that shall be defined.</li> <li>If :attr:<code>.MDODiscipline.data_processor</code> is not None, runs the postprocessor.</li> <li>Checks the output data.</li> <li>Caches the outputs.</li> <li>Updates the status to :attr:<code>.MDODiscipline.ExecutionStatus.DONE</code>   or :attr:<code>.MDODiscipline.ExecutionStatus.FAILED</code>.</li> <li>Updates summed execution time.</li> </ul> <p>Parameters:</p> <ul> <li> <code>input_data</code>             (<code>Mapping[str, ndarray | TimeSeries | Callable[[TimeDurationType], float]]</code>, default:                 <code>MappingProxyType({})</code> )         \u2013          <p>The input data needed to execute the discipline according to the discipline input grammar. If <code>None</code>, use the :attr:<code>.MDODiscipline.default_inputs</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DisciplineData</code>         \u2013          <p>The discipline local data after execution.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def execute(  # noqa:D102\n    self,\n    input_data: Mapping[\n        str, ndarray | TimeSeries | Callable[[TimeDurationType], float]\n    ] = MappingProxyType({}),\n) -&gt; DisciplineData:\n    self.__executed = True\n    full_input_data = self._filter_inputs(input_data)\n    self.__names_to_time_functions = {\n        name: value.compute\n        for name, value in full_input_data.items()\n        if isinstance(value, TimeSeries)\n    }\n    self.__names_to_time_functions.update({\n        name: value\n        for name, value in full_input_data.items()\n        if isinstance(value, Callable)\n    })\n    full_input_data.update({\n        name: array([value.observable[0]])\n        for name, value in full_input_data.items()\n        if isinstance(value, TimeSeries)\n    })\n    full_input_data.update({\n        name: array([value(self.__current_time)])\n        for name, value in full_input_data.items()\n        if isinstance(value, Callable)\n    })\n    return super().execute(full_input_data)\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline.StaticFMUDiscipline.set_default_execution","title":"set_default_execution","text":"<pre><code>set_default_execution(\n    do_step: bool | None = None,\n    final_time: TimeDurationType | None = None,\n    restart: bool | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None\n</code></pre> <p>Change the default simulation settings.</p> <p>Parameters:</p> <ul> <li> <code>do_step</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether the model is simulated over only one <code>time_step</code> when calling execute(). Otherwise, simulate the model from current time to final time in one go. If <code>None</code>, use the value considered at the instantiation.</p> </li> <li> <code>final_time</code>             (<code>TimeDurationType | None</code>, default:                 <code>None</code> )         \u2013          <p>The final time of the simulation; either a number in seconds or a string of characters (see TimeDuration); If <code>None</code>, use the value considered at the instantiation.</p> </li> <li> <code>restart</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to restart the model at <code>initial_time</code> before executing it; if <code>None</code>, use the value passed at the instantiation.</p> </li> <li> <code>time_step</code>             (<code>TimeDurationType | None</code>, default:                 <code>None</code> )         \u2013          <p>The time step of the simulation; either a number in seconds or a string of characters (see TimeDuration); If <code>None</code>, use the value considered at the instantiation.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def set_default_execution(\n    self,\n    do_step: bool | None = None,\n    final_time: TimeDurationType | None = None,\n    restart: bool | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None:\n    \"\"\"Change the default simulation settings.\n\n    Args:\n        do_step: Whether the model is simulated over only one `time_step`\n            when calling\n            [execute()][gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.execute].\n            Otherwise, simulate the model from current time to final time in one go.\n            If `None`, use the value considered at the instantiation.\n        final_time: The final time of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            If `None`, use the value considered at the instantiation.\n        restart: Whether to restart the model at `initial_time`\n            before executing it;\n            if `None`, use the value passed at the instantiation.\n        time_step: The time step of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            If `None`, use the value considered at the instantiation.\n    \"\"\"\n    if do_step is not None:\n        self.__do_step = do_step\n\n    if restart is not None:\n        self.__default_simulation_settings[self._RESTART] = restart\n\n    if final_time is not None:\n        final_time = TimeDuration(final_time).seconds\n        self._final_time = final_time\n\n    if time_step is not None:\n        time_step = TimeDuration(time_step).seconds\n        self.__default_simulation_settings[self._TIME_STEP] = time_step\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline.StaticFMUDiscipline.set_next_execution","title":"set_next_execution","text":"<pre><code>set_next_execution(\n    restart: bool | None = None,\n    simulation_time: TimeDurationType | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None\n</code></pre> <p>Change the simulation settings for the execution.</p> <p>Parameters:</p> <ul> <li> <code>restart</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to restart the model at <code>initial_time</code> before executing it; if <code>None</code>, use the value passed at the instantiation.</p> </li> <li> <code>simulation_time</code>             (<code>TimeDurationType | None</code>, default:                 <code>None</code> )         \u2013          <p>The duration of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code> and the <code>do_step</code> passed at instantiation is <code>False</code>, execute until the final time; if <code>None</code> and the <code>do_step</code> passed at instantiation is <code>True</code>, execute during a single time step.</p> </li> <li> <code>time_step</code>             (<code>TimeDurationType | None</code>, default:                 <code>None</code> )         \u2013          <p>The time step of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code>, use the value passed at the instantiation.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def set_next_execution(\n    self,\n    restart: bool | None = None,\n    simulation_time: TimeDurationType | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None:\n    \"\"\"Change the simulation settings for the execution.\n\n    Args:\n        restart: Whether to restart the model at `initial_time`\n            before executing it;\n            if `None`, use the value passed at the instantiation.\n        simulation_time: The duration of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None` and the `do_step` passed at instantiation is `False`,\n            execute until the final time;\n            if `None` and the `do_step` passed at instantiation is `True`,\n            execute during a single time step.\n        time_step: The time step of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None`, use the value passed at the instantiation.\n    \"\"\"  # noqa: D205 D212 D415\n    if not self.__simulation_settings:\n        self.__simulation_settings = self.__default_simulation_settings.copy()\n\n    if time_step is not None:\n        self.__simulation_settings[self._TIME_STEP] = TimeDuration(\n            time_step\n        ).seconds\n\n    if restart is not None:\n        self.__simulation_settings[self._RESTART] = restart\n\n    if simulation_time is not None:\n        simulation_time = TimeDuration(simulation_time).seconds\n        self.__simulation_settings[self._SIMULATION_TIME] = simulation_time\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/time_series/","title":"Time series","text":""},{"location":"reference/gemseo_fmu/disciplines/time_series/#gemseo_fmu.disciplines.time_series","title":"time_series","text":"<p>Time series.</p>"},{"location":"reference/gemseo_fmu/disciplines/time_series/#gemseo_fmu.disciplines.time_series-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_fmu/disciplines/time_series/#gemseo_fmu.disciplines.time_series.ObservableType","title":"ObservableType  <code>module-attribute</code>","text":"<pre><code>ObservableType = Union[\n    Sequence[float], NDArrayPydantic[float]\n]\n</code></pre> <p>The type for a sequence of observable values.</p>"},{"location":"reference/gemseo_fmu/disciplines/time_series/#gemseo_fmu.disciplines.time_series.TimeType","title":"TimeType  <code>module-attribute</code>","text":"<pre><code>TimeType = Union[\n    Sequence[TimeDurationType], NDArrayPydantic\n]\n</code></pre> <p>The type for a sequence of time values.</p>"},{"location":"reference/gemseo_fmu/disciplines/time_series/#gemseo_fmu.disciplines.time_series-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/disciplines/time_series/#gemseo_fmu.disciplines.time_series.TimeSeries","title":"TimeSeries","text":"<p>The time series of an observable.</p>"},{"location":"reference/gemseo_fmu/disciplines/time_series/#gemseo_fmu.disciplines.time_series.TimeSeries-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_fmu/disciplines/time_series/#gemseo_fmu.disciplines.time_series.TimeSeries.compute","title":"compute  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>compute: Callable[[float], float] = field(init=False)\n</code></pre> <p>The stairs function built from this time series.</p>"},{"location":"reference/gemseo_fmu/disciplines/time_series/#gemseo_fmu.disciplines.time_series.TimeSeries.observable","title":"observable  <code>instance-attribute</code>","text":"<pre><code>observable: ObservableType\n</code></pre> <p>The values of the observable associated to the values of the time.</p>"},{"location":"reference/gemseo_fmu/disciplines/time_series/#gemseo_fmu.disciplines.time_series.TimeSeries.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size: int = field(init=False)\n</code></pre> <p>The size of the time series.</p>"},{"location":"reference/gemseo_fmu/disciplines/time_series/#gemseo_fmu.disciplines.time_series.TimeSeries.time","title":"time  <code>instance-attribute</code>","text":"<pre><code>time: TimeType\n</code></pre> <p>The increasing values of the time.</p> <p>The components can be either numbers in seconds or strings of characters (see TimeDuration).</p>"},{"location":"reference/gemseo_fmu/disciplines/time_series/#gemseo_fmu.disciplines.time_series.TimeSeries.tolerance","title":"tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tolerance: TimeDurationType = 0.0\n</code></pre> <p>The tolerance for the stairs function.</p>"},{"location":"reference/gemseo_fmu/disciplines/time_stepping_system/","title":"Time stepping system","text":""},{"location":"reference/gemseo_fmu/disciplines/time_stepping_system/#gemseo_fmu.disciplines.time_stepping_system","title":"time_stepping_system","text":"<p>A system of disciplines based on static and time-stepping disciplines.</p>"},{"location":"reference/gemseo_fmu/disciplines/time_stepping_system/#gemseo_fmu.disciplines.time_stepping_system-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/disciplines/time_stepping_system/#gemseo_fmu.disciplines.time_stepping_system.TimeSteppingSystem","title":"TimeSteppingSystem","text":"<pre><code>TimeSteppingSystem(\n    disciplines: Iterable[str | Path | MDODiscipline],\n    final_time: float,\n    time_step: float,\n    apply_time_step_to_disciplines: bool = True,\n    restart: bool = True,\n    do_step: bool = False,\n    **fmu_options: Any\n)\n</code></pre> <p>             Bases: <code>MDOParallelChain</code></p> <p>A system of static and time-stepping disciplines.</p> <p>A static discipline computes an output at time \\(t_k\\) from an input at time \\(t_k\\) while a time-stepping discipline computes an output at time \\(t_k\\) from an input at time \\(t_k\\) and its state at time \\(t_{k-1}\\).</p> <p>At each time step, the time-stepping system executes such disciplines one after the other.</p> <p>Initialize self.  See help(type(self)) for accurate signature.</p> <p>Parameters:</p> <ul> <li> <code>disciplines</code>             (<code>Iterable[str | Path | MDODiscipline]</code>)         \u2013          <p>The static and time-stepping disciplines. The disciplines will be executed circularly according to the order of their definition.</p> </li> <li> <code>final_time</code>             (<code>float</code>)         \u2013          <p>The final time of the simulation (the initial time is 0).</p> </li> <li> <code>time_step</code>             (<code>float</code>)         \u2013          <p>The time step of the system.</p> </li> <li> <code>apply_time_step_to_disciplines</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the time-stepping disciplines should use <code>time_step</code> as time step. Otherwise, their own time steps.</p> </li> <li> <code>restart</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the system is restarted at initial time after each  execution.</p> </li> <li> <code>do_step</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether the model is simulated over only one <code>time_step</code> when calling the execution method. Otherwise, simulate the model from initial time to <code>final_time</code>.</p> </li> <li> <code>**fmu_options</code>             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>The options to instantiate the FMU disciplines.</p> </li> </ul> Notes <p>The actual number of processes could be lower than <code>n_processes</code> if there are less than <code>n_processes</code> disciplines. <code>n_processes</code> can be lower than the total number of CPUs on the machine. Each discipline may itself run on several CPUs.</p> Source code in <code>src/gemseo_fmu/disciplines/time_stepping_system.py</code> <pre><code>def __init__(\n    self,\n    disciplines: Iterable[str | Path | MDODiscipline],\n    final_time: float,\n    time_step: float,\n    apply_time_step_to_disciplines: bool = True,\n    restart: bool = True,\n    do_step: bool = False,\n    **fmu_options: Any,\n) -&gt; None:\n    \"\"\"\n    Args:\n        disciplines: The static and time-stepping disciplines.\n            The disciplines will be executed circularly\n            according to the order of their definition.\n        final_time: The final time of the simulation\n            (the initial time is 0).\n        time_step: The time step of the system.\n        apply_time_step_to_disciplines: Whether the time-stepping disciplines\n            should use `time_step` as time step. Otherwise, their own time steps.\n        restart: Whether the system is restarted at initial time\n            after each  execution.\n        do_step: Whether the model is simulated over only one `time_step`\n            when calling the execution method.\n            Otherwise, simulate the model from initial time to `final_time`.\n        **fmu_options: The options to instantiate the FMU disciplines.\n    \"\"\"  # noqa: D205 D212 D415\n    self.__do_step = do_step\n    self.__current_time = self.__initial_time = 0.0\n    self.__final_time = final_time\n    self.__restart = restart\n    self.__time_step = time_step\n    discipline_time_step = time_step if apply_time_step_to_disciplines else 0.0\n    _disciplines = []\n    for discipline in disciplines:\n        if isinstance(discipline, BaseFMUDiscipline):\n            discipline.set_default_execution(\n                final_time=final_time,\n                restart=False,\n                do_step=True,\n                time_step=discipline_time_step or None,\n            )\n        elif not isinstance(discipline, MDODiscipline):\n            discipline = DoStepFMUDiscipline(\n                discipline,\n                time_step=discipline_time_step,\n                final_time=final_time,\n                **fmu_options,\n            )\n        _disciplines.append(discipline)\n\n    self.__fmu_disciplines = [\n        discipline\n        for discipline in _disciplines\n        if isinstance(discipline, BaseFMUDiscipline)\n    ]\n    super().__init__(_disciplines, grammar_type=MDODiscipline.GrammarType.SIMPLER)\n    if self.__do_step:\n        # Workaround to be replaced by something related to time step.\n        self.__time_step_id = array([0])\n        self.input_grammar.update_from_names([self.__TIME_STEP_ID_LABEL])\n\n    # Discipline i has priority over discipline i+1 to set the default inputs.\n    self.default_inputs.clear()\n    for discipline in self.disciplines[::-1]:\n        self.default_inputs.update({\n            input_name: input_value\n            for input_name, input_value in discipline.default_inputs.items()\n            if input_name in self.input_grammar.names\n        })\n    self.__original_default_inputs = self.default_inputs.copy()\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/time_stepping_system/#gemseo_fmu.disciplines.time_stepping_system.TimeSteppingSystem-functions","title":"Functions","text":""},{"location":"reference/gemseo_fmu/disciplines/time_stepping_system/#gemseo_fmu.disciplines.time_stepping_system.TimeSteppingSystem.execute","title":"execute","text":"<pre><code>execute(\n    input_data: Mapping[str, Any] | None = None\n) -&gt; DisciplineData\n</code></pre> <p>Execute the discipline.</p> <p>This method executes the discipline:</p> <ul> <li>Adds the default inputs to the <code>input_data</code>   if some inputs are not defined in input_data   but exist in :attr:<code>.MDODiscipline.default_inputs</code>.</li> <li>Checks whether the last execution of the discipline was called   with identical inputs, i.e. cached in :attr:<code>.MDODiscipline.cache</code>;   if so, directly returns <code>self.cache.get_output_cache(inputs)</code>.</li> <li>Caches the inputs.</li> <li>Checks the input data against :attr:<code>.MDODiscipline.input_grammar</code>.</li> <li>If :attr:<code>.MDODiscipline.data_processor</code> is not None, runs the preprocessor.</li> <li>Updates the status to :attr:<code>.MDODiscipline.ExecutionStatus.RUNNING</code>.</li> <li>Calls the :meth:<code>.MDODiscipline._run</code> method, that shall be defined.</li> <li>If :attr:<code>.MDODiscipline.data_processor</code> is not None, runs the postprocessor.</li> <li>Checks the output data.</li> <li>Caches the outputs.</li> <li>Updates the status to :attr:<code>.MDODiscipline.ExecutionStatus.DONE</code>   or :attr:<code>.MDODiscipline.ExecutionStatus.FAILED</code>.</li> <li>Updates summed execution time.</li> </ul> <p>Parameters:</p> <ul> <li> <code>input_data</code>             (<code>Mapping[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>The input data needed to execute the discipline according to the discipline input grammar. If <code>None</code>, use the :attr:<code>.MDODiscipline.default_inputs</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DisciplineData</code>         \u2013          <p>The discipline local data after execution.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/time_stepping_system.py</code> <pre><code>def execute(  # noqa: D102\n    self, input_data: Mapping[str, Any] | None = None\n) -&gt; DisciplineData:\n    if self.__restart:\n        self.default_inputs = self.__original_default_inputs.copy()\n        self.__current_time = self.__initial_time\n        self.__time_step_id = array([0])\n        for discipline in self.__fmu_disciplines:\n            discipline.set_next_execution(restart=True)\n\n        if self.cache is not None:\n            self.cache.clear()\n\n    if self.__do_step:\n        input_data = input_data or {}\n        self.__time_step_id = self.__time_step_id + 1\n        input_data[self.__TIME_STEP_ID_LABEL] = self.__time_step_id\n\n    return super().execute(input_data)\n</code></pre>"},{"location":"reference/gemseo_fmu/problems/","title":"Problems","text":""},{"location":"reference/gemseo_fmu/problems/#gemseo_fmu.problems","title":"problems","text":"<p>Problems to illustrate the features of the package.</p>"},{"location":"reference/gemseo_fmu/problems/fmu_files/","title":"Fmu files","text":""},{"location":"reference/gemseo_fmu/problems/fmu_files/#gemseo_fmu.problems.fmu_files","title":"fmu_files","text":"<p>A set of platform-dependent FMU files.</p>"},{"location":"reference/gemseo_fmu/problems/fmu_files/#gemseo_fmu.problems.fmu_files-functions","title":"Functions","text":""},{"location":"reference/gemseo_fmu/problems/fmu_files/#gemseo_fmu.problems.fmu_files.get_fmu_file_path","title":"get_fmu_file_path","text":"<pre><code>get_fmu_file_path(\n    model_name: str, directory_name: str = \".\"\n) -&gt; Path\n</code></pre> <p>Return the file path of an FMU model depending on the platform.</p> <p>Parameters:</p> <ul> <li> <code>model_name</code>             (<code>str</code>)         \u2013          <p>The name of the FMU model; the corresponding file name is <code>f\"{model_name}.fmu\"</code>.</p> </li> <li> <code>directory_name</code>             (<code>str</code>, default:                 <code>'.'</code> )         \u2013          <p>The name of the directory containing the file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>The file path of the FMU model.</p> </li> </ul> Source code in <code>src/gemseo_fmu/problems/fmu_files/__init__.py</code> <pre><code>def get_fmu_file_path(model_name: str, directory_name: str = \".\") -&gt; Path:\n    \"\"\"Return the file path of an FMU model depending on the platform.\n\n    Args:\n        model_name: The name of the FMU model;\n            the corresponding file name is `f\"{model_name}.fmu\"`.\n        directory_name: The name of the directory containing the file.\n\n    Returns:\n        The file path of the FMU model.\n    \"\"\"\n    os_dir = \"win32\" if PLATFORM_IS_WINDOWS else \"linux\"\n    return Path(__file__).parent / os_dir / directory_name / f\"{model_name}.fmu\"\n</code></pre>"},{"location":"reference/gemseo_fmu/utils/","title":"Utils","text":""},{"location":"reference/gemseo_fmu/utils/#gemseo_fmu.utils","title":"utils","text":"<p>Utils.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/","title":"Time duration","text":""},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration","title":"time_duration","text":"<p>Time duration.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration","title":"TimeDuration","text":"<pre><code>TimeDuration(duration: TimeDurationType)\n</code></pre> <p>A time duration.</p> <p>This time duration is instantiated either from a number expressed in seconds or a string of characters that is a <code>number[, , and ]unit</code> succession, e.g. <code>\"2h 34m 1s\"</code> or <code>\"2 hours, 34 minutes and 1 second\"</code>. The unit can be one of:</p> <ul> <li>y, year, years,</li> <li>m, month, months,</li> <li>w, week, weeks,</li> <li>d, day, days,</li> <li>h, hour, hours,</li> <li>min, minute, minutes,</li> <li>s, second, seconds,</li> <li>ms, millis, millisecond, milliseconds.</li> </ul> <p>The value attribute stores the numerical value of the time duration in seconds while a property whose name is a time unit, e.g. <code>years</code> or <code>minutes</code>, corresponds to the time duration expressed with this time unit.</p> <p>Lastly, TimeDuration objects can be compared, e.g. <code>assert TimeDuration(\"1 week\") &lt; TimeDuration(\"8 days\")</code>.</p> <p>Parameters:</p> <ul> <li> <code>duration</code>             (<code>TimeDurationType</code>)         \u2013          <p>The time duration.</p> </li> </ul> Source code in <code>src/gemseo_fmu/utils/time_duration.py</code> <pre><code>def __init__(self, duration: TimeDurationType) -&gt; None:\n    \"\"\"\n    Args:\n        duration: The time duration.\n    \"\"\"  # noqa: D205, D212, D415\n    self.value = duration\n</code></pre>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.days","title":"days  <code>property</code>","text":"<pre><code>days: float\n</code></pre> <p>The time duration in days.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.hours","title":"hours  <code>property</code>","text":"<pre><code>hours: float\n</code></pre> <p>The time duration in hours.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.microseconds","title":"microseconds  <code>property</code>","text":"<pre><code>microseconds: float\n</code></pre> <p>The time duration in microseconds.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.milliseconds","title":"milliseconds  <code>property</code>","text":"<pre><code>milliseconds: float\n</code></pre> <p>The time duration in milliseconds.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.minutes","title":"minutes  <code>property</code>","text":"<pre><code>minutes: float\n</code></pre> <p>The time duration in minutes.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.months","title":"months  <code>property</code>","text":"<pre><code>months: float\n</code></pre> <p>The time duration in months.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.seconds","title":"seconds  <code>property</code>","text":"<pre><code>seconds: float\n</code></pre> <p>The time duration in seconds.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value: float\n</code></pre> <p>The time duration in seconds.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.weeks","title":"weeks  <code>property</code>","text":"<pre><code>weeks: float\n</code></pre> <p>The time duration in weeks.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.years","title":"years  <code>property</code>","text":"<pre><code>years: float\n</code></pre> <p>The time duration in years.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.TimeUnit","title":"TimeUnit","text":"<p>Time unit.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration-functions","title":"Functions","text":""},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.to","title":"to","text":"<pre><code>to(time_unit: TimeUnit) -&gt; float\n</code></pre> <p>Return the time duration with a given time unit.</p> <p>Parameters:</p> <ul> <li> <code>time_unit</code>             (<code>TimeUnit</code>)         \u2013          <p>The time unit.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>         \u2013          <p>The time duration.</p> </li> </ul> Source code in <code>src/gemseo_fmu/utils/time_duration.py</code> <pre><code>def to(self, time_unit: TimeUnit) -&gt; float:\n    \"\"\"Return the time duration with a given time unit.\n\n    Args:\n        time_unit: The time unit.\n\n    Returns:\n        The time duration.\n    \"\"\"\n    return getattr(self, time_unit)\n</code></pre>"},{"location":"user_guide/","title":"User guide","text":""},{"location":"user_guide/#user-guide","title":"User guide","text":"<p>Installation FMU discipline Time stepping system</p>"},{"location":"user_guide/fmu_discipline/","title":"Fmu discipline","text":""},{"location":"user_guide/fmu_discipline/#fmu-discipline","title":"FMU discipline","text":"<p>The functional mock-up interface (FMI) is a popular free standard to exchange dynamic simulation models. This standard defines the notion of functional mock-up unit (FMU) through a ZIP file containg a mix of XML files, binaries and C code. GEMSEO-FMU proposes new types of MDODiscipline to simulate an FMU model:</p> <ul> <li>the StaticFMUDiscipline   to simulate a time-independent FMU model \\(f\\)   like \\(y=f(x)\\)   where \\(x\\) is the input and \\(y\\) is the output,</li> <li>the DynamicFMUDiscipline   to simulate a time-dependent FMU model \\(f\\)   like \\(y(t_k)=f(y(t_{k-1}),x(t_{k-1}),\\Delta t_k)\\)   where \\(t_{k-1}\\) is the previous time,   \\(t_k\\) is the current time   and \\(\\Delta t_k=t_k-t_{k-1}\\) is the time step,</li> <li>the FMUDiscipline   to simulate a time-independent or time-dependent FMU model \\(f\\)   like \\(y=f(x)\\) or \\(y(t_k)=f(y(t_{k-1}),x(t_{k-1}),\\Delta t_k)\\).</li> </ul> <p>Info</p> <p>FMUDiscipline is an alias of DynamicFMUDiscipline and can be used to simulate both time-dependent and time-independent FMU models. Most of the time, the FMU model are dynamic and so this naming shortcut can be useful.</p> <p>Note</p> <p><code>gemseo-fmu</code> distinguishes between static and dynamic models to facilitate use by newcomers in the FMI standard. However, it should be noted that an FMU model does not make this distinction: all FMU models include the notion of time. Thus, a model summing two operands \\(a\\) and \\(b\\) can be run with different time steps and different final times; it will then produce the same result \\(c=a+b\\) at each time step.</p> <p>In the following, we will talk about the FMUDiscipline. The content would be the same for StaticFMUDiscipline except for the parts related to the notion of time, which are specific to the DynamicFMUDiscipline. You will find examples of both StaticFMUDiscipline and DynamicFMUDiscipline. in the galleries of examples.</p>"},{"location":"user_guide/fmu_discipline/#basics","title":"Basics","text":"<p>As any MDODiscipline, you mainly need to know how to instantiate an FMUDiscipline, and how to execute it. Advanced features will be presented later.</p>"},{"location":"user_guide/fmu_discipline/#instantiation","title":"Instantiation","text":"<p>The only mandatory argument is the path to the FMU file:</p> <pre><code>from gemseo_fmu.disciplines.fmu_discipline import FMUDiscipline\n\ndiscipline = FMUDiscipline(\"my_model.fmu\")\n</code></pre>"},{"location":"user_guide/fmu_discipline/#input-and-outputs","title":"Input and outputs","text":"<p>In that case, the input variables of the discipline are all the variables of the FMU model with type input or parameter while its output variables are all the outputs of the FMU model plus the time.</p> <p>The time can be excluded from the outputs with <code>add_time_to_output_grammar=False</code>.</p> <p>The discipline has no input variables with <code>input_names=None</code>.</p> <p>The input variables can be a subset of the inputs and parameters of the FMU model by using <code>input_names=some_input_names</code>. The output variables can also be a subset of the outputs of the FMU model by using <code>output_names=some_output_names</code>.</p>"},{"location":"user_guide/fmu_discipline/#time-settings","title":"Time settings","text":"<p>Regarding the time settings, this minimal instantiation implies that each execution of the discipline will execute the FMU model as co-simulation FMU model from its start time to its final time with a default time step and a default solver for ordinary differential equation (ODE). If the start time is not defined in the FMU models, this is set to 0. If the final time is not defined in the FMU models, this time is set to the start time, and it is therefore advisable to use a custom value.</p> <p>The time step and the solver can be changed with the float argument <code>time_step</code> and the string argument <code>solver_name</code>.</p> <p>An execution can also advance a single time step from the start time by using <code>do_step=True</code>. When using both <code>do_step=True</code> and <code>restart=False</code>, an execution advances a single time step from the previous one.</p> <p>Info</p> <p>The DoStepFMUDiscipline is an FMUDiscipline whose execution advances a single time step from the previous time. It can be useful if you want an FMUDiscipline doing time stepping throughout its life cycle.</p> <p>Lastly, the final time can be changed with the float argument <code>final_time</code>.</p> <p>Warning</p> <p>The discipline cannot be executed after the final time.</p>"},{"location":"user_guide/fmu_discipline/#execution","title":"Execution","text":"<p>An FMUDiscipline can be easily executed with the default values of its inputs:</p> <pre><code>discipline.execute()\n</code></pre> <p>or with custom ones passed as a dictionary:</p> <pre><code>discipline.execute({\"my_input\": my_input_value})\n</code></pre>"},{"location":"user_guide/fmu_discipline/#advanced","title":"Advanced","text":""},{"location":"user_guide/fmu_discipline/#time-series","title":"Time series","text":"<p>An input value can be either a scalar or a TimeSeries.</p> <p>For instance, a discipline can take as input a signal \\(x(t)\\) known at time steps \\(t_1,t2,\\ldots,t_N\\):</p> <pre><code>from gemseo.disciplines.time_series import TimeSeries\n\nmy_time_series = TimeSeries([t1, t2, ..., tN], [x1, x2, ..., xN])\n</code></pre> <p>The values of the time \\(t\\) and observable \\(x\\) can be easily accessed:</p> <pre><code>t = my_time_series.time\nx = my_time_series.observable\n</code></pre> <p>In practice, you can use it either to set the default inputs:</p> <pre><code>discipline.default_inputs[\"my_input\"] = my_time_series\n</code></pre> <p>or to execute the discipline:</p> <pre><code>discipline.execute({\"my_input\": my_time_series})\n</code></pre>"},{"location":"user_guide/fmu_discipline/#configure-the-next-execution","title":"Configure the next execution","text":"<p>The time settings of the next execution of the discipline depends on the time settings defined at instantiation but can be changed temporarily.</p> <p>set_next_execution() allows to change the duration of the simulation associated to the next execution, change the time step used during the next execution and restart the discipline instantiated with <code>restart=False</code> (and vice-versa).</p> <p>Only the next execution</p> <p>This method only applies to the next execution. It must be used each time a different behavior from the instantiation settings is required.</p> <p>Simulation time</p> <p>The simulation time must be less than or equal to the time remaining before the final time.</p> <p>Here is an example of how to use this method:</p> <pre><code>from gemseo_fmu.disciplines.fmu_discipline import FMUDiscipline\n\n# Create a discipline from an FMU model:\n# - set the final time at 12 seconds,\n# - start an execution at the time step where the previous one stopped.\ndiscipline = FMUDiscipline(\"my_model.fmu\", final_time=12, restart=False)\n\n# Simulate with the default values of the inputs during 3 seconds\ndiscipline.set_next_execution(simulation_time=3)\ndiscipline.execute()\n\n# Simulate with custom values of the inputs during 2 seconds\ndiscipline.set_next_execution(simulation_time=2)\ndiscipline.execute({\"x\": array([12.3])})\n\n# Simulate with custome values until final time (i.e. during 7 seconds)\ndiscipline.execute({\"x\": array([16.8])})\n</code></pre>"},{"location":"user_guide/fmu_discipline/#restart","title":"Restart","text":"<p>The argument <code>restart</code> has already been introduced in this page.</p> <p>It can also be used to compare trajectories:</p> <pre><code>import matplotlib.pyplot as plt\nfrom gemseo_fmu.disciplines.fmu_discipline import FMUDiscipline\n\ndiscipline = FMUDiscipline(\"my_model.fmu\")\ndiscipline.execute()\ndefault_trajectory = discipline.local_data[\"y\"]\n\ndiscipline.execute({\"x\": array([12.3])})\nfirst_custom_trajectory = discipline.local_data[\"y\"]\n\ndiscipline.execute({\"x\": array([16.8])})\nsecond_custom_trajectory = discipline.local_data[\"y\"]\n\ntime = discipline.local_data[\"time\"]\n\nplt.plot(time, default_trajectory, label=\"Default\")\nplt.plot(time, first_custom_trajectory, label=\"Option 1\")\nplt.plot(time, second_custom_trajectory, label=\"Option 2\")\nplt.show()\n</code></pre>"},{"location":"user_guide/installation/","title":"Installation","text":""},{"location":"user_guide/installation/#installation","title":"Installation","text":""},{"location":"user_guide/installation/#basics","title":"Basics","text":""},{"location":"user_guide/installation/#requirements","title":"Requirements","text":"<p>To install GEMSEO-FMU, you should use a Python environment. You can create environments with the Python built-in venv module or with anaconda.</p>"},{"location":"user_guide/installation/#install-from-pypi","title":"Install from Pypi","text":"<p>Install the latest version with</p> <pre><code>pip install gemseo-fmu\n</code></pre> <p>See pip for more information.</p>"},{"location":"user_guide/installation/#test-the-installation","title":"Test the installation","text":""},{"location":"user_guide/installation/#basic-test","title":"Basic test","text":"<p>To check that the installation is successful, try to import the module:</p> <pre><code>python -c \"import gemseo_fmu\"\n</code></pre> <p>If you obtain an error as <code>ImportError: No module named gemseo-fmu</code>, then the installation failed.</p>"},{"location":"user_guide/installation/#test-with-examples","title":"Test with examples","text":"<p>The gallery of examples contains many examples to illustrate the main features of GEMSEO-FMU. For each example, you can download a Python script or a Jupyter Notebook, execute it and experiment to test the installation.</p>"},{"location":"user_guide/installation/#advanced","title":"Advanced","text":""},{"location":"user_guide/installation/#install-the-development-version","title":"Install the development version","text":"<p>Install the development version with</p> <pre><code>pip install gemseo-fmu@git+https://gitlab.com/gemseo/dev/gemseo-fmu.git@develop\n</code></pre> <p>To develop in GEMSEO-FMU, see instead the contributing section of GEMSEO.</p>"},{"location":"user_guide/installation/#test-with-unit-tests","title":"Test with unit tests","text":"<p>Run the tests with:</p> <pre><code>pip install gemseo-fmu[test]\n</code></pre> <p>Look at the output of the above command to determine the installed version of GEMSEO-FMU. Get the tests corresponding to the same version of GEMSEO-FMU from gitlab. Then from the directory of this archive that contains the <code>tests</code> directory, run</p> <pre><code>pytest\n</code></pre> <p>Look at the contributing section of GEMSEO for more information on testing.</p>"},{"location":"user_guide/time_stepping_system/","title":"Time stepping system","text":""},{"location":"user_guide/time_stepping_system/#time-stepping-system","title":"Time stepping system","text":"<p>A TimeSteppingSystem is an MDODiscipline defined by system of static and time-stepping disciplines:</p> <ul> <li>a static discipline computes an output \\(y\\) at time \\(t_k\\)   from an input \\(x\\) at time \\(t_k\\), i.e. \\(y(t_k)=f(x(t_k))\\),</li> <li>a time-stepping discipline computes an output \\(y\\) at time \\(t_k\\)   from an input \\(y\\) at time \\(t_k\\) and its state \\(s\\) at time \\(t_k\\),   i.e. \\(y(t_k)=f(x(t_k),s(t_k),t_k)\\).</li> </ul> <p>At each time step \\(t_k\\), the TimeSteppingSystem executes a collection of such disciplines one after the other.</p> <p>Note</p> <p>The order of execution is the user one. Future versions of <code>gemseo-fmu</code> should implement advanced strategies based on the MDOCouplingStructure of the disciplines.</p>"},{"location":"user_guide/time_stepping_system/#instantiation","title":"Instantiation","text":"<p>The instantiation of a TimeSteppingSystem only requires a list of disciplines, final time and a time step:</p> <pre><code>from gemseo_fmu.disciplines.time_stepping_system import TimeSteppingSystem\nfrom gemseo_fmu.disciplines.dynamic_fmu_discipline import DynamicFMUDiscipline\nfrom gemseo.disciplines.analytic import AnalyticDiscipline\n\ndisciplines = [\n    \"file_path.fmu\",\n    DynamicFMUDiscipline(\"other_file_path.fmu\"),\n    AnalyticDiscipline({\"y\":\"2*x\"})\n]\nsystem = TimeSteppingSystem(disciplines, 1, 0.1)\n</code></pre> <p>The disciplines can be either an FMU file path, a static discipline or a dynamic discipline and will be executed in parallel.</p>"},{"location":"user_guide/time_stepping_system/#restart","title":"Restart","text":"<p>By default, an execution starts from the initial time. Set <code>restart</code> to <code>False</code> if you want to restart from the initial time.</p>"},{"location":"user_guide/time_stepping_system/#time-stepping","title":"Time stepping","text":"<p>By default, an execution simulates from the initial time to the final time. Set <code>do_step</code> to <code>True</code> if you want to simulate with only one time step.</p>"},{"location":"user_guide/time_stepping_system/#time-step","title":"Time step","text":"<p>By default, the time-stepping disciplines use the time step passed at instantiation. Set <code>apply_time_step_to_disciplines</code> to <code>False</code>  if you want to use their specific time steps.</p>"}]}
{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#gemseo-fmu","title":"gemseo-fmu","text":""},{"location":"#overview","title":"Overview","text":"<p>GEMSEO-FMU is a GEMSEO plugin for loading, interacting, and simulating Functional Mockup Unit models (FMUs). FMUs are widely used by the simulation community and can be generated by over 200 tools such as Dymola, OpenModelica, CATIA, ANSYS, LS-DYNA, or MATLAB (see the full list here https://www.fmi-standard.org/tools).</p> <p>GEMSEO-FMU enables the integration and exploitation of FMUs in a Multidisciplinary Design Optimization (MDO) context, via GEMSEO. For that, it wraps the FMU model into a GEMSEO discipline named <code>FMUDiscipline</code>. GEMSEO-FMU also offers a <code>TimeSteppingSystem</code> class to co-simulate FMU models using a master algorithm.</p> <p>GEMSEO-FMU relies on the FMPy library for loading the FMU models, setting the model parameters and evaluating model equations. Model Exchange and Co-Simulation types as well as versions 1.0, 2.0 and 3.0 of the FMI standard are supported by FMPy, and so by GEMSEO-FMU.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install the latest version with <code>pip install gemseo-fmu</code>.</p> <p>See pip for more information.</p>"},{"location":"#bugs-and-questions","title":"Bugs and questions","text":"<p>Please use the gitlab issue tracker to submit bugs or questions.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>See the contributing section of GEMSEO.</p>"},{"location":"#contributors","title":"Contributors","text":"<ul> <li>Jorge Camacho Casero</li> <li>Fran\u00e7ois Gallard</li> <li>Antoine Dechaume</li> <li>Matthias De Lozzo</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":"<p>All notable changes of this project will be documented here.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#develop","title":"Develop","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>FMUDiscipline supports the variable types <code>Int32</code>, <code>Int64</code>, <code>Float64</code>, <code>Boolean</code>, <code>String</code> and <code>Enumeration</code> introduced by FMI3.</li> <li>TimeSeries.compute is a piecewise linear function when its field <code>interpolate</code> is <code>True</code>.</li> <li>TimeSeries.from_csv is used to create a TimeSeries from a CSV file.</li> <li>TimeSteppingSystem has a new option <code>mda_max_iter_at_t0</code> to perform an MDA at initial time with at most <code>mda_max_iter_at_t0</code> iterations.</li> <li>FMUDiscipline.set_default_execution has a new option <code>initialize_only</code> to simply initialize the FMU model at execution.</li> <li>FMUDiscipline has a new argument, named <code>time_name</code>, to set the name of the time variable (default: <code>\"time\"</code>).</li> <li>FMUDiscipline.set_default_execution has a new argument, named <code>use_arrays_only</code>, to pass only NumPy arrays at execution (default: <code>False</code>).</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>BaseFMUDiscipline supports array outputs (FMI3 only).</li> <li>FMUDiscipline supports FMI3 when <code>do_step</code> is <code>True</code></li> <li>FMUDiscipline supports FMI3 when using the default input data.</li> <li>TimeSteppingSystem supports input data passed as numbers.</li> <li>TimeSteppingSystem supports Gauss-Seidel as co-simulation algorithm.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>The time variable of FMUDiscipline is no longer namespaced but still prefixed by the discipline name: <code>f\"{discipline_name}_{time_name}\"</code>.</li> </ul>"},{"location":"changelog/#version-300-november-2024","title":"Version 3.0.0 (November 2024)","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Support GEMSEO v6.</li> <li>Support for Python 3.12.</li> <li>The class TimeManager can be used to create a time manager   from an initial time, a final time and a time step;   the current time can be updated   with the update_current_time method   and reset with the reset one.</li> <li>The method   FMUDiscipline.set_default_execution   can be used to redefine some default settings, such as <code>do_step</code>, <code>final_time</code>, <code>restart</code> and <code>time_step</code>.</li> <li>TimeSteppingSystem   has new arguments <code>mda_name</code> and <code>mda_options</code> to define the master algorithm,   e.g. a parallel master algorithm inspired by the Jacobi method when <code>mda_name=\"MDAJacobi\"</code> (default)   and a serial one inspired by the Gauss-Seidel method when <code>mda_name=\"MDAGaussSeidel\"</code>.</li> <li>TimeSteppingSystem   has a new argument <code>apply_time_step_to_disciplines</code> (default: <code>True</code>);   if <code>True</code>,   the value of its <code>time_step</code> argument is passed to the time-stepping disciplines;   otherwise,   the time-stepping disciplines use their own time steps.</li> <li>Any FMUDiscipline can use scalar input variables.</li> <li>A time-varying FMU model input can also be defined   as a time function of type <code>Callable[[TimeDurationType], float]</code>,   and not only a constant value or a   TimeSeries;   the documentation provides an example of this functionality.</li> <li>The method   FMUDiscipline.plot   draws the temporal evolution of output variables with lines.</li> <li>The components of   TimeSeries.time   can be either strings of characters such as <code>\"2h 34m 5s\"</code>,   or numbers expressed in seconds</li> <li>The arguments <code>initial_time</code>, <code>final_time</code> and <code>time_step</code> of   FMUDiscipline   can be strings of characters such as <code>\"2h 34m 5s\"</code>,   in addition to numbers expressed in seconds.</li> <li>TimeDuration   allows to define a time duration   based on a number expressed in seconds   or a string of characters such as <code>\"2h 34m 5s\"</code>.</li> <li>The <code>variable_names</code> argument of FMUDiscipline   allows the discipline to have input and output names different from the input and output names of the FMU model.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>TimeSeries is now   in the subpackage gemseo_fmu.utils.time_series.</li> <li>TimeSeries supports the <code>==</code> and <code>!=</code> operators.</li> <li>FMUDiscipline   stores the time evolution of its time-varying inputs   in its local_data   when <code>do_step</code> is <code>False</code>   and their values at current time otherwise.</li> <li>The installation page of the documentation no longer mentions the possibility   of installing via conda-forge.</li> <li>The installation page of the documentation no longer mentions the possibility   of using gemseo-fmu with Python 3.8.</li> <li>The readme file of the project now includes links to the documentation.</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>TimeSteppingSystem   can use input values of type TimeSeries.</li> <li>TimeSteppingSystem   can simulate up to the final time by adapting the last time step   in the case where the difference between the initial and final times is not a multiple of the time step.</li> <li>FMUDiscipline.set_next_execution   can be called several times before an execution.</li> <li><code>BaseFMUDiscipline._pre_instantiate</code> can now redefine time properties   relative to initial and final times, e.g. simulation time and current value.</li> <li>The points of a   TimeSeries   are interpreted as the starting points of the intervals of a stairs function   for FMU model inputs of causality <code>input</code>,   which is consistent with the FMU model input of causality <code>parameter</code>.</li> </ul>"},{"location":"changelog/#version-200-december-2023","title":"Version 2.0.0 (December 2023)","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Support for Python 3.11.</li> <li>The default behavior of   FMUDiscipline   is either simulating until the final time or during a time step;   it can also restart from initial time after each execution.</li> <li>FMUDiscipline.execute   can change the behavior of the   FMUDiscipline   temporarily, to simulate during a given simulation time, with a   different time step or from initial time.</li> <li>TimeSeries   allows to specify inputs as time series.</li> <li>gemseo-fmu.problems contains use cases,   either defined as FMUDiscipline   or simply as FMU files;   use get_fmu_file_path   to get a FMU file path easily.</li> <li>DoStepFMUDiscipline   is an FMUDiscipline   whose execution is only one time step ahead.</li> <li>TimeSteppingSystem   is a system of static and time-stepping disciplines   which executes them sequentially at each time step.</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>The FMUDiscipline   relies on the library FMPy.</li> <li>FMUDiscipline   is in gemseo-fmu.disciplines.</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<p>Support for Python 3.8.</p>"},{"location":"changelog/#version-101-june-2023","title":"Version 1.0.1 (June 2023)","text":"<p>Update to GEMSEO 5.</p>"},{"location":"changelog/#version-100-january-2023","title":"Version 1.0.0 (January 2023)","text":"<p>First release.</p>"},{"location":"credits/","title":"Credits","text":"<pre><code>Traceback (most recent call last):\n  File \"/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/markdown_exec/_internal/formatters/python.py\", line 71, in _run_python\n    exec_python(code, code_block_id, exec_globals)\n  File \"/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/markdown_exec/_internal/formatters/_exec_python.py\", line 8, in exec_python\n    exec(compiled, exec_globals)  # noqa: S102\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"&lt;code block: n1&gt;\", line 147, in &lt;module&gt;\n    print(_render_credits())  # noqa: T201\n           ^^^^^^^^^^^^^^^^^\n  File \"&lt;code block: n1&gt;\", line 100, in _render_credits\n    *project[\"optional-dependencies\"].values(),\n      ~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\nKeyError: 'optional-dependencies'\n</code></pre>"},{"location":"licenses/","title":"Licenses","text":""},{"location":"licenses/#licenses","title":"Licenses","text":""},{"location":"licenses/#gnu-lgpl-v30","title":"GNU LGPL v3.0","text":"<p>The <code>gemseo-fmu</code> source code is distributed under the GNU LGPL v3.0 license. <pre><code>Copyright 2021 IRT Saint Exup\u00e9ry, https://www.irt-saintexupery.com\n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU Lesser General Public\nLicense version 3 as published by the Free Software Foundation.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nLesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with this program; if not, write to the Free Software Foundation,\nInc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n</code></pre></p>"},{"location":"licenses/#bsd-0-clause","title":"BSD 0-Clause","text":"<p>The <code>gemseo-fmu</code> examples are distributed under the BSD 0-Clause <pre><code>Copyright 2021 IRT Saint Exup\u00e9ry, https://www.irt-saintexupery.com\n\nThis work is licensed under a BSD 0-Clause License.\n\nPermission to use, copy, modify, and/or distribute this software\nfor any purpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL\nWARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL\nTHE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,\nOR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING\nFROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\nNEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\nWITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n</code></pre></p>"},{"location":"licenses/#cc-by-sa-40","title":"CC BY-SA 4.0","text":"<p>The <code>gemseo-fmu</code> documentation is distributed under the CC BY-SA 4.0 license. <pre><code>Copyright 2021 IRT Saint Exup\u00e9ry, https://www.irt-saintexupery.com\n\nThis work is licensed under the Creative Commons Attribution-ShareAlike 4.0\nInternational License. To view a copy of this license, visit\nhttp://creativecommons.org/licenses/by-sa/4.0/ or send a letter to Creative\nCommons, PO Box 1866, Mountain View, CA 94042, USA.\n</code></pre></p>"},{"location":"developer_guide/class_diagram/","title":"Developer guide","text":""},{"location":"developer_guide/class_diagram/#class-diagram","title":"Class diagram","text":"<p>This section describes the design of the gemseo_fmu package.</p> <pre><code>classDiagram\n    Discipline &lt;|-- BaseFMUDiscipline\n    Discipline &lt;|-- TimeSteppingSystem\n\n    BaseFMUDiscipline &lt;|-- FMUDiscipline\n    BaseFMUDiscipline &lt;|-- StaticDiscipline\n    FMUDiscipline &lt;|-- DoStepFMUDiscipline\n\n    TimeSteppingSystem \"1\" o-- \"n\" DoStepFMUDiscipline\n\n    BaseFMUDiscipline *-- TimeManager\n    TimeSteppingSystem *-- TimeManager\n\n    TimeSeries &lt;-- BaseFMUDiscipline\n\n    TimeDuration &lt;-- BaseFMUDiscipline\n    TimeSeries --&gt; TimeDuration\n\n    namespace FMUDisciplines {\n    class BaseFMUDiscipline {\n        +causalities_to_variable_names\n        +default_inputs\n        +model\n        +model_description\n        +name\n        +execute()\n        +set_default_execution()\n        +set_next_execution()\n    }\n\n    class FMUDiscipline {\n        +initial_values\n        +time\n        +plot()\n    }\n\n    class StaticDiscipline\n    class DoStepFMUDiscipline\n\n    }\n\n    class TimeManager {\n        +initial\n        +current\n        +final\n        +is_constant\n        +is_initial\n        +is_final\n        +step\n        +reset()\n        +update_current_time()\n    }\n\n    class TimeSteppingSystem {\n        +default_inputs\n        +execute()\n    }\n\n    class TimeSeries {\n        +observable\n        +size\n        +time\n        +tolerance\n        +compute()\n    }\n\n    class TimeDuration {\n        days\n        hours\n        microseconds\n        milliseconds\n        minutes\n        months\n        seconds\n        value\n        weeks\n        years\n        to()\n    }\n\n    TimeSteppingSystem *-- BaseMDA\n    &lt;&lt;abstract&gt;&gt; BaseMDA\n    BaseMDA &lt;|-- MDAGaussSeidel\n    BaseMDA &lt;|-- MDAJacobi</code></pre>"},{"location":"generated/examples/co_simulation/","title":"Co-simulation","text":""},{"location":"generated/examples/co_simulation/#time-stepping-systems","title":"Time stepping systems","text":"<p> Co-simulation from multidisciplinary feasible initial conditions </p> <p> Co-simulation with a parallel master algorithm </p> <p> Co-simulation with a serial master algorithm </p> <p> Co-simulation with multiple time steps </p> <p> Download all examples in Python source code: co_simulation_python.zip</p> <p> Download all examples in Jupyter notebooks: co_simulation_jupyter.zip</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/co_simulation/mg_execution_times/","title":"Computation times","text":"<p>00:19.611 total execution time for generated_examples_co_simulation files:</p> <p>+---------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_jacobi (docs/examples/co_simulation/plot_jacobi.py)                                        | 00:07.636 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_multiple_time_steps (docs/examples/co_simulation/plot_multiple_time_steps.py) | 00:05.682 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_initial_conditions (docs/examples/co_simulation/plot_initial_conditions.py)    | 00:04.459 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_gauss_seidel (docs/examples/co_simulation/plot_gauss_seidel.py)                      | 00:01.835 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/examples/co_simulation/plot_gauss_seidel/","title":"Co-simulation with a serial master algorithm","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/co_simulation/plot_gauss_seidel/#co-simulation-with-a-serial-master-algorithm","title":"Co-simulation with a serial master algorithm","text":"<p>Sometimes, we may want to simulate a system of several FMU models coupled together. TimeSteppingSystem allows to perform this co-simulation task, with a parallel master algorithm based on the Jacobi method. In this example, we will see how to replace this master algorithm by a serial one using the Gauss-Seidel method.</p> <pre><code>from __future__ import annotations\n\nfrom gemseo import generate_xdsm\nfrom matplotlib import pyplot as plt\n\nfrom gemseo_fmu.disciplines.fmu_discipline import FMUDiscipline\nfrom gemseo_fmu.disciplines.time_stepping_system import TimeSteppingSystem\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\n</code></pre> <p>Let us consider a set of two mass-spring pairs connected to each other and modelled by two FMU models:</p> \\[ \\begin{cases} x_1' = v_1\\\\ v_1' = -\\frac{k_1+k_2}{m_1}x_1+\\frac{k_2}{m_1}x_2 \\end{cases} \\] <p>and</p> \\[ \\begin{cases} x_2' = v_2\\\\ v_2' = -\\frac{k_2+k_3}{m_2}x_2+\\frac{k_2}{m_2}x_1 \\end{cases} \\] <p>These models can be co-simulated by instantiating a TimeSteppingSystem:</p> <pre><code>system = TimeSteppingSystem(\n    (\n        get_fmu_file_path(\"MassSpringSubSystem1\"),\n        get_fmu_file_path(\"MassSpringSubSystem2\"),\n    ),\n    50,\n    0.01,\n    mda_name=\"MDAGaussSeidel\",\n)\n</code></pre> <p>Note that in this case, we do not use the default MDA name <code>\"MDAJacobi\"</code> implementing a Jacobi method but <code>\"MDAGaussSeidel\"</code> implementing a Gauss-Seidel technique. The disciplines are no longer executed in parallel but sequentially:</p> <pre><code>generate_xdsm(system, save_html=False)\n</code></pre> <p>Then we can execute this system from initial time to final time:</p> <pre><code>system.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/pydantic/main.py:705: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'k1': array([1.]), 'k2': array([1.]), 'm1': array([1.]), 'x2': array([1.        , 0.999801  , 0.99940401, ..., 1.20466672, 1.22777893,\n       1.22777893], shape=(5001,)), 'k3': array([1.]), 'm2': array([1.]), 'v1': array([ 1.01      ,  1.0198    ,  1.02939601, ..., -0.51206915,\n       -0.49606332, -0.49606332], shape=(5001,)), 'x1': array([ 0.01      ,  0.0201    ,  0.030298  , ..., -0.19795826,\n       -0.20307895, -0.20307895], shape=(5001,)), 'MassSpringSubSystem1_time': array([1.000e-02, 2.000e-02, 3.000e-02, ..., 4.999e+01, 5.000e+01,\n       5.000e+01], shape=(5001,)), 'v2': array([-0.0199    , -0.039699  , -0.05939204, ...,  2.31122156,\n        2.28509744,  2.28509744], shape=(5001,)), 'MassSpringSubSystem2_time': array([1.000e-02, 2.000e-02, 3.000e-02, ..., 4.999e+01, 5.000e+01,\n       5.000e+01], shape=(5001,))}\n</code></pre> <p>or with time stepping by setting <code>do_step</code> to <code>False</code> at instantiation. For this particular example, we also have a FMU model of the complete system:</p> <pre><code>reference = FMUDiscipline(\n    get_fmu_file_path(\"MassSpringSystem\"), final_time=50, time_step=0.01\n)\nreference.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/pydantic/main.py:705: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'k1': array([1.]), 'k2': array([1.]), 'k3': array([1.]), 'm1': array([1.]), 'm2': array([1.]), 'v1': array([ 1.        ,  1.01      ,  1.0198    , ..., -0.83587438,\n       -0.81690925, -0.79753386], shape=(5001,)), 'v2': array([ 0.        , -0.02      , -0.0399    , ...,  2.43080622,\n        2.40316415,  2.37495232], shape=(5001,)), 'x1': array([ 0.        ,  0.01      ,  0.0201    , ..., -0.34293973,\n       -0.35129848, -0.35946757], shape=(5001,)), 'x2': array([1.        , 1.        , 0.9998    , ..., 1.21063389, 1.23494196,\n       1.2589736 ], shape=(5001,)), 'MassSpringSystem_time': array([0.000e+00, 1.000e-02, 2.000e-02, ..., 4.998e+01, 4.999e+01,\n       5.000e+01], shape=(5001,))}\n</code></pre> <p>Then, we can compare the solutions graphically in terms of position and velocity of the two masses and note that for this example, the co-simulation of the two subsystems is equivalent to that of the complete system.</p> <pre><code>fig, (ax1, ax2) = plt.subplots(2, 1)\ntime_1 = system.local_data[\"MassSpringSubSystem1_time\"]\ntime_2 = system.local_data[\"MassSpringSubSystem2_time\"]\nax1.plot(time_1, system.local_data[\"x1\"], label=\"x1\", color=\"red\")\nax1.plot(time_2, system.local_data[\"x2\"], label=\"x2\", color=\"blue\")\nax2.plot(time_1, system.local_data[\"v1\"], label=\"v1\", color=\"red\")\nax2.plot(time_2, system.local_data[\"v2\"], label=\"v2\", color=\"blue\")\n\ntime = reference.local_data[\"MassSpringSystem_time\"]\nax1.plot(time, reference.local_data[\"x1\"], label=\"x1[ref]\", linestyle=\"--\", color=\"red\")\nax1.plot(\n    time, reference.local_data[\"x2\"], label=\"x2[ref]\", linestyle=\"--\", color=\"blue\"\n)\nax2.plot(time, reference.local_data[\"v1\"], label=\"v1[ref]\", linestyle=\"--\", color=\"red\")\nax2.plot(\n    time, reference.local_data[\"v2\"], label=\"v2[ref]\", linestyle=\"--\", color=\"blue\"\n)\n\nax1.set_xlabel(\"Time (s)\")\nax1.set_ylabel(\"Position (m)\")\nax1.grid()\nax1.legend()\nax2.set_xlabel(\"Time (s)\")\nax2.set_ylabel(\"Velocity (m/s)\")\nax2.grid()\nax2.legend()\nplt.show()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  1.835 seconds)</p> <p> Download Python source code: plot_gauss_seidel.py</p> <p> Download Jupyter notebook: plot_gauss_seidel.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/co_simulation/plot_initial_conditions/","title":"Co-simulation from multidisciplinary feasible initial conditions","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/co_simulation/plot_initial_conditions/#co-simulation-from-multidisciplinary-feasible-initial-conditions","title":"Co-simulation from multidisciplinary feasible initial conditions","text":"<pre><code>from numpy import array\n\nfrom gemseo_fmu.disciplines.static_fmu_discipline import StaticFMUDiscipline\nfrom gemseo_fmu.disciplines.time_stepping_system import TimeSteppingSystem\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/gemseo/caches/_hdf5_file_singleton.py:36: DeprecationWarning: numpy.core.multiarray is deprecated and has been renamed to numpy._core.multiarray. The numpy._core namespace contains private NumPy internals and its use is discouraged, as NumPy internals can change without warning in any release. In practice, most real-world usage of numpy.core is to access functionality in the public NumPy API. If that is the case, use the public NumPy API. If not, you are using NumPy internals. If you would still like to access an internal attribute, use numpy._core.multiarray.array.\n  from numpy.core.multiarray import array\n/builds/gemseo/dev/gemseo-fmu/src/gemseo_fmu/disciplines/base_fmu_discipline.py:49: DeprecationWarning: numpy.core.shape_base is deprecated and has been renamed to numpy._core.shape_base. The numpy._core namespace contains private NumPy internals and its use is discouraged, as NumPy internals can change without warning in any release. In practice, most real-world usage of numpy.core is to access functionality in the public NumPy API. If that is the case, use the public NumPy API. If not, you are using NumPy internals. If you would still like to access an internal attribute, use numpy._core.shape_base.atleast_1d.\n  from numpy.core.shape_base import atleast_1d\n</code></pre>"},{"location":"generated/examples/co_simulation/plot_initial_conditions/#the-problem","title":"The problem","text":"<p>When co-simulating several FMU models, the latter do not always have consistent initial conditions, which can complicate the running of the master algorithm and result in erroneous variable evolutions over time.</p> <p>In this example, we will see how to update these initial conditions to make them multidisciplinary feasible. For that, we consider a very simple example:</p> <ul> <li>a discipline A   computes \\(x(t) = x(t-1) + 1\\) at \\(t&gt;0\\)   with the initial equation \\(x(0) = 3 + y(0)\\)   and the initial condition \\(x(0) = 1\\),</li> <li>a discipline B computes \\(y(t) = y(t-1) + 2\\) at \\(t&gt;0\\)   with the initial equation \\(y(0) = 3 + 2x(0)\\)   and the initial condition \\(y(0) = 1\\).</li> </ul> <p>So, after initialization, the output of A is incremented by 1 at each execution, while the output of B is incremented by 2.</p> <p>These disciplines are very similar, differing only in terms of increment and initial conditions. For this reason, they are implemented from the same FMU model, whose variables are renamed:</p> <pre><code>a = StaticFMUDiscipline(\n    get_fmu_file_path(\"FMU3Model\"),\n    variable_names={\"input\": \"y\", \"output\": \"x\", \"increment\": \"inc_a\"},\n    name=\"A\",\n)\nb = StaticFMUDiscipline(\n    get_fmu_file_path(\"FMU3Model\"),\n    variable_names={\"input\": \"x\", \"output\": \"y\", \"increment\": \"inc_b\"},\n    name=\"B\",\n)\nb.default_input_data[\"inc_b\"] = array([2.0])\n</code></pre>"},{"location":"generated/examples/co_simulation/plot_initial_conditions/#the-wrong-way","title":"The wrong way","text":"<p>First, we can co-simulate these disciplines with the current initial conditions without iterating the master algorithm at initial time:</p> <pre><code>system = TimeSteppingSystem(\n    (a, b),\n    3,\n    1,\n)\n_ = system.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/pydantic/main.py:705: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n</code></pre> <p>and note the time evolutions of the output variables after three time steps:</p> <pre><code>{name: system.io.data[name] for name in [\"x\", \"y\"]}\n</code></pre> <p>Out:</p> <pre><code>{'x': array([4., 5., 6.]), 'y': array([5., 7., 9.])}\n</code></pre>"},{"location":"generated/examples/co_simulation/plot_initial_conditions/#the-right-way","title":"The right way","text":"<p>Then, we can co-simulate these disciplines, by applying the default master algorithm at initial time:</p> <pre><code>system = TimeSteppingSystem(\n    (a, b),\n    3,\n    1,\n    mda_max_iter_at_t0=10,\n)\n_ = system.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/pydantic/main.py:705: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n</code></pre> <p>and see that the time evolutions of the output variables after three time steps have changed:</p> <pre><code>{name: system.io.data[name] for name in [\"x\", \"y\"]}\n</code></pre> <p>Out:</p> <pre><code>{'x': array([-5., -4., -3.]), 'y': array([-7., -5., -3.])}\n</code></pre>"},{"location":"generated/examples/co_simulation/plot_initial_conditions/#the-difference","title":"The difference","text":"<p>This difference can be explained by the fact that the master algorithm has corrected the initial conditions, which were inconsistent.</p> <p>Indeed, the statement said that \\(x(0) = 1\\) and \\(y(0) = 3 + 2x(0)\\). Then, \\(y(0) = 5\\). But the statement said also that \\(y(0) = 1\\), which is contradictory!</p> <p>Now, let us consider the initial equation system</p> \\[\\left\\{\\begin{matrix}x(0) = 3 + y(0)\\\\ y(0) = 3 + 2x(0)\\end{matrix}\\right.\\] <p>Its analytical solution is \\((x(0),y(0)) = (-6,-9)\\). This is what the master algorithm found numerically, before the three time steps increment these values.</p>"},{"location":"generated/examples/co_simulation/plot_initial_conditions/#the-take-home-message","title":"The take-home message","text":"<p>When models have potentially inconsistent initial conditions, it may be prudent to perform a few iterations of the master algorithm at the initial time to ensure that the initial conditions are multidisciplinary feasible. To do this, fill in the argument <code>mda_max_iter_at_t0</code> of the TimeSteppingSystem.</p> <p>Total running time of the script: ( 0 minutes  4.459 seconds)</p> <p> Download Python source code: plot_initial_conditions.py</p> <p> Download Jupyter notebook: plot_initial_conditions.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/co_simulation/plot_jacobi/","title":"Co-simulation with a parallel master algorithm","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/co_simulation/plot_jacobi/#co-simulation-with-a-parallel-master-algorithm","title":"Co-simulation with a parallel master algorithm","text":"<p>Sometimes, we may want to simulate a system of several FMU models coupled together. TimeSteppingSystem allows to perform this co-simulation task.</p> <pre><code>from __future__ import annotations\n\nfrom gemseo import generate_xdsm\nfrom matplotlib import pyplot as plt\n\nfrom gemseo_fmu.disciplines.fmu_discipline import FMUDiscipline\nfrom gemseo_fmu.disciplines.time_stepping_system import TimeSteppingSystem\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\n</code></pre> <p>Let us consider a set of two mass-spring pairs connected to each other and modelled by two FMU models:</p> \\[ \\begin{cases} x_1' = v_1\\\\ v_1' = -\\frac{k_1+k_2}{m_1}x_1+\\frac{k_2}{m_1}x_2 \\end{cases} \\] <p>and</p> \\[ \\begin{cases} x_2' = v_2\\\\ v_2' = -\\frac{k_2+k_3}{m_2}x_2+\\frac{k_2}{m_2}x_1 \\end{cases} \\] <p>These models can be co-simulated by instantiating a TimeSteppingSystem:</p> <pre><code>system = TimeSteppingSystem(\n    (\n        get_fmu_file_path(\"MassSpringSubSystem1\"),\n        get_fmu_file_path(\"MassSpringSubSystem2\"),\n    ),\n    50,\n    0.01,\n)\n</code></pre> <p>We can have a quick look at the Jacobi-based co-simulation process (the strongly coupled FMU models are evaluated in parallel):</p> <pre><code>generate_xdsm(system, save_html=False)\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/gemseo/disciplines/scenario_adapters/mdo_scenario_adapter.py:35: DeprecationWarning: The numpy.linalg.linalg has been made private and renamed to numpy.linalg._linalg. All public functions exported by it are available from numpy.linalg. Please use numpy.linalg.norm instead.\n  from gemseo.algos.post_optimal_analysis import PostOptimalAnalysis\n&lt;frozen importlib._bootstrap&gt;:488: DeprecationWarning: builtin type SwigPyPacked has no __module__ attribute\n&lt;frozen importlib._bootstrap&gt;:488: DeprecationWarning: builtin type SwigPyObject has no __module__ attribute\n&lt;frozen importlib._bootstrap&gt;:488: DeprecationWarning: builtin type swigvarlink has no __module__ attribute\n</code></pre> <p>before executing it from initial time to final time:</p> <pre><code>system.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/pydantic/main.py:705: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'k1': array([1.]), 'k2': array([1.]), 'm1': array([1.]), 'x2': array([1.        , 0.9998    , 0.999401  , ..., 1.23494196, 1.2589736 ,\n       1.2589736 ], shape=(5001,)), 'k3': array([1.]), 'm2': array([1.]), 'x1': array([ 0.01      ,  0.0201    ,  0.030298  , ..., -0.35129848,\n       -0.35946757, -0.35946757], shape=(5001,)), 'v1': array([ 1.01      ,  1.0198    ,  1.029396  , ..., -0.81690925,\n       -0.79753386, -0.79753386], shape=(5001,)), 'MassSpringSubSystem1_time': array([1.000e-02, 2.000e-02, 3.000e-02, ..., 4.999e+01, 5.000e+01,\n       5.000e+01], shape=(5001,)), 'v2': array([-0.02      , -0.0399    , -0.059695  , ...,  2.40316415,\n        2.37495232,  2.37495232], shape=(5001,)), 'MassSpringSubSystem2_time': array([1.000e-02, 2.000e-02, 3.000e-02, ..., 4.999e+01, 5.000e+01,\n       5.000e+01], shape=(5001,)), 'MDA residuals norm': array([1.00000000e+00, 1.01019800e+00, 1.02058025e+00, ...,\n       2.57050673e+00, 2.53821564e+00, 3.45347493e-10], shape=(5001,))}\n</code></pre> <p>or with time stepping by setting <code>do_step</code> to <code>False</code> at instantiation. For this particular example, we also have a FMU model of the complete system:</p> <pre><code>reference = FMUDiscipline(\n    get_fmu_file_path(\"MassSpringSystem\"), final_time=50, time_step=0.01\n)\nreference.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/pydantic/main.py:705: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'k1': array([1.]), 'k2': array([1.]), 'k3': array([1.]), 'm1': array([1.]), 'm2': array([1.]), 'v1': array([ 1.        ,  1.01      ,  1.0198    , ..., -0.83587438,\n       -0.81690925, -0.79753386], shape=(5001,)), 'v2': array([ 0.        , -0.02      , -0.0399    , ...,  2.43080622,\n        2.40316415,  2.37495232], shape=(5001,)), 'x1': array([ 0.        ,  0.01      ,  0.0201    , ..., -0.34293973,\n       -0.35129848, -0.35946757], shape=(5001,)), 'x2': array([1.        , 1.        , 0.9998    , ..., 1.21063389, 1.23494196,\n       1.2589736 ], shape=(5001,)), 'MassSpringSystem_time': array([0.000e+00, 1.000e-02, 2.000e-02, ..., 4.998e+01, 4.999e+01,\n       5.000e+01], shape=(5001,))}\n</code></pre> <p>Then, we can compare the solutions graphically in terms of position and velocity of the two masses and note that for this example, the co-simulation of the two subsystems is equivalent to that of the complete system.</p> <pre><code>fig, (ax1, ax2) = plt.subplots(2, 1)\ntime_1 = system.local_data[\"MassSpringSubSystem1_time\"]\ntime_2 = system.local_data[\"MassSpringSubSystem2_time\"]\nax1.plot(time_1, system.local_data[\"x1\"], label=\"x1\", color=\"red\")\nax1.plot(time_2, system.local_data[\"x2\"], label=\"x2\", color=\"blue\")\nax2.plot(time_1, system.local_data[\"v1\"], label=\"v1\", color=\"red\")\nax2.plot(time_2, system.local_data[\"v2\"], label=\"v2\", color=\"blue\")\n\ntime = reference.local_data[\"MassSpringSystem_time\"]\nax1.plot(time, reference.local_data[\"x1\"], label=\"x1[ref]\", linestyle=\"--\", color=\"red\")\nax1.plot(\n    time, reference.local_data[\"x2\"], label=\"x2[ref]\", linestyle=\"--\", color=\"blue\"\n)\nax2.plot(time, reference.local_data[\"v1\"], label=\"v1[ref]\", linestyle=\"--\", color=\"red\")\nax2.plot(\n    time, reference.local_data[\"v2\"], label=\"v2[ref]\", linestyle=\"--\", color=\"blue\"\n)\n\nax1.set_xlabel(\"Time (s)\")\nax1.set_ylabel(\"Position (m)\")\nax1.grid()\nax1.legend()\nax2.set_xlabel(\"Time (s)\")\nax2.set_ylabel(\"Velocity (m/s)\")\nax2.grid()\nax2.legend()\nplt.show()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  7.636 seconds)</p> <p> Download Python source code: plot_jacobi.py</p> <p> Download Jupyter notebook: plot_jacobi.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/co_simulation/plot_multiple_time_steps/","title":"Co-simulation with multiple time steps","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/co_simulation/plot_multiple_time_steps/#co-simulation-with-multiple-time-steps","title":"Co-simulation with multiple time steps","text":"<p>Sometimes, we may want to simulate a system of several FMU models coupled together. TimeSteppingSystem allows to perform this co-simulation task, even in the presence of FMU models with variable time steps.</p> <pre><code>from __future__ import annotations\n\nfrom matplotlib import pyplot as plt\n\nfrom gemseo_fmu.disciplines.do_step_fmu_discipline import DoStepFMUDiscipline\nfrom gemseo_fmu.disciplines.fmu_discipline import FMUDiscipline\nfrom gemseo_fmu.disciplines.time_stepping_system import TimeSteppingSystem\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\n</code></pre> <p>Let us consider a set of two mass-spring pairs connected to each other and modelled by two FMU models:</p> \\[ \\begin{cases} x_1' = v_1\\\\ v_1' = -\\frac{k_1+k_2}{m_1}x_1+\\frac{k_2}{m_1}x_2 \\end{cases} \\] <p>and</p> \\[ \\begin{cases} x_2' = v_2\\\\ v_2' = -\\frac{k_2+k_3}{m_2}x_2+\\frac{k_2}{m_2}x_1 \\end{cases} \\] <p>These models can be modeled using the DoStepFMUDiscipline class. For illustration purposes, we use different time steps for these models:</p> <pre><code>sub_system_1 = DoStepFMUDiscipline(\n    get_fmu_file_path(\"MassSpringSubSystem1\"), time_step=0.004\n)\nsub_system_2 = DoStepFMUDiscipline(\n    get_fmu_file_path(\"MassSpringSubSystem2\"), time_step=0.01\n)\n</code></pre> <p>Note</p> <p>There is no need for one time step to be a multiple of the other.</p> <p>Then, these disciplines can be co-simulated by instantiating a TimeSteppingSystem.</p> <pre><code>system = TimeSteppingSystem(\n    (sub_system_1, sub_system_2), 50, 0.01, apply_time_step_to_disciplines=False\n)\n</code></pre> <p>and executing it from initial time to final time:</p> <pre><code>system.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/pydantic/main.py:705: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'k1': array([1.]), 'k2': array([1.]), 'm1': array([1.]), 'x2': array([1.        , 0.9998    , 0.999401  , ..., 1.03766458, 1.05780873,\n       1.05780873], shape=(5001,)), 'k3': array([1.]), 'm2': array([1.]), 'x1': array([ 0.01003194,  0.02016259,  0.03038993, ..., -0.26450989,\n       -0.27054247, -0.27054247], shape=(5001,)), 'v1': array([ 1.00993594,  1.0196706 ,  1.02920003, ..., -0.60827531,\n       -0.59256964, -0.59256964], shape=(5001,)), 'MassSpringSubSystem1_time': array([1.000e-02, 2.000e-02, 3.000e-02, ..., 4.999e+01, 5.000e+01,\n       5.000e+01], shape=(5001,)), 'v2': array([-0.02      , -0.03989968, -0.05969405, ...,  2.01441517,\n        1.99101678,  1.99101678], shape=(5001,)), 'MassSpringSubSystem2_time': array([1.000e-02, 2.000e-02, 3.000e-02, ..., 4.999e+01, 5.000e+01,\n       5.000e+01], shape=(5001,)), 'MDA residuals norm': array([1.00000000e+00, 1.01003702e+00, 1.02025411e+00, ...,\n       2.12245001e+00, 2.09611083e+00, 2.85433705e-10], shape=(5001,))}\n</code></pre> <p>or with time stepping by setting <code>do_step</code> to <code>False</code> at instantiation.</p> <p>Note</p> <p>We set <code>apply_time_step_to_disciplines</code> to <code>False</code> at instantiation in order to let the disciplines use their own time steps. By default, the global time step passed at instantiation (0.1 in this example) is used by the disciplines.</p> <p>For this particular example, we also have a FMU model of the complete system:</p> <pre><code>reference = FMUDiscipline(\n    get_fmu_file_path(\"MassSpringSystem\"), final_time=50, time_step=0.01\n)\nreference.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/pydantic/main.py:705: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'k1': array([1.]), 'k2': array([1.]), 'k3': array([1.]), 'm1': array([1.]), 'm2': array([1.]), 'v1': array([ 1.        ,  1.01      ,  1.0198    , ..., -0.83587438,\n       -0.81690925, -0.79753386], shape=(5001,)), 'v2': array([ 0.        , -0.02      , -0.0399    , ...,  2.43080622,\n        2.40316415,  2.37495232], shape=(5001,)), 'x1': array([ 0.        ,  0.01      ,  0.0201    , ..., -0.34293973,\n       -0.35129848, -0.35946757], shape=(5001,)), 'x2': array([1.        , 1.        , 0.9998    , ..., 1.21063389, 1.23494196,\n       1.2589736 ], shape=(5001,)), 'MassSpringSystem_time': array([0.000e+00, 1.000e-02, 2.000e-02, ..., 4.998e+01, 4.999e+01,\n       5.000e+01], shape=(5001,))}\n</code></pre> <p>Then, we can compare the solutions graphically in terms of position and velocity of the two masses and note that for this example, the co-simulation of the two subsystems is equivalent to that of the complete system.</p> <pre><code>fig, (ax1, ax2) = plt.subplots(2, 1)\ntime_1 = system.local_data[\"MassSpringSubSystem1_time\"]\ntime_2 = system.local_data[\"MassSpringSubSystem2_time\"]\nax1.plot(time_1, system.local_data[\"x1\"], label=\"x1\", color=\"red\")\nax1.plot(time_2, system.local_data[\"x2\"], label=\"x2\", color=\"blue\")\nax2.plot(time_1, system.local_data[\"v1\"], label=\"v1\", color=\"red\")\nax2.plot(time_2, system.local_data[\"v2\"], label=\"v2\", color=\"blue\")\n\ntime = reference.local_data[\"MassSpringSystem_time\"]\nax1.plot(time, reference.local_data[\"x1\"], label=\"x1[ref]\", linestyle=\"--\", color=\"red\")\nax1.plot(\n    time, reference.local_data[\"x2\"], label=\"x2[ref]\", linestyle=\"--\", color=\"blue\"\n)\nax2.plot(time, reference.local_data[\"v1\"], label=\"v1[ref]\", linestyle=\"--\", color=\"red\")\nax2.plot(\n    time, reference.local_data[\"v2\"], label=\"v2[ref]\", linestyle=\"--\", color=\"blue\"\n)\n\nax1.set_xlabel(\"Time (s)\")\nax1.set_ylabel(\"Position (m)\")\nax1.grid()\nax1.legend()\nax2.set_xlabel(\"Time (s)\")\nax2.set_ylabel(\"Velocity (m/s)\")\nax2.grid()\nax2.legend()\nplt.show()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  5.682 seconds)</p> <p> Download Python source code: plot_multiple_time_steps.py</p> <p> Download Jupyter notebook: plot_multiple_time_steps.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/disciplines/","title":"Disciplines","text":""},{"location":"generated/examples/disciplines/#disciplines","title":"Disciplines","text":""},{"location":"generated/examples/disciplines/#dynamic-fmu-discipline","title":"Dynamic FMU discipline","text":"<p>Info</p> <p>FMUDiscipline is an alias of DynamicFMUDiscipline and can be used to simulate both time-dependent and time-independent FMU models. Most of the time, the FMU model are dynamic and so this naming shortcut can be useful. However, to avoid any confusion, we prefer to use DynamicFMUDiscipline.</p> <p> Time as a character string </p> <p> Use time stepping </p> <p> Plot a time evolution </p> <p> From initial time to final time </p> <p> Do not restart </p> <p> Use time functions </p> <p> Use time series </p> <p> Set evaluation time </p>"},{"location":"generated/examples/disciplines/#static-fmu-discipline","title":"Static FMU discipline","text":"<p> Static discipline </p> <p> Download all examples in Python source code: disciplines_python.zip</p> <p> Download all examples in Jupyter notebooks: disciplines_jupyter.zip</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/disciplines/dynamic/mg_execution_times/","title":"Computation times","text":"<p>00:02.317 total execution time for generated_examples_disciplines_dynamic files:</p> <p>+---------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_plot_time_evolution (docs/examples/disciplines/dynamic/plot_plot_time_evolution.py)                                     | 00:00.616 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_time_series (docs/examples/disciplines/dynamic/plot_time_series.py)                                                             | 00:00.356 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_time_function (docs/examples/disciplines/dynamic/plot_time_function.py)                                                       | 00:00.349 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_evaluation_time (docs/examples/disciplines/dynamic/plot_evaluation_time.py)                                                 | 00:00.286 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_from_initial_time_to_final_time (docs/examples/disciplines/dynamic/plot_from_initial_time_to_final_time.py) | 00:00.236 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_restart_false (docs/examples/disciplines/dynamic/plot_restart_false.py)                                                       | 00:00.180 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_string_time (docs/examples/disciplines/dynamic/plot_string_time.py)                                                             | 00:00.166 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_do_step (docs/examples/disciplines/dynamic/plot_do_step.py)                                                                         | 00:00.129 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/examples/disciplines/dynamic/plot_do_step/","title":"Use time stepping","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/disciplines/dynamic/plot_do_step/#use-time-stepping","title":"Use time stepping","text":"<p>The DoStepFMUDiscipline can be used to simulate a co-simulation FMU model by manually advancing one step at a time.</p> <pre><code>from __future__ import annotations\n\nfrom matplotlib import pyplot as plt\n\nfrom gemseo_fmu.disciplines.do_step_fmu_discipline import DoStepFMUDiscipline\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\n</code></pre> <p>Let us create a discipline to simulate a mass damper defined in an FMU model from 0 to 1 second with a time step of 0.1 millisecond:</p> <p></p> <p>We only use the mass of the sliding mass [kg] and the spring constant [N/m] as inputs. The position of the mass [m] is used as output.</p> <pre><code>discipline = DoStepFMUDiscipline(\n    get_fmu_file_path(\"Mass_Damper\"),\n    [\"mass.m\", \"spring.c\"],\n    [\"y\"],\n    initial_time=0.0,\n    final_time=1.0,\n    time_step=0.0001,\n)\n</code></pre> <p>Then, we execute the discipline 10 times and create the graph as we go along with different point colors. In that case, executing the discipline 10 times means that we are advancing 10 times by one time step.</p> <pre><code>for _ in range(10):\n    discipline.execute()\n    plt.scatter(\n        discipline.time,\n        discipline.local_data[\"y\"],\n    )\nplt.xlabel(\"Time [s]\")\nplt.ylabel(\"Amplitude [m]\")\nplt.show()\n</code></pre> <p></p> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/pydantic/main.py:705: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n</code></pre> <p>Note</p> <p>We can also do time stepping with DynamicFMUDiscipline by setting <code>do_step</code> to <code>False</code> and <code>restart</code> to <code>False</code>.</p> <p>Total running time of the script: ( 0 minutes  0.129 seconds)</p> <p> Download Python source code: plot_do_step.py</p> <p> Download Jupyter notebook: plot_do_step.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/disciplines/dynamic/plot_evaluation_time/","title":"Set evaluation time","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/disciplines/dynamic/plot_evaluation_time/#set-evaluation-time","title":"Set evaluation time","text":"<p>Instead of simulating an FMU model from an initial time to a final time in one go, we may want to simulate it time window by time window.</p> <p>The DynamicFMUDiscipline makes this possible.</p> <pre><code>from __future__ import annotations\n\nfrom matplotlib import pyplot as plt\n\nfrom gemseo_fmu.disciplines.dynamic_fmu_discipline import DynamicFMUDiscipline\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\n</code></pre> <p>Let us create a discipline to simulate a mass damper defined in an FMU model from 0 to 1 second with a time step of 0.1 milliseconds:</p> <p></p> <p>We only use the mass of the sliding mass [kg] and the spring constant [N/m] as inputs. The position of the mass [m] is used as output.</p> <pre><code>discipline = DynamicFMUDiscipline(\n    get_fmu_file_path(\"Mass_Damper\"),\n    [\"mass.m\", \"spring.c\"],\n    [\"y\"],\n    initial_time=0.0,\n    final_time=1.0,\n    time_step=0.0001,\n)\n</code></pre> <p>Firstly, we execute the discipline setting a simulation time of 0.3 seconds with the default input values:</p> <pre><code>discipline.set_next_execution(simulation_time=0.3)\ndiscipline.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/pydantic/main.py:705: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'mass.m': array([1.]), 'spring.c': array([10000.]), 'y': array([ 0.00000000e+00,  0.00000000e+00, -5.00000000e-05, ...,\n       -4.92042818e-01, -4.90752654e-01, -4.89464576e-01], shape=(3001,)), 'Mass_Damper_time': array([0.000e+00, 1.000e-04, 2.000e-04, ..., 2.998e-01, 2.999e-01,\n       3.000e-01], shape=(3001,))}\n</code></pre> <p>and store the results:</p> <pre><code>default_1 = (discipline.time, discipline.local_data[\"y\"])\n</code></pre> <p>Then, we repeat the experiment until the final time:</p> <pre><code>discipline.set_next_execution(restart=False)\ndiscipline.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/pydantic/main.py:705: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'mass.m': array([1.]), 'spring.c': array([10000.]), 'y': array([-0.48946458, -0.48817871, -0.48689518, ..., -0.49567838,\n       -0.49564567, -0.49561344], shape=(7001,)), 'Mass_Damper_time': array([0.3   , 0.3001, 0.3002, ..., 0.9998, 0.9999, 1.    ], shape=(7001,))}\n</code></pre> <p>and store the results:</p> <pre><code>default_2 = (discipline.time, discipline.local_data[\"y\"])\n</code></pre> <p>Thirdly, we restart the discipline (default setting) and execute the discipline setting a simulation time of 0.3 seconds with custom input values:</p> <pre><code>discipline.set_next_execution(simulation_time=0.3)\ndiscipline.execute({\"mass.m\": 1.5, \"spring.c\": 1050.0})\n</code></pre> <p>Out:</p> <pre><code>{'mass.m': 1.5, 'spring.c': 1050.0, 'y': array([ 0.00000000e+00,  0.00000000e+00, -3.50000000e-06, ...,\n       -4.79620768e-01, -4.80116604e-01, -4.80612253e-01], shape=(3001,)), 'Mass_Damper_time': array([0.000e+00, 1.000e-04, 2.000e-04, ..., 2.998e-01, 2.999e-01,\n       3.000e-01], shape=(3001,))}\n</code></pre> <p>and store the results:</p> <pre><code>custom_1 = (discipline.time, discipline.local_data[\"y\"])\n</code></pre> <p>Then, we repeat the experiment until the final time with the same custom input values:</p> <pre><code>discipline.set_next_execution(restart=False)\ndiscipline.execute({\"mass.m\": 1.5, \"spring.c\": 1050.0})\n</code></pre> <p>Out:</p> <pre><code>{'mass.m': 1.5, 'spring.c': 1050.0, 'y': array([-0.48061225, -0.48110771, -0.48160297, ..., -0.48980401,\n       -0.48984827, -0.48989259], shape=(7001,)), 'Mass_Damper_time': array([0.3   , 0.3001, 0.3002, ..., 0.9998, 0.9999, 1.    ], shape=(7001,))}\n</code></pre> <p>and store the results:</p> <pre><code>custom_2 = (discipline.time, discipline.local_data[\"y\"])\n</code></pre> <p>Lastly, we use a chart to compare the default and custom results:</p> <pre><code>plt.plot(*default_1, label=\"Default 1/2\")\nplt.plot(*default_2, label=\"Default 2/2\")\nplt.plot(*custom_1, label=\"Custom 1/2\")\nplt.plot(*custom_2, label=\"Custom 2/2\")\nplt.xlabel(\"Time [s]\")\nplt.ylabel(\"Amplitude [m]\")\nplt.legend()\nplt.show()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  0.286 seconds)</p> <p> Download Python source code: plot_evaluation_time.py</p> <p> Download Jupyter notebook: plot_evaluation_time.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/disciplines/dynamic/plot_from_initial_time_to_final_time/","title":"From initial time to final time","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/disciplines/dynamic/plot_from_initial_time_to_final_time/#from-initial-time-to-final-time","title":"From initial time to final time","text":"<p>The most obvious use of the DynamicFMUDiscipline is to simulate an FMU model from an initial time to a final time in one go.</p> <pre><code>from __future__ import annotations\n\nfrom matplotlib import pyplot as plt\n\nfrom gemseo_fmu.disciplines.dynamic_fmu_discipline import DynamicFMUDiscipline\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\n</code></pre> <p>Let us create a discipline to simulate a mass damper defined in a FMU model from 0 to 1 second with a time step of 0.1 millisecond:</p> <p></p> <p>We only use the mass of the sliding mass [kg] and the spring constant [N/m] as inputs and the position of the mass [m] as output.</p> <pre><code>discipline = DynamicFMUDiscipline(\n    get_fmu_file_path(\"Mass_Damper\"),\n    [\"mass.m\", \"spring.c\"],\n    [\"y\"],\n    initial_time=0.0,\n    final_time=1.0,\n    time_step=0.0001,\n)\n</code></pre> <p>Firstly, we simulate the FMU with the default input values:</p> <pre><code>discipline.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/pydantic/main.py:705: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'mass.m': array([1.]), 'spring.c': array([10000.]), 'y': array([ 0.00000000e+00,  0.00000000e+00, -5.00000000e-05, ...,\n       -4.95678376e-01, -4.95645675e-01, -4.95613439e-01], shape=(10001,)), 'Mass_Damper_time': array([0.000e+00, 1.000e-04, 2.000e-04, ..., 9.998e-01, 9.999e-01,\n       1.000e+00], shape=(10001,))}\n</code></pre> <p>and store the time evolution of the position of the mass:</p> <pre><code>default_y_evolution = discipline.local_data[\"y\"]\n</code></pre> <p>Then, we repeat the experiment with custom values of the mass and spring constants:</p> <pre><code>discipline.execute({\"mass.m\": 1.5, \"spring.c\": 1050.0})\n</code></pre> <p>Out:</p> <pre><code>{'mass.m': 1.5, 'spring.c': 1050.0, 'y': array([ 0.00000000e+00,  0.00000000e+00, -3.50000000e-06, ...,\n       -4.89804005e-01, -4.89848274e-01, -4.89892585e-01], shape=(10001,)), 'Mass_Damper_time': array([0.000e+00, 1.000e-04, 2.000e-04, ..., 9.998e-01, 9.999e-01,\n       1.000e+00], shape=(10001,))}\n</code></pre> <p>Lastly, we use a chart to compare the positions of the mass:</p> <pre><code>plt.plot(discipline.time, default_y_evolution, label=\"Default\")\nplt.plot(discipline.time, discipline.local_data[\"y\"], label=\"Custom\")\nplt.xlabel(\"Time [s]\")\nplt.ylabel(\"Amplitude [m]\")\nplt.legend()\nplt.show()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  0.236 seconds)</p> <p> Download Python source code: plot_from_initial_time_to_final_time.py</p> <p> Download Jupyter notebook: plot_from_initial_time_to_final_time.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/disciplines/dynamic/plot_plot_time_evolution/","title":"Plot a time evolution","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/disciplines/dynamic/plot_plot_time_evolution/#plot-a-time-evolution","title":"Plot a time evolution","text":"<p>The time evolution of a discipline output can easily be plotted, using the FMUDiscipline.plot method.</p> <pre><code>from __future__ import annotations\n\nfrom gemseo_fmu.disciplines.dynamic_fmu_discipline import DynamicFMUDiscipline\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\n</code></pre> <p>Let us create a discipline to simulate a mass damper defined in an FMU model from 0 to 1 second with a time step of 0.1 milliseconds:</p> <p></p> <p>We only use the mass of the sliding mass [kg] and the spring constant [N/m] as inputs. The position of the mass [m] is used as output.</p> <pre><code>discipline = DynamicFMUDiscipline(\n    get_fmu_file_path(\"Mass_Damper\"),\n    [\"mass.m\", \"spring.c\"],\n    [\"y\"],\n    initial_time=0.0,\n    final_time=1.0,\n    time_step=0.0001,\n)\n</code></pre> <p>Firstly, we execute the discipline:</p> <pre><code>discipline.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/pydantic/main.py:705: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'mass.m': array([1.]), 'spring.c': array([10000.]), 'y': array([ 0.00000000e+00,  0.00000000e+00, -5.00000000e-05, ...,\n       -4.95678376e-01, -4.95645675e-01, -4.95613439e-01], shape=(10001,)), 'Mass_Damper_time': array([0.000e+00, 1.000e-04, 2.000e-04, ..., 9.998e-01, 9.999e-01,\n       1.000e+00], shape=(10001,))}\n</code></pre> <p>Then, we can easily access the local data, e.g the output <code>\"y\"</code>:</p> <pre><code>discipline.local_data[\"y\"]\n</code></pre> <p>Out:</p> <pre><code>array([ 0.00000000e+00,  0.00000000e+00, -5.00000000e-05, ...,\n       -4.95678376e-01, -4.95645675e-01, -4.95613439e-01], shape=(10001,))\n</code></pre> <p>But it is not very easy to read and plotting the time evolution of this variable is a better option:</p> <pre><code>discipline.plot(\"y\", save=False, show=True)\n</code></pre> <p></p> <p>Out:</p> <pre><code>&lt;gemseo.post.dataset.lines.Lines object at 0x7be43c180560&gt;\n</code></pre> <p>We can also restrict the view to a specific time window defined by the start time index:</p> <pre><code>discipline.plot(\"y\", time_window=3000, save=False, show=True)\n</code></pre> <p></p> <p>Out:</p> <pre><code>&lt;gemseo.post.dataset.lines.Lines object at 0x7be43c304710&gt;\n</code></pre> <p>or both the start and end time indices:</p> <pre><code>discipline.plot(\"y\", time_window=[3000, 7000], save=False, show=True)\n</code></pre> <p></p> <p>Out:</p> <pre><code>&lt;gemseo.post.dataset.lines.Lines object at 0x7be4396e4620&gt;\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.616 seconds)</p> <p> Download Python source code: plot_plot_time_evolution.py</p> <p> Download Jupyter notebook: plot_plot_time_evolution.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/disciplines/dynamic/plot_restart_false/","title":"Do not restart","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/disciplines/dynamic/plot_restart_false/#do-not-restart","title":"Do not restart","text":"<p>In some situations, we may want to configure the DynamicFMUDiscipline so that each execution starts where the previous one stopped.</p> <pre><code>from __future__ import annotations\n\nfrom matplotlib import pyplot as plt\n\nfrom gemseo_fmu.disciplines.dynamic_fmu_discipline import DynamicFMUDiscipline\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\n</code></pre> <p>Let us create a discipline to simulate a mass damper defined in an FMU model from 0 to 1 second with a time step of 0.1 milliseconds:</p> <p></p> <p>We only use the mass of the sliding mass [kg] and the spring constant [N/m] as inputs. The position of the mass [m] is used as output.</p> <pre><code>discipline = DynamicFMUDiscipline(\n    get_fmu_file_path(\"Mass_Damper\"),\n    [\"mass.m\", \"spring.c\"],\n    [\"y\"],\n    initial_time=0.0,\n    final_time=1.0,\n    time_step=0.0001,\n    restart=False,\n)\n</code></pre> <p>Note</p> <p>We had to set <code>restart</code> to <code>False</code> as the default behavior of the DynamicFMUDiscipline is to run each execution from the start time.</p> <p>Then, we execute the discipline setting a simulation time of 0.3 seconds with the default input values:</p> <pre><code>discipline.set_next_execution(simulation_time=0.3)\ndiscipline.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/pydantic/main.py:705: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'mass.m': array([1.]), 'spring.c': array([10000.]), 'y': array([ 0.00000000e+00,  0.00000000e+00, -5.00000000e-05, ...,\n       -4.92042818e-01, -4.90752654e-01, -4.89464576e-01], shape=(3001,)), 'Mass_Damper_time': array([0.000e+00, 1.000e-04, 2.000e-04, ..., 2.998e-01, 2.999e-01,\n       3.000e-01], shape=(3001,))}\n</code></pre> <p>and store the time evolution of the position of the mass:</p> <pre><code>time_evolution_1 = (discipline.time, discipline.local_data[\"y\"])\n</code></pre> <p>We repeat this experiment with custom input values:</p> <pre><code>discipline.set_next_execution(simulation_time=0.3)\ndiscipline.execute({\"mass.m\": 1.5, \"spring.c\": 1050.0})\n</code></pre> <p>Out:</p> <pre><code>{'mass.m': 1.5, 'spring.c': 1050.0, 'y': array([-0.48946458, -0.48817871, -0.48689378, ..., -0.31740528,\n       -0.31748476, -0.31756546], shape=(3001,)), 'Mass_Damper_time': array([0.3   , 0.3001, 0.3002, ..., 0.5998, 0.5999, 0.6   ], shape=(3001,))}\n</code></pre> <p>store the results:</p> <pre><code>time_evolution_2 = (discipline.time, discipline.local_data[\"y\"])\n</code></pre> <p>and execute the discipline until the final time:</p> <pre><code>discipline.execute()\ntime_evolution_3 = (discipline.time, discipline.local_data[\"y\"])\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/pydantic/main.py:705: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n</code></pre> <p>Lastly, we draw this trajectory on a chart:</p> <pre><code>plt.plot(*time_evolution_1, label=\"Default 1/3\")\nplt.plot(*time_evolution_2, label=\"Default 2/3\")\nplt.plot(*time_evolution_3, label=\"Default 3/3\")\nplt.xlabel(\"Time [s]\")\nplt.ylabel(\"Amplitude [m]\")\nplt.legend()\nplt.show()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  0.180 seconds)</p> <p> Download Python source code: plot_restart_false.py</p> <p> Download Jupyter notebook: plot_restart_false.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/disciplines/dynamic/plot_string_time/","title":"Time as a character string","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/disciplines/dynamic/plot_string_time/#time-as-a-character-string","title":"Time as a character string","text":"<p>Time information can often be specified either in seconds or as a string written in natural language, e.g. <code>\"2h 34m 1s\"</code> or <code>\"2 hours, 34 minutes and 1 second\"</code> (units include y, m, w, d, h, min, s, ms).</p> <pre><code>from __future__ import annotations\n\nfrom matplotlib import pyplot as plt\n\nfrom gemseo_fmu.disciplines.dynamic_fmu_discipline import DynamicFMUDiscipline\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\n</code></pre> <p>Let us create and use a discipline to simulate a mass damper defined in a FMU model from 0 to 1 second with a time step of 0.1 millisecond:</p> <p></p> <p>Here, we express the final time and time step in natural language with <code>\"1 second\"</code> and <code>\"0.1ms\"</code> instead of <code>1</code> and <code>0.0001</code>.</p> <pre><code>discipline = DynamicFMUDiscipline(\n    get_fmu_file_path(\"Mass_Damper\"),\n    [\"mass.m\", \"spring.c\"],\n    [\"y\"],\n    initial_time=0.0,\n    final_time=\"1 second\",\n    time_step=\"0.1ms\",\n)\ndiscipline.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/pydantic/main.py:705: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'mass.m': array([1.]), 'spring.c': array([10000.]), 'y': array([ 0.00000000e+00,  0.00000000e+00, -5.00000000e-05, ...,\n       -4.95678376e-01, -4.95645675e-01, -4.95613439e-01], shape=(10001,)), 'Mass_Damper_time': array([0.000e+00, 1.000e-04, 2.000e-04, ..., 9.998e-01, 9.999e-01,\n       1.000e+00], shape=(10001,))}\n</code></pre> <p>We can plot the time-evolution of the position of the mass:</p> <pre><code>plt.plot(discipline.time, discipline.local_data[\"y\"])\nplt.xlabel(\"Time [s]\")\nplt.ylabel(\"Amplitude [m]\")\nplt.show()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  0.166 seconds)</p> <p> Download Python source code: plot_string_time.py</p> <p> Download Jupyter notebook: plot_string_time.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/disciplines/dynamic/plot_time_function/","title":"Use time functions","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/disciplines/dynamic/plot_time_function/#use-time-functions","title":"Use time functions","text":"<p>The input variables with <code>input</code> causality as well as some input variables with <code>parameter</code> causality can be set with time functions.</p> <pre><code>from __future__ import annotations\n\nfrom matplotlib import pyplot as plt\n\nfrom gemseo_fmu.disciplines.dynamic_fmu_discipline import DynamicFMUDiscipline\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\n</code></pre> <p>Let us create a discipline to simulate a mass damper defined in a FMU model from 0 to 1 second with a time step of 0.1 millisecond:</p> <p></p> <p>We only use the mass of the sliding mass [kg] and the spring constant [N/m] as inputs and the position of the mass [m] as output.</p> <pre><code>discipline = DynamicFMUDiscipline(\n    get_fmu_file_path(\"Mass_Damper\"),\n    [\"mass.m\", \"spring.c\"],\n    [\"y\"],\n    initial_time=0.0,\n    final_time=1.0,\n    time_step=0.0001,\n)\n</code></pre> <p>Firstly, we simulate the FMU with the default input values, and in particular a constant value for the mass:</p> <pre><code>discipline.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/pydantic/main.py:705: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'mass.m': array([1.]), 'spring.c': array([10000.]), 'y': array([ 0.00000000e+00,  0.00000000e+00, -5.00000000e-05, ...,\n       -4.95678376e-01, -4.95645675e-01, -4.95613439e-01], shape=(10001,)), 'Mass_Damper_time': array([0.000e+00, 1.000e-04, 2.000e-04, ..., 9.998e-01, 9.999e-01,\n       1.000e+00], shape=(10001,))}\n</code></pre> <p>and store the time evolution of its position:</p> <pre><code>default_y_evolution = discipline.local_data[\"y\"]\ndefault_mass = discipline.local_data[\"mass.m\"]\n</code></pre> <p>Then, we repeat the experiment with a time linear function for the mass:</p> <pre><code>discipline.execute({\"mass.m\": lambda t: 4 - 3 * t})\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/pydantic/main.py:705: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'mass.m': array([4.    , 3.9997, 3.9994, ..., 1.0006, 1.0003, 1.    ],\n      shape=(10001,)), 'spring.c': array([10000.]), 'y': array([ 0.00000000e+00,  0.00000000e+00, -1.25000000e-05, ...,\n       -5.36841710e-01, -5.36575518e-01, -5.36305911e-01], shape=(10001,)), 'Mass_Damper_time': array([0.000e+00, 1.000e-04, 2.000e-04, ..., 9.998e-01, 9.999e-01,\n       1.000e+00], shape=(10001,))}\n</code></pre> <p>Lastly, we use a chart to compare the positions of the mass:</p> <pre><code>fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)\nax1.plot(discipline.time, default_y_evolution, label=\"Default\")\np = ax1.plot(discipline.time, discipline.local_data[\"y\"], label=\"Custom\")\nax1.set_ylabel(\"Amplitude [m]\")\nax1.legend()\nax2.axhline(default_mass, label=\"Default\")\nax2.plot(\n    discipline.time,\n    discipline.local_data[\"mass.m\"],\n    label=\"Custom\",\n    color=p[0].get_color(),\n)\nax2.set_ylabel(\"Mass [kg]\")\nplt.xlabel(\"Time [s]\")\nax2.legend()\nplt.show()\n</code></pre> <p></p> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/matplotlib/cbook.py:1719: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return math.isfinite(val)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.349 seconds)</p> <p> Download Python source code: plot_time_function.py</p> <p> Download Jupyter notebook: plot_time_function.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/disciplines/dynamic/plot_time_series/","title":"Use time series","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/disciplines/dynamic/plot_time_series/#use-time-series","title":"Use time series","text":"<p>The input variables with <code>input</code> causality as well as some input variables with <code>parameter</code> causality can be set with time series.</p> <pre><code>from __future__ import annotations\n\nfrom matplotlib import pyplot as plt\n\nfrom gemseo_fmu.disciplines.dynamic_fmu_discipline import DynamicFMUDiscipline\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\nfrom gemseo_fmu.utils.time_series import TimeSeries\n</code></pre> <p>Let us create a discipline to simulate a mass damper defined in a FMU model from 0 to 1 second with a time step of 0.1 millisecond:</p> <p></p> <p>We only use the mass of the sliding mass [kg] and the spring constant [N/m] as inputs and the position of the mass [m] as output.</p> <pre><code>discipline = DynamicFMUDiscipline(\n    get_fmu_file_path(\"Mass_Damper\"),\n    [\"mass.m\", \"spring.c\"],\n    [\"y\"],\n    initial_time=0.0,\n    final_time=1.0,\n    time_step=0.0001,\n)\n</code></pre> <p>Firstly, we simulate the FMU with the default input values, and in particular a constant value for the mass:</p> <pre><code>discipline.execute()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/pydantic/main.py:705: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'mass.m': array([1.]), 'spring.c': array([10000.]), 'y': array([ 0.00000000e+00,  0.00000000e+00, -5.00000000e-05, ...,\n       -4.95678376e-01, -4.95645675e-01, -4.95613439e-01], shape=(10001,)), 'Mass_Damper_time': array([0.000e+00, 1.000e-04, 2.000e-04, ..., 9.998e-01, 9.999e-01,\n       1.000e+00], shape=(10001,))}\n</code></pre> <p>and store the time evolution of both its position and the mass:</p> <pre><code>default_y_evolution = discipline.local_data[\"y\"]\ndefault_mass = discipline.local_data[\"mass.m\"]\n</code></pre> <p>Then, we repeat the experiment with a custom time series for the mass, characterized by a sharp change after 0.5 seconds.</p> <pre><code>time_series = TimeSeries(time=[0.0, 0.25, 0.5, 1.0], observable=[4.0, 2.0, 0.2, 0.1])\ndiscipline.execute({\"mass.m\": time_series})\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/pydantic/main.py:705: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'mass.m': array([4. , 4. , 4. , ..., 0.2, 0.2, 0.1], shape=(10001,)), 'spring.c': array([10000.]), 'y': array([ 0.00000000e+00,  0.00000000e+00, -1.25000000e-05, ...,\n       -5.00001066e-01, -5.00001049e-01, -5.00001032e-01], shape=(10001,)), 'Mass_Damper_time': array([0.000e+00, 1.000e-04, 2.000e-04, ..., 9.998e-01, 9.999e-01,\n       1.000e+00], shape=(10001,))}\n</code></pre> <p>Lastly, we use a chart to compare the positions of the mass:</p> <pre><code>fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)\nax1.plot(discipline.time, default_y_evolution, label=\"Default\")\np = ax1.plot(discipline.time, discipline.local_data[\"y\"], label=\"Custom\")\nax1.set_ylabel(\"Amplitude [m]\")\nax1.legend()\nax2.axhline(default_mass, label=\"Default\")\nax2.plot(\n    discipline.time,\n    discipline.local_data[\"mass.m\"],\n    label=\"Custom\",\n    color=p[0].get_color(),\n)\nax2.set_ylabel(\"Mass [kg]\")\nplt.xlabel(\"Time [s]\")\nax2.legend()\nplt.show()\n</code></pre> <p></p> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/matplotlib/cbook.py:1719: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return math.isfinite(val)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.356 seconds)</p> <p> Download Python source code: plot_time_series.py</p> <p> Download Jupyter notebook: plot_time_series.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/disciplines/static/mg_execution_times/","title":"Computation times","text":"<p>00:00.052 total execution time for generated_examples_disciplines_static files:</p> <p>+--------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_static_discipline (docs/examples/disciplines/static/plot_static_discipline.py) | 00:00.052 | 0.0 MB | +--------------------------------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/examples/disciplines/static/plot_static_discipline/","title":"Static discipline","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/disciplines/static/plot_static_discipline/#static-discipline","title":"Static discipline","text":"<p>The StaticFMUDiscipline can be used to simulate a time-independent FMU model.</p> <pre><code>from __future__ import annotations\n\nfrom gemseo_fmu.disciplines.static_fmu_discipline import StaticFMUDiscipline\nfrom gemseo_fmu.problems.fmu_files import get_fmu_file_path\n</code></pre> <p>Let us create a discipline based on an FMU model computing the output \\(y\\) from the inputs \\(u_1\\) and \\(u_2\\) as \\(y=f(u_1,u_2)=k_1u_1+k_2u_2\\):</p> <pre><code>discipline = StaticFMUDiscipline(get_fmu_file_path(\"add\"))\n</code></pre> <p>We can have a look to the default inputs:</p> <pre><code>discipline.default_input_data\n</code></pre> <p>Out:</p> <pre><code>{'u1': array([0.]), 'u2': array([0.]), 'add.k1': array([1.]), 'add.k2': array([1.])}\n</code></pre> <p>and see that they are equal to zero. We can also see that \\(k_1\\) and \\(k_2\\) are discipline inputs in the same way as \\(u_1\\) and \\(u_2\\). However, their causality is parameter while the causality of \\(u_1\\) and \\(u_2\\) is input:</p> <pre><code>discipline.causalities_to_variable_names\n</code></pre> <p>Out:</p> <pre><code>{'input': ['u1', 'u2'], 'output': ['y'], 'parameter': ['add.k1', 'add.k2'], 'local': ['add.u1', 'add.u2', 'add.y']}\n</code></pre> <p>Then, we can execute the discipline with the default input values</p> <pre><code>discipline.execute()\ndiscipline.get_output_data()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/pydantic/main.py:705: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'y': array([0.])}\n</code></pre> <p>and check that the output is equal to 0 as expected. Then, we can execute this discipline with new input values:</p> <pre><code>discipline.execute({\"u1\": 2.0, \"u2\": 3.0})\ndiscipline.get_output_data()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/pydantic/main.py:705: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'y': array([5.])}\n</code></pre> <p>and check that the output is equal to 5 as expected. Lastly, we can also change the values of the inputs with parameter causality:</p> <pre><code>discipline.execute({\"u1\": 2.0, \"u2\": 3.0, \"add.k1\": 4.0})\ndiscipline.get_output_data()\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-fmu/.tox/doc/lib64/python3.12/site-packages/pydantic/main.py:705: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  return cls.__pydantic_validator__.validate_python(\n\n{'y': array([11.])}\n</code></pre> <p>The output is equal to 11 as expected.</p> <p>Total running time of the script: ( 0 minutes  0.052 seconds)</p> <p> Download Python source code: plot_static_discipline.py</p> <p> Download Jupyter notebook: plot_static_discipline.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>gemseo_fmu<ul> <li>disciplines<ul> <li>base_fmu_discipline</li> <li>do_step_fmu_discipline</li> <li>dynamic_fmu_discipline</li> <li>fmu_discipline</li> <li>static_fmu_discipline</li> <li>time_series</li> <li>time_stepping_system</li> </ul> </li> <li>problems<ul> <li>fmu_files</li> </ul> </li> <li>utils<ul> <li>time_duration</li> <li>time_manager</li> <li>time_series</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/gemseo_fmu/","title":"API documentation","text":""},{"location":"reference/gemseo_fmu/#gemseo_fmu","title":"gemseo_fmu","text":"<p>Entry point to gemseo fmu.</p>"},{"location":"reference/gemseo_fmu/disciplines/","title":"Disciplines","text":""},{"location":"reference/gemseo_fmu/disciplines/#gemseo_fmu.disciplines","title":"disciplines","text":"<p>Features to create a discipline from an FMU file.</p>"},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/","title":"Base fmu discipline","text":""},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline","title":"base_fmu_discipline","text":"<p>A base discipline wrapping a Functional Mockup Unit (FMU) model.</p>"},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline.BaseFMUDiscipline","title":"BaseFMUDiscipline","text":"<pre><code>BaseFMUDiscipline(\n    file_path: str | Path,\n    input_names: Iterable[str] | None = (),\n    output_names: Iterable[str] = (),\n    initial_time: TimeDurationType | None = None,\n    final_time: TimeDurationType | None = None,\n    time_step: TimeDurationType = 0.0,\n    time_name: str = \"time\",\n    add_time_to_output_grammar: bool = True,\n    restart: bool = True,\n    do_step: bool = False,\n    name: str = \"\",\n    use_co_simulation: bool = True,\n    solver_name: Solver = CVODE,\n    model_instance_directory: str | Path = \"\",\n    delete_model_instance_directory: bool = True,\n    variable_names: Mapping[\n        str, str\n    ] = READ_ONLY_EMPTY_DICT,\n    validate: bool = True,\n    **pre_instantiation_parameters: Any\n)\n</code></pre> <p>               Bases: <code>Discipline</code></p> <p>A base discipline wrapping a Functional Mockup Unit (FMU) model.</p> <p>This discipline relies on FMPy.</p> <p>Initialize self.  See help(type(self)) for accurate signature.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>               (<code>str | Path</code>)           \u2013            <p>The path to the FMU model file.</p> </li> <li> <code>input_names</code>               (<code>Iterable[str] | None</code>, default:                   <code>()</code> )           \u2013            <p>The names of the FMU model inputs; if empty, use all the inputs and parameters of the FMU model; if <code>None</code>, do not use inputs.</p> </li> <li> <code>output_names</code>               (<code>Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>The names of the FMU model outputs. if empty, use all the outputs of the FMU model.</p> </li> <li> <code>initial_time</code>               (<code>TimeDurationType | None</code>, default:                   <code>None</code> )           \u2013            <p>The initial time of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code>, use the start time defined in the FMU model if any; otherwise use 0.</p> </li> <li> <code>final_time</code>               (<code>TimeDurationType | None</code>, default:                   <code>None</code> )           \u2013            <p>The final time of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code>, use the stop time defined in the FMU model if any; otherwise use the initial time.</p> </li> <li> <code>time_step</code>               (<code>TimeDurationType</code>, default:                   <code>0.0</code> )           \u2013            <p>The time step of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>0.</code>, use the stop time defined in the FMU model if any; otherwise use <code>0.</code>.</p> </li> <li> <code>time_name</code>               (<code>str</code>, default:                   <code>'time'</code> )           \u2013            <p>The name of the time variable in the FMU model.</p> </li> <li> <code>add_time_to_output_grammar</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the time is added to the output grammar.</p> </li> <li> <code>restart</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the model is restarted at <code>initial_time</code> after execution.</p> </li> <li> <code>do_step</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the model is simulated over only one <code>time_step</code> when calling execute(). Otherwise, simulate the model from current time to final time in one go.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The name of the discipline. If empty, use the name of the class.</p> </li> <li> <code>use_co_simulation</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the co-simulation FMI type is used. Otherwise, use model-exchange FMI type. When <code>do_step</code> is <code>True</code>, the co-simulation FMI type is required.</p> </li> <li> <code>solver_name</code>               (<code>Solver</code>, default:                   <code>CVODE</code> )           \u2013            <p>The name of the solver to simulate a model-exchange model.</p> </li> <li> <code>model_instance_directory</code>               (<code>str | Path</code>, default:                   <code>''</code> )           \u2013            <p>The directory of the FMU instance, containing the files extracted from the FMU model file; if empty, let <code>fmpy</code> create a temporary directory.</p> </li> <li> <code>delete_model_instance_directory</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to delete the directory of the FMU instance when deleting the discipline.</p> </li> <li> <code>variable_names</code>               (<code>Mapping[str, str]</code>, default:                   <code>READ_ONLY_EMPTY_DICT</code> )           \u2013            <p>The names of the discipline inputs and outputs associated with the names of the FMU model inputs and outputs, passed as <code>{fmu_model_variable_name: discipline_variable_name, ...}</code>. When missing, use the names of the FMU model inputs and outputs.</p> </li> <li> <code>validate</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the FMU file must be checked.</p> </li> <li> <code>**pre_instantiation_parameters</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>The parameters to be passed to <code>_pre_instantiate()</code>.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def __init__(\n    self,\n    file_path: str | Path,\n    input_names: Iterable[str] | None = (),\n    output_names: Iterable[str] = (),\n    initial_time: TimeDurationType | None = None,\n    final_time: TimeDurationType | None = None,\n    time_step: TimeDurationType = 0.0,\n    time_name: str = \"time\",\n    add_time_to_output_grammar: bool = True,\n    restart: bool = True,\n    do_step: bool = False,\n    name: str = \"\",\n    use_co_simulation: bool = True,\n    solver_name: Solver = Solver.CVODE,\n    model_instance_directory: str | Path = \"\",\n    delete_model_instance_directory: bool = True,\n    variable_names: Mapping[str, str] = READ_ONLY_EMPTY_DICT,\n    validate: bool = True,\n    **pre_instantiation_parameters: Any,\n) -&gt; None:\n    \"\"\"\n    Args:\n        file_path: The path to the FMU model file.\n        input_names: The names of the FMU model inputs;\n            if empty, use all the inputs and parameters of the FMU model;\n            if `None`, do not use inputs.\n        output_names: The names of the FMU model outputs.\n            if empty, use all the outputs of the FMU model.\n        initial_time: The initial time of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None`, use the start time defined in the FMU model if any;\n            otherwise use 0.\n        final_time: The final time of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None`, use the stop time defined in the FMU model if any;\n            otherwise use the initial time.\n        time_step: The time step of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `0.`, use the stop time defined in the FMU model if any;\n            otherwise use `0.`.\n        time_name: The name of the time variable in the FMU model.\n        add_time_to_output_grammar: Whether the time is added to the output grammar.\n        restart: Whether the model is restarted at `initial_time` after execution.\n        do_step: Whether the model is simulated over only one `time_step`\n            when calling\n            [execute()][gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.execute].\n            Otherwise, simulate the model from current time to final time in one go.\n        use_co_simulation: Whether the co-simulation FMI type is used.\n            Otherwise, use model-exchange FMI type.\n            When `do_step` is `True`, the co-simulation FMI type is required.\n        solver_name: The name of the solver to simulate a model-exchange model.\n        model_instance_directory: The directory of the FMU instance,\n            containing the files extracted from the FMU model file;\n            if empty, let `fmpy` create a temporary directory.\n        delete_model_instance_directory: Whether to delete the directory\n            of the FMU instance when deleting the discipline.\n        variable_names: The names of the discipline inputs and outputs\n            associated with the names of the FMU model inputs and outputs,\n            passed as `{fmu_model_variable_name: discipline_variable_name, ...}`.\n            When missing, use the names of the FMU model inputs and outputs.\n        validate: Whether the FMU file must be checked.\n        **pre_instantiation_parameters: The parameters to be passed\n            to `_pre_instantiate()`.\n    \"\"\"  # noqa: D205 D212 D415\n    self.__delete_model_instance_directory = delete_model_instance_directory\n    self.__executed = False\n    self.__names_to_time_functions = {}\n    self.__solver_name = str(solver_name)\n    self.__names_to_sizes = {}\n    self.name = self.__set_fmu_model(\n        file_path,\n        validate,\n        model_instance_directory,\n        do_step,\n        use_co_simulation,\n        name,\n    )\n    self.__from_fmu_names = dict(variable_names)\n    self.__to_fmu_names = {v: k for k, v in variable_names.items()}\n    self.__time_name = f\"{self.name}_{time_name}\"\n    self.__time_name_in_fmu = time_name\n    self.__from_fmu_names[self.__time_name_in_fmu] = self.__time_name\n    self.__to_fmu_names[self.__time_name] = self.__time_name_in_fmu\n    input_names, output_names = (\n        self.__set_variable_names_references_and_causalities(\n            input_names, output_names\n        )\n    )\n    self.__set_initial_values()\n    self.__set_time(initial_time, final_time, time_step, do_step, restart)\n    self._pre_instantiate(**(pre_instantiation_parameters or {}))\n    super().__init__(name=self.name)\n\n    self.io.input_grammar.update_from_types(\n        dict.fromkeys(\n            input_names, Union[bool, int, float, str, NDArrayPydantic, TimeSeries]\n        )\n    )\n    self.io.output_grammar.update_from_names(output_names)\n    self.__define_getters_and_setters()\n    if add_time_to_output_grammar:\n        self.io.output_grammar.update_from_types({\n            self.__time_name: Union[float, NDArrayPydantic[float]]\n        })\n\n    self.default_input_data = {\n        input_name: self._initial_values[input_name] for input_name in input_names\n    }\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline.BaseFMUDiscipline-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline.BaseFMUDiscipline.causalities_to_variable_names","title":"causalities_to_variable_names  <code>property</code>","text":"<pre><code>causalities_to_variable_names: dict[str, list[str]]\n</code></pre> <p>The names of the variables sorted by causality.</p>"},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline.BaseFMUDiscipline.model","title":"model  <code>property</code>","text":"<pre><code>model: FMUModel\n</code></pre> <p>The FMU model.</p>"},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline.BaseFMUDiscipline.model_description","title":"model_description  <code>property</code>","text":"<pre><code>model_description: ModelDescription\n</code></pre> <p>The description of the FMU model.</p>"},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline.BaseFMUDiscipline-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline.BaseFMUDiscipline.Solver","title":"Solver","text":"<p>               Bases: <code>StrEnum</code></p> <p>The solver to simulate a model-exchange model.</p>"},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline.BaseFMUDiscipline-functions","title":"Functions","text":""},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline.BaseFMUDiscipline.execute","title":"execute","text":"<pre><code>execute(\n    input_data: Mapping[\n        str,\n        ndarray\n        | TimeSeries\n        | Callable[[TimeDurationType], float],\n    ] = MappingProxyType({}),\n) -&gt; DisciplineData\n</code></pre> <p>Execute the discipline, i.e. compute output data from input data.</p> <p>If :attr:<code>.virtual_execution</code> is <code>True</code>, this method returns the :attr:<code>.default_output_data</code>. Otherwise, it calls the :meth:<code>._run</code> method performing the true execution and returns the corresponding output data. This :meth:<code>._run</code> method must be implemented in subclasses.</p> <p>Parameters:</p> <ul> <li> <code>input_data</code>               (<code>Mapping[str, ndarray | TimeSeries | Callable[[TimeDurationType], float]]</code>, default:                   <code>MappingProxyType({})</code> )           \u2013            <p>The input data. Complete this dictionary with the :attr:<code>.default_input_data</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DisciplineData</code>           \u2013            <p>The input and output data.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def execute(  # noqa:D102\n    self,\n    input_data: Mapping[\n        str, ndarray | TimeSeries | Callable[[TimeDurationType], float]\n    ] = MappingProxyType({}),\n) -&gt; DisciplineData:\n    self.__executed = True\n    if self.__default_simulation_settings.use_arrays_only:\n        return super().execute(input_data)\n\n    full_input_data = self.io.prepare_input_data(input_data)\n    current_time = self.__time_manager.current\n    names_to_time_functions = self.__names_to_time_functions = {}\n    for name, value in full_input_data.items():\n        cls = value.__class__\n        if issubclass(cls, TimeSeries):\n            names_to_time_functions[name] = value.compute\n            full_input_data[name] = array([value.observable[0]])\n        elif issubclass(cls, Callable):\n            names_to_time_functions[name] = value\n            full_input_data[name] = array([value(current_time)])\n\n    return super().execute(full_input_data)\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline.BaseFMUDiscipline.set_default_execution","title":"set_default_execution","text":"<pre><code>set_default_execution(\n    do_step: bool | None = None,\n    final_time: TimeDurationType | None = None,\n    restart: bool | None = None,\n    time_step: TimeDurationType | None = None,\n    initialize_only: bool = False,\n    use_arrays_only: bool = False,\n) -&gt; None\n</code></pre> <p>Change the default simulation settings.</p> <p>Parameters:</p> <ul> <li> <code>do_step</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the model is simulated over only one <code>time_step</code> when calling execute(). Otherwise, simulate the model from current time to final time in one go. If <code>None</code>, use the value considered at the instantiation.</p> </li> <li> <code>final_time</code>               (<code>TimeDurationType | None</code>, default:                   <code>None</code> )           \u2013            <p>The final time of the simulation; either a number in seconds or a string of characters (see TimeDuration); If <code>None</code>, use the value considered at the instantiation.</p> </li> <li> <code>restart</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to restart the model at <code>initial_time</code> before executing it; if <code>None</code>, use the value passed at the instantiation.</p> </li> <li> <code>time_step</code>               (<code>TimeDurationType | None</code>, default:                   <code>None</code> )           \u2013            <p>The time step of the simulation; either a number in seconds or a string of characters (see TimeDuration); If <code>None</code>, use the value considered at the instantiation.</p> </li> <li> <code>initialize_only</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the model simply needs to be initialized (no time integration).</p> </li> <li> <code>use_arrays_only</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use array data only.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def set_default_execution(\n    self,\n    do_step: bool | None = None,\n    final_time: TimeDurationType | None = None,\n    restart: bool | None = None,\n    time_step: TimeDurationType | None = None,\n    initialize_only: bool = False,\n    use_arrays_only: bool = False,\n) -&gt; None:\n    \"\"\"Change the default simulation settings.\n\n    Args:\n        do_step: Whether the model is simulated over only one `time_step`\n            when calling\n            [execute()][gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.execute].\n            Otherwise, simulate the model from current time to final time in one go.\n            If `None`, use the value considered at the instantiation.\n        final_time: The final time of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            If `None`, use the value considered at the instantiation.\n        restart: Whether to restart the model at `initial_time`\n            before executing it;\n            if `None`, use the value passed at the instantiation.\n        time_step: The time step of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            If `None`, use the value considered at the instantiation.\n        initialize_only: Whether the model simply needs to be initialized\n            (no time integration).\n        use_arrays_only: Whether to use array data only.\n    \"\"\"\n    if do_step is not None:\n        self.__do_step = do_step\n\n    if restart is not None:\n        self.__default_simulation_settings.restart = restart\n\n    if final_time is not None:\n        self.__set_final_time(final_time)\n\n    if time_step is not None:\n        time_step = TimeDuration(time_step).seconds\n        self.__default_simulation_settings.time_step = time_step\n\n    self.__default_simulation_settings.initialize_only = initialize_only\n    self.__default_simulation_settings.use_arrays_only = use_arrays_only\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/base_fmu_discipline/#gemseo_fmu.disciplines.base_fmu_discipline.BaseFMUDiscipline.set_next_execution","title":"set_next_execution","text":"<pre><code>set_next_execution(\n    restart: bool | None = None,\n    simulation_time: TimeDurationType | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None\n</code></pre> <p>Change the simulation settings for the execution.</p> <p>Parameters:</p> <ul> <li> <code>restart</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to restart the model at <code>initial_time</code> before executing it; if <code>None</code>, use the value passed at the instantiation.</p> </li> <li> <code>simulation_time</code>               (<code>TimeDurationType | None</code>, default:                   <code>None</code> )           \u2013            <p>The duration of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code> and the <code>do_step</code> passed at instantiation is <code>False</code>, execute until the final time; if <code>None</code> and the <code>do_step</code> passed at instantiation is <code>True</code>, execute during a single time step.</p> </li> <li> <code>time_step</code>               (<code>TimeDurationType | None</code>, default:                   <code>None</code> )           \u2013            <p>The time step of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code>, use the value passed at the instantiation.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def set_next_execution(\n    self,\n    restart: bool | None = None,\n    simulation_time: TimeDurationType | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None:\n    \"\"\"Change the simulation settings for the execution.\n\n    Args:\n        restart: Whether to restart the model at `initial_time`\n            before executing it;\n            if `None`, use the value passed at the instantiation.\n        simulation_time: The duration of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None` and the `do_step` passed at instantiation is `False`,\n            execute until the final time;\n            if `None` and the `do_step` passed at instantiation is `True`,\n            execute during a single time step.\n        time_step: The time step of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None`, use the value passed at the instantiation.\n    \"\"\"  # noqa: D205 D212 D415\n    if self.__simulation_settings is None:\n        self.__simulation_settings = copy(self.__default_simulation_settings)\n\n    if time_step is not None:\n        self.__simulation_settings.time_step = TimeDuration(time_step).seconds\n\n    if restart is not None:\n        self.__simulation_settings.restart = restart\n\n    if simulation_time is not None:\n        simulation_time = TimeDuration(simulation_time).seconds\n        self.__simulation_settings.simulation_time = simulation_time\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/","title":"Do step fmu discipline","text":""},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline","title":"do_step_fmu_discipline","text":"<p>An FMU discipline whose execution simulates only one time step.</p>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline","title":"DoStepFMUDiscipline","text":"<pre><code>DoStepFMUDiscipline(\n    file_path: str | Path,\n    input_names: Iterable[str] | None = (),\n    output_names: Iterable[str] = (),\n    initial_time: TimeType | None = None,\n    final_time: TimeType | None = None,\n    time_step: TimeType = 0.0,\n    add_time_to_output_grammar: bool = True,\n    restart: bool = False,\n    name: str = \"\",\n    solver_name: Solver = CVODE,\n    fmu_instance_directory: str | Path = \"\",\n    delete_fmu_instance_directory: bool = True,\n    variable_names: Mapping[\n        str, str\n    ] = READ_ONLY_EMPTY_DICT,\n    validate: bool = True,\n    **pre_instantiation_parameters: Any\n)\n</code></pre> <p>               Bases: <code>FMUDiscipline</code></p> <p>An FMU discipline whose execution simulates only one time step.</p> Notes <p>The time series are interpolated at the time steps resulting from the union of their respective time steps. Then, between two time steps, the time series for the variables of causality \"input\" are linearly interpolated at the integration time steps while for the variables of causality \"parameter\", the time series are considered as constant.</p> <p>Initialize self.  See help(type(self)) for accurate signature.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>               (<code>str | Path</code>)           \u2013            <p>The path to the FMU model file.</p> </li> <li> <code>input_names</code>               (<code>Iterable[str] | None</code>, default:                   <code>()</code> )           \u2013            <p>The names of the FMU model inputs; if empty, use all the inputs and parameters of the FMU model; if <code>None</code>, do not use inputs.</p> </li> <li> <code>output_names</code>               (<code>Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>The names of the FMU model outputs. if empty, use all the outputs of the FMU model.</p> </li> <li> <code>initial_time</code>               (<code>TimeType | None</code>, default:                   <code>None</code> )           \u2013            <p>The initial time of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code>, use the start time defined in the FMU model if any; otherwise use 0.</p> </li> <li> <code>final_time</code>               (<code>TimeType | None</code>, default:                   <code>None</code> )           \u2013            <p>The final time of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code>, use the stop time defined in the FMU model if any; otherwise use the initial time.</p> </li> <li> <code>time_step</code>               (<code>TimeType</code>, default:                   <code>0.0</code> )           \u2013            <p>The time step of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>0.</code>, use the stop time defined in the FMU model if any; otherwise use <code>0.</code>.</p> </li> <li> <code>add_time_to_output_grammar</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the time is added to the output grammar.</p> </li> <li> <code>restart</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the model is restarted at <code>initial_time</code> after execution.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The name of the discipline. If empty, use the name of the class.</p> </li> <li> <code>solver_name</code>               (<code>Solver</code>, default:                   <code>CVODE</code> )           \u2013            <p>The name of the solver to simulate a model-exchange model.</p> </li> <li> <code>fmu_instance_directory</code>               (<code>str | Path</code>, default:                   <code>''</code> )           \u2013            <p>The description is missing.</p> </li> <li> <code>delete_fmu_instance_directory</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>The description is missing.</p> </li> <li> <code>variable_names</code>               (<code>Mapping[str, str]</code>, default:                   <code>READ_ONLY_EMPTY_DICT</code> )           \u2013            <p>The names of the discipline inputs and outputs associated with the names of the FMU model inputs and outputs, passed as <code>{fmu_model_variable_name: discipline_variable_name, ...}</code>. When missing, use the names of the FMU model inputs and outputs.</p> </li> <li> <code>validate</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the FMU file must be checked.</p> </li> <li> <code>**pre_instantiation_parameters</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>The parameters to be passed to <code>_pre_instantiate()</code>.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/do_step_fmu_discipline.py</code> <pre><code>def __init__(  # noqa: D107\n    self,\n    file_path: str | Path,\n    input_names: Iterable[str] | None = (),\n    output_names: Iterable[str] = (),\n    initial_time: TimeType | None = None,\n    final_time: TimeType | None = None,\n    time_step: TimeType = 0.0,\n    add_time_to_output_grammar: bool = True,\n    restart: bool = False,\n    name: str = \"\",\n    solver_name: FMUDiscipline.Solver = FMUDiscipline.Solver.CVODE,\n    fmu_instance_directory: str | Path = \"\",\n    delete_fmu_instance_directory: bool = True,\n    variable_names: Mapping[str, str] = READ_ONLY_EMPTY_DICT,\n    validate: bool = True,\n    **pre_instantiation_parameters: Any,\n) -&gt; None:\n    do_step = pre_instantiation_parameters.get(self._DO_STEP, None)\n    if do_step is False:\n        msg = \"DoStepFMUDiscipline has no do_step parameter.\"\n        raise ValueError(msg)\n\n    if do_step is True:\n        del pre_instantiation_parameters[self._DO_STEP]\n\n    super().__init__(\n        file_path,\n        input_names=input_names,\n        output_names=output_names,\n        initial_time=initial_time,\n        final_time=final_time,\n        time_step=time_step,\n        add_time_to_output_grammar=add_time_to_output_grammar,\n        restart=restart,\n        do_step=True,\n        name=name,\n        use_co_simulation=True,\n        solver_name=solver_name,\n        fmu_instance_directory=fmu_instance_directory,\n        delete_fmu_instance_directory=delete_fmu_instance_directory,\n        variable_names=variable_names,\n        validate=validate,\n        **pre_instantiation_parameters,\n    )\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline.causalities_to_variable_names","title":"causalities_to_variable_names  <code>property</code>","text":"<pre><code>causalities_to_variable_names: dict[str, list[str]]\n</code></pre> <p>The names of the variables sorted by causality.</p>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline.initial_values","title":"initial_values  <code>property</code>","text":"<pre><code>initial_values: dict[str, NumberArray]\n</code></pre> <p>The initial input, output and time values.</p>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline.model","title":"model  <code>property</code>","text":"<pre><code>model: FMUModel\n</code></pre> <p>The FMU model.</p>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline.model_description","title":"model_description  <code>property</code>","text":"<pre><code>model_description: ModelDescription\n</code></pre> <p>The description of the FMU model.</p>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline.time","title":"time  <code>property</code>","text":"<pre><code>time: RealArray | None\n</code></pre> <p>The time steps of the last execution if any.</p>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline.Solver","title":"Solver","text":"<p>               Bases: <code>StrEnum</code></p> <p>The solver to simulate a model-exchange model.</p>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline-functions","title":"Functions","text":""},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline.execute","title":"execute","text":"<pre><code>execute(\n    input_data: Mapping[\n        str,\n        ndarray\n        | TimeSeries\n        | Callable[[TimeDurationType], float],\n    ] = MappingProxyType({}),\n) -&gt; DisciplineData\n</code></pre> <p>Execute the discipline, i.e. compute output data from input data.</p> <p>If :attr:<code>.virtual_execution</code> is <code>True</code>, this method returns the :attr:<code>.default_output_data</code>. Otherwise, it calls the :meth:<code>._run</code> method performing the true execution and returns the corresponding output data. This :meth:<code>._run</code> method must be implemented in subclasses.</p> <p>Parameters:</p> <ul> <li> <code>input_data</code>               (<code>Mapping[str, ndarray | TimeSeries | Callable[[TimeDurationType], float]]</code>, default:                   <code>MappingProxyType({})</code> )           \u2013            <p>The input data. Complete this dictionary with the :attr:<code>.default_input_data</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DisciplineData</code>           \u2013            <p>The input and output data.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def execute(  # noqa:D102\n    self,\n    input_data: Mapping[\n        str, ndarray | TimeSeries | Callable[[TimeDurationType], float]\n    ] = MappingProxyType({}),\n) -&gt; DisciplineData:\n    self.__executed = True\n    if self.__default_simulation_settings.use_arrays_only:\n        return super().execute(input_data)\n\n    full_input_data = self.io.prepare_input_data(input_data)\n    current_time = self.__time_manager.current\n    names_to_time_functions = self.__names_to_time_functions = {}\n    for name, value in full_input_data.items():\n        cls = value.__class__\n        if issubclass(cls, TimeSeries):\n            names_to_time_functions[name] = value.compute\n            full_input_data[name] = array([value.observable[0]])\n        elif issubclass(cls, Callable):\n            names_to_time_functions[name] = value\n            full_input_data[name] = array([value(current_time)])\n\n    return super().execute(full_input_data)\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline.plot","title":"plot","text":"<pre><code>plot(\n    output_names: str | Iterable[str],\n    abscissa_name: str = \"\",\n    time_unit: TimeUnit = SECONDS,\n    time_window: int | Sequence[int] = 0,\n    save: bool = True,\n    show: bool = False,\n    file_path: str | Path = \"\",\n) -&gt; Lines\n</code></pre> <p>Plot the time evolution of output variables.</p> <p>Parameters:</p> <ul> <li> <code>output_names</code>               (<code>str | Iterable[str]</code>)           \u2013            <p>The name(s) of the output variable(s).</p> </li> <li> <code>abscissa_name</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The name of the variable to be plotted on the x-axis. If empty, use the time variable.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnit</code>, default:                   <code>SECONDS</code> )           \u2013            <p>The unit to express the time.</p> </li> <li> <code>time_window</code>               (<code>int | Sequence[int]</code>, default:                   <code>0</code> )           \u2013            <p>The time windows over which to draw the time evolution. Either the start time index (the end one will be the final time one) or both the start and end time indices.</p> </li> <li> <code>save</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to save the figure.</p> </li> <li> <code>show</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to show the figure.</p> </li> <li> <code>file_path</code>               (<code>str | Path</code>, default:                   <code>''</code> )           \u2013            <p>The path of the file to save the figure. The directory path and file format are deduced from it. If empty, save the file in the current directory, with the output name as file name and PNG format.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Lines</code>           \u2013            <p>The figure.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/fmu_discipline.py</code> <pre><code>def plot(\n    self,\n    output_names: str | Iterable[str],\n    abscissa_name: str = \"\",\n    time_unit: TimeUnit = TimeUnit.SECONDS,\n    time_window: int | Sequence[int] = 0,\n    save: bool = True,\n    show: bool = False,\n    file_path: str | Path = \"\",\n) -&gt; Lines:\n    \"\"\"Plot the time evolution of output variables.\n\n    Args:\n        output_names: The name(s) of the output variable(s).\n        abscissa_name: The name of the variable to be plotted on the x-axis.\n            If empty, use the time variable.\n        time_unit: The unit to express the time.\n        time_window: The time windows over which to draw the time evolution.\n            Either the start time index (the end one will be the final time one)\n            or both the start and end time indices.\n        save: Whether to save the figure.\n        show: Whether to show the figure.\n        file_path: The path of the file to save the figure.\n            The directory path and file format are deduced from it.\n            If empty,\n            save the file in the current directory,\n            with the output name as file name and PNG format.\n\n    Returns:\n        The figure.\n    \"\"\"\n    if isinstance(output_names, str):\n        output_names = [output_names]\n\n    time_name = f\"Time ({time_unit})\"\n    if not abscissa_name:\n        abscissa_name = time_name\n\n    if isinstance(time_window, int):\n        time_window = (time_window, self.time.size)\n\n    dataset = Dataset()\n    time_window = slice(*time_window)\n    time_duration = TimeDuration(self.time[time_window, newaxis])\n    dataset.add_variable(time_name, time_duration.to(time_unit))\n    for name in set(output_names).union({abscissa_name}) - {time_name}:\n        dataset.add_variable(name, self.io.data[name][time_window, newaxis])\n\n    figure = Lines(dataset, output_names, abscissa_variable=abscissa_name)\n    figure.execute(save=save, show=show, file_path=file_path)\n    return figure\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline.set_default_execution","title":"set_default_execution","text":"<pre><code>set_default_execution(\n    final_time: TimeDurationType | None = None,\n    restart: bool | None = None,\n    time_step: TimeDurationType | None = None,\n    initialize_only: bool = False,\n    use_arrays_only: bool = False,\n) -&gt; None\n</code></pre> <p>Change the default simulation settings.</p> <p>Parameters:</p> <ul> <li> <code>final_time</code>               (<code>TimeDurationType | None</code>, default:                   <code>None</code> )           \u2013            <p>The final time of the simulation; either a number in seconds or a string of characters (see TimeDuration); If <code>None</code>, use the value considered at the instantiation.</p> </li> <li> <code>restart</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to restart the model at <code>initial_time</code> before executing it; if <code>None</code>, use the value passed at the instantiation.</p> </li> <li> <code>time_step</code>               (<code>TimeDurationType | None</code>, default:                   <code>None</code> )           \u2013            <p>The time step of the simulation; either a number in seconds or a string of characters (see TimeDuration); If <code>None</code>, use the value considered at the instantiation.</p> </li> <li> <code>initialize_only</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the model simply needs to be initialized (no time integration).</p> </li> <li> <code>use_arrays_only</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use array data only.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/do_step_fmu_discipline.py</code> <pre><code>def set_default_execution(  # noqa: D102\n    self,\n    final_time: TimeDurationType | None = None,\n    restart: bool | None = None,\n    time_step: TimeDurationType | None = None,\n    initialize_only: bool = False,\n    use_arrays_only: bool = False,\n) -&gt; None:\n    super().set_default_execution(\n        do_step=True,\n        final_time=final_time,\n        restart=restart,\n        time_step=time_step,\n        initialize_only=initialize_only,\n        use_arrays_only=use_arrays_only,\n    )\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/do_step_fmu_discipline/#gemseo_fmu.disciplines.do_step_fmu_discipline.DoStepFMUDiscipline.set_next_execution","title":"set_next_execution","text":"<pre><code>set_next_execution(\n    restart: bool | None = None,\n    simulation_time: TimeDurationType | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None\n</code></pre> <p>Change the simulation settings for the execution.</p> <p>Parameters:</p> <ul> <li> <code>restart</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to restart the model at <code>initial_time</code> before executing it; if <code>None</code>, use the value passed at the instantiation.</p> </li> <li> <code>simulation_time</code>               (<code>TimeDurationType | None</code>, default:                   <code>None</code> )           \u2013            <p>The duration of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code> and the <code>do_step</code> passed at instantiation is <code>False</code>, execute until the final time; if <code>None</code> and the <code>do_step</code> passed at instantiation is <code>True</code>, execute during a single time step.</p> </li> <li> <code>time_step</code>               (<code>TimeDurationType | None</code>, default:                   <code>None</code> )           \u2013            <p>The time step of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code>, use the value passed at the instantiation.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def set_next_execution(\n    self,\n    restart: bool | None = None,\n    simulation_time: TimeDurationType | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None:\n    \"\"\"Change the simulation settings for the execution.\n\n    Args:\n        restart: Whether to restart the model at `initial_time`\n            before executing it;\n            if `None`, use the value passed at the instantiation.\n        simulation_time: The duration of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None` and the `do_step` passed at instantiation is `False`,\n            execute until the final time;\n            if `None` and the `do_step` passed at instantiation is `True`,\n            execute during a single time step.\n        time_step: The time step of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None`, use the value passed at the instantiation.\n    \"\"\"  # noqa: D205 D212 D415\n    if self.__simulation_settings is None:\n        self.__simulation_settings = copy(self.__default_simulation_settings)\n\n    if time_step is not None:\n        self.__simulation_settings.time_step = TimeDuration(time_step).seconds\n\n    if restart is not None:\n        self.__simulation_settings.restart = restart\n\n    if simulation_time is not None:\n        simulation_time = TimeDuration(simulation_time).seconds\n        self.__simulation_settings.simulation_time = simulation_time\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/dynamic_fmu_discipline/","title":"Dynamic fmu discipline","text":""},{"location":"reference/gemseo_fmu/disciplines/dynamic_fmu_discipline/#gemseo_fmu.disciplines.dynamic_fmu_discipline","title":"dynamic_fmu_discipline","text":"<p>A dynamic discipline wrapping a Functional Mockup Unit (FMU) model.</p>"},{"location":"reference/gemseo_fmu/disciplines/dynamic_fmu_discipline/#gemseo_fmu.disciplines.dynamic_fmu_discipline-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/","title":"Fmu discipline","text":""},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline","title":"fmu_discipline","text":"<p>A dynamic discipline wrapping a Functional Mockup Unit (FMU) model.</p>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline","title":"FMUDiscipline","text":"<pre><code>FMUDiscipline(\n    file_path: str | Path,\n    input_names: Iterable[str] | None = (),\n    output_names: Iterable[str] = (),\n    initial_time: TimeDurationType | None = None,\n    final_time: TimeDurationType | None = None,\n    time_step: TimeDurationType = 0.0,\n    time_name: str = \"time\",\n    add_time_to_output_grammar: bool = True,\n    restart: bool = True,\n    do_step: bool = False,\n    name: str = \"\",\n    use_co_simulation: bool = True,\n    solver_name: Solver = CVODE,\n    model_instance_directory: str | Path = \"\",\n    delete_model_instance_directory: bool = True,\n    variable_names: Mapping[\n        str, str\n    ] = READ_ONLY_EMPTY_DICT,\n    validate: bool = True,\n    **pre_instantiation_parameters: Any\n)\n</code></pre> <p>               Bases: <code>BaseFMUDiscipline</code></p> <p>A dynamic discipline wrapping a Functional Mockup Unit (FMU) model.</p> <p>This discipline relies on FMPy.</p> Notes <p>The time series are interpolated at the time steps resulting from the union of their respective time steps. Then, between two time steps, the time series for the variables of causality \"input\" are linearly interpolated at the integration time steps while for the variables of causality \"parameter\", the time series are considered as constant.</p> <p>Initialize self.  See help(type(self)) for accurate signature.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>               (<code>str | Path</code>)           \u2013            <p>The path to the FMU model file.</p> </li> <li> <code>input_names</code>               (<code>Iterable[str] | None</code>, default:                   <code>()</code> )           \u2013            <p>The names of the FMU model inputs; if empty, use all the inputs and parameters of the FMU model; if <code>None</code>, do not use inputs.</p> </li> <li> <code>output_names</code>               (<code>Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>The names of the FMU model outputs. if empty, use all the outputs of the FMU model.</p> </li> <li> <code>initial_time</code>               (<code>TimeDurationType | None</code>, default:                   <code>None</code> )           \u2013            <p>The initial time of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code>, use the start time defined in the FMU model if any; otherwise use 0.</p> </li> <li> <code>final_time</code>               (<code>TimeDurationType | None</code>, default:                   <code>None</code> )           \u2013            <p>The final time of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code>, use the stop time defined in the FMU model if any; otherwise use the initial time.</p> </li> <li> <code>time_step</code>               (<code>TimeDurationType</code>, default:                   <code>0.0</code> )           \u2013            <p>The time step of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>0.</code>, use the stop time defined in the FMU model if any; otherwise use <code>0.</code>.</p> </li> <li> <code>time_name</code>               (<code>str</code>, default:                   <code>'time'</code> )           \u2013            <p>The name of the time variable in the FMU model.</p> </li> <li> <code>add_time_to_output_grammar</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the time is added to the output grammar.</p> </li> <li> <code>restart</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the model is restarted at <code>initial_time</code> after execution.</p> </li> <li> <code>do_step</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the model is simulated over only one <code>time_step</code> when calling execute(). Otherwise, simulate the model from current time to final time in one go.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The name of the discipline. If empty, use the name of the class.</p> </li> <li> <code>use_co_simulation</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the co-simulation FMI type is used. Otherwise, use model-exchange FMI type. When <code>do_step</code> is <code>True</code>, the co-simulation FMI type is required.</p> </li> <li> <code>solver_name</code>               (<code>Solver</code>, default:                   <code>CVODE</code> )           \u2013            <p>The name of the solver to simulate a model-exchange model.</p> </li> <li> <code>model_instance_directory</code>               (<code>str | Path</code>, default:                   <code>''</code> )           \u2013            <p>The directory of the FMU instance, containing the files extracted from the FMU model file; if empty, let <code>fmpy</code> create a temporary directory.</p> </li> <li> <code>delete_model_instance_directory</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to delete the directory of the FMU instance when deleting the discipline.</p> </li> <li> <code>variable_names</code>               (<code>Mapping[str, str]</code>, default:                   <code>READ_ONLY_EMPTY_DICT</code> )           \u2013            <p>The names of the discipline inputs and outputs associated with the names of the FMU model inputs and outputs, passed as <code>{fmu_model_variable_name: discipline_variable_name, ...}</code>. When missing, use the names of the FMU model inputs and outputs.</p> </li> <li> <code>validate</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the FMU file must be checked.</p> </li> <li> <code>**pre_instantiation_parameters</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>The parameters to be passed to <code>_pre_instantiate()</code>.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def __init__(\n    self,\n    file_path: str | Path,\n    input_names: Iterable[str] | None = (),\n    output_names: Iterable[str] = (),\n    initial_time: TimeDurationType | None = None,\n    final_time: TimeDurationType | None = None,\n    time_step: TimeDurationType = 0.0,\n    time_name: str = \"time\",\n    add_time_to_output_grammar: bool = True,\n    restart: bool = True,\n    do_step: bool = False,\n    name: str = \"\",\n    use_co_simulation: bool = True,\n    solver_name: Solver = Solver.CVODE,\n    model_instance_directory: str | Path = \"\",\n    delete_model_instance_directory: bool = True,\n    variable_names: Mapping[str, str] = READ_ONLY_EMPTY_DICT,\n    validate: bool = True,\n    **pre_instantiation_parameters: Any,\n) -&gt; None:\n    \"\"\"\n    Args:\n        file_path: The path to the FMU model file.\n        input_names: The names of the FMU model inputs;\n            if empty, use all the inputs and parameters of the FMU model;\n            if `None`, do not use inputs.\n        output_names: The names of the FMU model outputs.\n            if empty, use all the outputs of the FMU model.\n        initial_time: The initial time of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None`, use the start time defined in the FMU model if any;\n            otherwise use 0.\n        final_time: The final time of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None`, use the stop time defined in the FMU model if any;\n            otherwise use the initial time.\n        time_step: The time step of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `0.`, use the stop time defined in the FMU model if any;\n            otherwise use `0.`.\n        time_name: The name of the time variable in the FMU model.\n        add_time_to_output_grammar: Whether the time is added to the output grammar.\n        restart: Whether the model is restarted at `initial_time` after execution.\n        do_step: Whether the model is simulated over only one `time_step`\n            when calling\n            [execute()][gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.execute].\n            Otherwise, simulate the model from current time to final time in one go.\n        use_co_simulation: Whether the co-simulation FMI type is used.\n            Otherwise, use model-exchange FMI type.\n            When `do_step` is `True`, the co-simulation FMI type is required.\n        solver_name: The name of the solver to simulate a model-exchange model.\n        model_instance_directory: The directory of the FMU instance,\n            containing the files extracted from the FMU model file;\n            if empty, let `fmpy` create a temporary directory.\n        delete_model_instance_directory: Whether to delete the directory\n            of the FMU instance when deleting the discipline.\n        variable_names: The names of the discipline inputs and outputs\n            associated with the names of the FMU model inputs and outputs,\n            passed as `{fmu_model_variable_name: discipline_variable_name, ...}`.\n            When missing, use the names of the FMU model inputs and outputs.\n        validate: Whether the FMU file must be checked.\n        **pre_instantiation_parameters: The parameters to be passed\n            to `_pre_instantiate()`.\n    \"\"\"  # noqa: D205 D212 D415\n    self.__delete_model_instance_directory = delete_model_instance_directory\n    self.__executed = False\n    self.__names_to_time_functions = {}\n    self.__solver_name = str(solver_name)\n    self.__names_to_sizes = {}\n    self.name = self.__set_fmu_model(\n        file_path,\n        validate,\n        model_instance_directory,\n        do_step,\n        use_co_simulation,\n        name,\n    )\n    self.__from_fmu_names = dict(variable_names)\n    self.__to_fmu_names = {v: k for k, v in variable_names.items()}\n    self.__time_name = f\"{self.name}_{time_name}\"\n    self.__time_name_in_fmu = time_name\n    self.__from_fmu_names[self.__time_name_in_fmu] = self.__time_name\n    self.__to_fmu_names[self.__time_name] = self.__time_name_in_fmu\n    input_names, output_names = (\n        self.__set_variable_names_references_and_causalities(\n            input_names, output_names\n        )\n    )\n    self.__set_initial_values()\n    self.__set_time(initial_time, final_time, time_step, do_step, restart)\n    self._pre_instantiate(**(pre_instantiation_parameters or {}))\n    super().__init__(name=self.name)\n\n    self.io.input_grammar.update_from_types(\n        dict.fromkeys(\n            input_names, Union[bool, int, float, str, NDArrayPydantic, TimeSeries]\n        )\n    )\n    self.io.output_grammar.update_from_names(output_names)\n    self.__define_getters_and_setters()\n    if add_time_to_output_grammar:\n        self.io.output_grammar.update_from_types({\n            self.__time_name: Union[float, NDArrayPydantic[float]]\n        })\n\n    self.default_input_data = {\n        input_name: self._initial_values[input_name] for input_name in input_names\n    }\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.causalities_to_variable_names","title":"causalities_to_variable_names  <code>property</code>","text":"<pre><code>causalities_to_variable_names: dict[str, list[str]]\n</code></pre> <p>The names of the variables sorted by causality.</p>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.initial_values","title":"initial_values  <code>property</code>","text":"<pre><code>initial_values: dict[str, NumberArray]\n</code></pre> <p>The initial input, output and time values.</p>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.model","title":"model  <code>property</code>","text":"<pre><code>model: FMUModel\n</code></pre> <p>The FMU model.</p>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.model_description","title":"model_description  <code>property</code>","text":"<pre><code>model_description: ModelDescription\n</code></pre> <p>The description of the FMU model.</p>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.time","title":"time  <code>property</code>","text":"<pre><code>time: RealArray | None\n</code></pre> <p>The time steps of the last execution if any.</p>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.Solver","title":"Solver","text":"<p>               Bases: <code>StrEnum</code></p> <p>The solver to simulate a model-exchange model.</p>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline-functions","title":"Functions","text":""},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.execute","title":"execute","text":"<pre><code>execute(\n    input_data: Mapping[\n        str,\n        ndarray\n        | TimeSeries\n        | Callable[[TimeDurationType], float],\n    ] = MappingProxyType({}),\n) -&gt; DisciplineData\n</code></pre> <p>Execute the discipline, i.e. compute output data from input data.</p> <p>If :attr:<code>.virtual_execution</code> is <code>True</code>, this method returns the :attr:<code>.default_output_data</code>. Otherwise, it calls the :meth:<code>._run</code> method performing the true execution and returns the corresponding output data. This :meth:<code>._run</code> method must be implemented in subclasses.</p> <p>Parameters:</p> <ul> <li> <code>input_data</code>               (<code>Mapping[str, ndarray | TimeSeries | Callable[[TimeDurationType], float]]</code>, default:                   <code>MappingProxyType({})</code> )           \u2013            <p>The input data. Complete this dictionary with the :attr:<code>.default_input_data</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DisciplineData</code>           \u2013            <p>The input and output data.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def execute(  # noqa:D102\n    self,\n    input_data: Mapping[\n        str, ndarray | TimeSeries | Callable[[TimeDurationType], float]\n    ] = MappingProxyType({}),\n) -&gt; DisciplineData:\n    self.__executed = True\n    if self.__default_simulation_settings.use_arrays_only:\n        return super().execute(input_data)\n\n    full_input_data = self.io.prepare_input_data(input_data)\n    current_time = self.__time_manager.current\n    names_to_time_functions = self.__names_to_time_functions = {}\n    for name, value in full_input_data.items():\n        cls = value.__class__\n        if issubclass(cls, TimeSeries):\n            names_to_time_functions[name] = value.compute\n            full_input_data[name] = array([value.observable[0]])\n        elif issubclass(cls, Callable):\n            names_to_time_functions[name] = value\n            full_input_data[name] = array([value(current_time)])\n\n    return super().execute(full_input_data)\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.plot","title":"plot","text":"<pre><code>plot(\n    output_names: str | Iterable[str],\n    abscissa_name: str = \"\",\n    time_unit: TimeUnit = SECONDS,\n    time_window: int | Sequence[int] = 0,\n    save: bool = True,\n    show: bool = False,\n    file_path: str | Path = \"\",\n) -&gt; Lines\n</code></pre> <p>Plot the time evolution of output variables.</p> <p>Parameters:</p> <ul> <li> <code>output_names</code>               (<code>str | Iterable[str]</code>)           \u2013            <p>The name(s) of the output variable(s).</p> </li> <li> <code>abscissa_name</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The name of the variable to be plotted on the x-axis. If empty, use the time variable.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnit</code>, default:                   <code>SECONDS</code> )           \u2013            <p>The unit to express the time.</p> </li> <li> <code>time_window</code>               (<code>int | Sequence[int]</code>, default:                   <code>0</code> )           \u2013            <p>The time windows over which to draw the time evolution. Either the start time index (the end one will be the final time one) or both the start and end time indices.</p> </li> <li> <code>save</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to save the figure.</p> </li> <li> <code>show</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to show the figure.</p> </li> <li> <code>file_path</code>               (<code>str | Path</code>, default:                   <code>''</code> )           \u2013            <p>The path of the file to save the figure. The directory path and file format are deduced from it. If empty, save the file in the current directory, with the output name as file name and PNG format.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Lines</code>           \u2013            <p>The figure.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/fmu_discipline.py</code> <pre><code>def plot(\n    self,\n    output_names: str | Iterable[str],\n    abscissa_name: str = \"\",\n    time_unit: TimeUnit = TimeUnit.SECONDS,\n    time_window: int | Sequence[int] = 0,\n    save: bool = True,\n    show: bool = False,\n    file_path: str | Path = \"\",\n) -&gt; Lines:\n    \"\"\"Plot the time evolution of output variables.\n\n    Args:\n        output_names: The name(s) of the output variable(s).\n        abscissa_name: The name of the variable to be plotted on the x-axis.\n            If empty, use the time variable.\n        time_unit: The unit to express the time.\n        time_window: The time windows over which to draw the time evolution.\n            Either the start time index (the end one will be the final time one)\n            or both the start and end time indices.\n        save: Whether to save the figure.\n        show: Whether to show the figure.\n        file_path: The path of the file to save the figure.\n            The directory path and file format are deduced from it.\n            If empty,\n            save the file in the current directory,\n            with the output name as file name and PNG format.\n\n    Returns:\n        The figure.\n    \"\"\"\n    if isinstance(output_names, str):\n        output_names = [output_names]\n\n    time_name = f\"Time ({time_unit})\"\n    if not abscissa_name:\n        abscissa_name = time_name\n\n    if isinstance(time_window, int):\n        time_window = (time_window, self.time.size)\n\n    dataset = Dataset()\n    time_window = slice(*time_window)\n    time_duration = TimeDuration(self.time[time_window, newaxis])\n    dataset.add_variable(time_name, time_duration.to(time_unit))\n    for name in set(output_names).union({abscissa_name}) - {time_name}:\n        dataset.add_variable(name, self.io.data[name][time_window, newaxis])\n\n    figure = Lines(dataset, output_names, abscissa_variable=abscissa_name)\n    figure.execute(save=save, show=show, file_path=file_path)\n    return figure\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.set_default_execution","title":"set_default_execution","text":"<pre><code>set_default_execution(\n    do_step: bool | None = None,\n    final_time: TimeDurationType | None = None,\n    restart: bool | None = None,\n    time_step: TimeDurationType | None = None,\n    initialize_only: bool = False,\n    use_arrays_only: bool = False,\n) -&gt; None\n</code></pre> <p>Change the default simulation settings.</p> <p>Parameters:</p> <ul> <li> <code>do_step</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the model is simulated over only one <code>time_step</code> when calling execute(). Otherwise, simulate the model from current time to final time in one go. If <code>None</code>, use the value considered at the instantiation.</p> </li> <li> <code>final_time</code>               (<code>TimeDurationType | None</code>, default:                   <code>None</code> )           \u2013            <p>The final time of the simulation; either a number in seconds or a string of characters (see TimeDuration); If <code>None</code>, use the value considered at the instantiation.</p> </li> <li> <code>restart</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to restart the model at <code>initial_time</code> before executing it; if <code>None</code>, use the value passed at the instantiation.</p> </li> <li> <code>time_step</code>               (<code>TimeDurationType | None</code>, default:                   <code>None</code> )           \u2013            <p>The time step of the simulation; either a number in seconds or a string of characters (see TimeDuration); If <code>None</code>, use the value considered at the instantiation.</p> </li> <li> <code>initialize_only</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the model simply needs to be initialized (no time integration).</p> </li> <li> <code>use_arrays_only</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use array data only.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def set_default_execution(\n    self,\n    do_step: bool | None = None,\n    final_time: TimeDurationType | None = None,\n    restart: bool | None = None,\n    time_step: TimeDurationType | None = None,\n    initialize_only: bool = False,\n    use_arrays_only: bool = False,\n) -&gt; None:\n    \"\"\"Change the default simulation settings.\n\n    Args:\n        do_step: Whether the model is simulated over only one `time_step`\n            when calling\n            [execute()][gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.execute].\n            Otherwise, simulate the model from current time to final time in one go.\n            If `None`, use the value considered at the instantiation.\n        final_time: The final time of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            If `None`, use the value considered at the instantiation.\n        restart: Whether to restart the model at `initial_time`\n            before executing it;\n            if `None`, use the value passed at the instantiation.\n        time_step: The time step of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            If `None`, use the value considered at the instantiation.\n        initialize_only: Whether the model simply needs to be initialized\n            (no time integration).\n        use_arrays_only: Whether to use array data only.\n    \"\"\"\n    if do_step is not None:\n        self.__do_step = do_step\n\n    if restart is not None:\n        self.__default_simulation_settings.restart = restart\n\n    if final_time is not None:\n        self.__set_final_time(final_time)\n\n    if time_step is not None:\n        time_step = TimeDuration(time_step).seconds\n        self.__default_simulation_settings.time_step = time_step\n\n    self.__default_simulation_settings.initialize_only = initialize_only\n    self.__default_simulation_settings.use_arrays_only = use_arrays_only\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/fmu_discipline/#gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.set_next_execution","title":"set_next_execution","text":"<pre><code>set_next_execution(\n    restart: bool | None = None,\n    simulation_time: TimeDurationType | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None\n</code></pre> <p>Change the simulation settings for the execution.</p> <p>Parameters:</p> <ul> <li> <code>restart</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to restart the model at <code>initial_time</code> before executing it; if <code>None</code>, use the value passed at the instantiation.</p> </li> <li> <code>simulation_time</code>               (<code>TimeDurationType | None</code>, default:                   <code>None</code> )           \u2013            <p>The duration of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code> and the <code>do_step</code> passed at instantiation is <code>False</code>, execute until the final time; if <code>None</code> and the <code>do_step</code> passed at instantiation is <code>True</code>, execute during a single time step.</p> </li> <li> <code>time_step</code>               (<code>TimeDurationType | None</code>, default:                   <code>None</code> )           \u2013            <p>The time step of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code>, use the value passed at the instantiation.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def set_next_execution(\n    self,\n    restart: bool | None = None,\n    simulation_time: TimeDurationType | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None:\n    \"\"\"Change the simulation settings for the execution.\n\n    Args:\n        restart: Whether to restart the model at `initial_time`\n            before executing it;\n            if `None`, use the value passed at the instantiation.\n        simulation_time: The duration of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None` and the `do_step` passed at instantiation is `False`,\n            execute until the final time;\n            if `None` and the `do_step` passed at instantiation is `True`,\n            execute during a single time step.\n        time_step: The time step of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None`, use the value passed at the instantiation.\n    \"\"\"  # noqa: D205 D212 D415\n    if self.__simulation_settings is None:\n        self.__simulation_settings = copy(self.__default_simulation_settings)\n\n    if time_step is not None:\n        self.__simulation_settings.time_step = TimeDuration(time_step).seconds\n\n    if restart is not None:\n        self.__simulation_settings.restart = restart\n\n    if simulation_time is not None:\n        simulation_time = TimeDuration(simulation_time).seconds\n        self.__simulation_settings.simulation_time = simulation_time\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/","title":"Static fmu discipline","text":""},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline","title":"static_fmu_discipline","text":"<p>A static discipline wrapping a Functional Mockup Unit (FMU) model.</p>"},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline.StaticFMUDiscipline","title":"StaticFMUDiscipline","text":"<pre><code>StaticFMUDiscipline(\n    file_path: str | Path,\n    input_names: Iterable[str] | None = (),\n    output_names: Iterable[str] = (),\n    name: str = \"\",\n    use_co_simulation: bool = True,\n    model_instance_directory: str | Path = \"\",\n    delete_model_instance_directory: bool = True,\n    variable_names: Mapping[\n        str, str\n    ] = READ_ONLY_EMPTY_DICT,\n    validate: bool = True,\n    **pre_instantiation_parameters: Any\n)\n</code></pre> <p>               Bases: <code>BaseFMUDiscipline</code></p> <p>A static discipline wrapping a Functional Mockup Unit (FMU) model.</p> <p>This discipline relies on FMPy.</p> <p>Initialize self.  See help(type(self)) for accurate signature.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>               (<code>str | Path</code>)           \u2013            <p>The path to the FMU model file.</p> </li> <li> <code>input_names</code>               (<code>Iterable[str] | None</code>, default:                   <code>()</code> )           \u2013            <p>The names of the FMU model inputs; if empty, use all the inputs and parameters of the FMU model; if <code>None</code>, do not use inputs.</p> </li> <li> <code>output_names</code>               (<code>Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>The names of the FMU model outputs. if empty, use all the outputs of the FMU model.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The name of the discipline. If empty, use the name of the class.</p> </li> <li> <code>use_co_simulation</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the co-simulation FMI type is used. Otherwise, use model-exchange FMI type. When <code>do_step</code> is <code>True</code>, the co-simulation FMI type is required.</p> </li> <li> <code>model_instance_directory</code>               (<code>str | Path</code>, default:                   <code>''</code> )           \u2013            <p>The directory of the FMU instance, containing the files extracted from the FMU model file; if empty, let <code>fmpy</code> create a temporary directory.</p> </li> <li> <code>delete_model_instance_directory</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to delete the directory of the FMU instance when deleting the discipline.</p> </li> <li> <code>variable_names</code>               (<code>Mapping[str, str]</code>, default:                   <code>READ_ONLY_EMPTY_DICT</code> )           \u2013            <p>The names of the discipline inputs and outputs associated with the names of the FMU model inputs and outputs, passed as <code>{fmu_model_variable_name: discipline_variable_name, ...}</code>. When missing, use the names of the FMU model inputs and outputs.</p> </li> <li> <code>validate</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the FMU file must be checked.</p> </li> <li> <code>**pre_instantiation_parameters</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>The parameters to be passed to <code>_pre_instantiate()</code>.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/static_fmu_discipline.py</code> <pre><code>def __init__(  # noqa: D107\n    self,\n    file_path: str | Path,\n    input_names: Iterable[str] | None = (),\n    output_names: Iterable[str] = (),\n    name: str = \"\",\n    use_co_simulation: bool = True,\n    model_instance_directory: str | Path = \"\",\n    delete_model_instance_directory: bool = True,\n    variable_names: Mapping[str, str] = READ_ONLY_EMPTY_DICT,\n    validate: bool = True,\n    **pre_instantiation_parameters: Any,\n) -&gt; None:\n    super().__init__(\n        file_path=file_path,\n        input_names=input_names,\n        output_names=output_names,\n        name=name,\n        use_co_simulation=use_co_simulation,\n        model_instance_directory=model_instance_directory,\n        delete_model_instance_directory=delete_model_instance_directory,\n        do_step=True,\n        add_time_to_output_grammar=False,\n        variable_names=variable_names,\n        validate=validate,\n        **pre_instantiation_parameters,\n    )\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline.StaticFMUDiscipline-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline.StaticFMUDiscipline.causalities_to_variable_names","title":"causalities_to_variable_names  <code>property</code>","text":"<pre><code>causalities_to_variable_names: dict[str, list[str]]\n</code></pre> <p>The names of the variables sorted by causality.</p>"},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline.StaticFMUDiscipline.model","title":"model  <code>property</code>","text":"<pre><code>model: FMUModel\n</code></pre> <p>The FMU model.</p>"},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline.StaticFMUDiscipline.model_description","title":"model_description  <code>property</code>","text":"<pre><code>model_description: ModelDescription\n</code></pre> <p>The description of the FMU model.</p>"},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline.StaticFMUDiscipline-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline.StaticFMUDiscipline.Solver","title":"Solver","text":"<p>               Bases: <code>StrEnum</code></p> <p>The solver to simulate a model-exchange model.</p>"},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline.StaticFMUDiscipline-functions","title":"Functions","text":""},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline.StaticFMUDiscipline.execute","title":"execute","text":"<pre><code>execute(\n    input_data: Mapping[\n        str,\n        ndarray\n        | TimeSeries\n        | Callable[[TimeDurationType], float],\n    ] = MappingProxyType({}),\n) -&gt; DisciplineData\n</code></pre> <p>Execute the discipline, i.e. compute output data from input data.</p> <p>If :attr:<code>.virtual_execution</code> is <code>True</code>, this method returns the :attr:<code>.default_output_data</code>. Otherwise, it calls the :meth:<code>._run</code> method performing the true execution and returns the corresponding output data. This :meth:<code>._run</code> method must be implemented in subclasses.</p> <p>Parameters:</p> <ul> <li> <code>input_data</code>               (<code>Mapping[str, ndarray | TimeSeries | Callable[[TimeDurationType], float]]</code>, default:                   <code>MappingProxyType({})</code> )           \u2013            <p>The input data. Complete this dictionary with the :attr:<code>.default_input_data</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DisciplineData</code>           \u2013            <p>The input and output data.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def execute(  # noqa:D102\n    self,\n    input_data: Mapping[\n        str, ndarray | TimeSeries | Callable[[TimeDurationType], float]\n    ] = MappingProxyType({}),\n) -&gt; DisciplineData:\n    self.__executed = True\n    if self.__default_simulation_settings.use_arrays_only:\n        return super().execute(input_data)\n\n    full_input_data = self.io.prepare_input_data(input_data)\n    current_time = self.__time_manager.current\n    names_to_time_functions = self.__names_to_time_functions = {}\n    for name, value in full_input_data.items():\n        cls = value.__class__\n        if issubclass(cls, TimeSeries):\n            names_to_time_functions[name] = value.compute\n            full_input_data[name] = array([value.observable[0]])\n        elif issubclass(cls, Callable):\n            names_to_time_functions[name] = value\n            full_input_data[name] = array([value(current_time)])\n\n    return super().execute(full_input_data)\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline.StaticFMUDiscipline.set_default_execution","title":"set_default_execution","text":"<pre><code>set_default_execution(\n    do_step: bool | None = None,\n    final_time: TimeDurationType | None = None,\n    restart: bool | None = None,\n    time_step: TimeDurationType | None = None,\n    initialize_only: bool = False,\n    use_arrays_only: bool = False,\n) -&gt; None\n</code></pre> <p>Change the default simulation settings.</p> <p>Parameters:</p> <ul> <li> <code>do_step</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the model is simulated over only one <code>time_step</code> when calling execute(). Otherwise, simulate the model from current time to final time in one go. If <code>None</code>, use the value considered at the instantiation.</p> </li> <li> <code>final_time</code>               (<code>TimeDurationType | None</code>, default:                   <code>None</code> )           \u2013            <p>The final time of the simulation; either a number in seconds or a string of characters (see TimeDuration); If <code>None</code>, use the value considered at the instantiation.</p> </li> <li> <code>restart</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to restart the model at <code>initial_time</code> before executing it; if <code>None</code>, use the value passed at the instantiation.</p> </li> <li> <code>time_step</code>               (<code>TimeDurationType | None</code>, default:                   <code>None</code> )           \u2013            <p>The time step of the simulation; either a number in seconds or a string of characters (see TimeDuration); If <code>None</code>, use the value considered at the instantiation.</p> </li> <li> <code>initialize_only</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the model simply needs to be initialized (no time integration).</p> </li> <li> <code>use_arrays_only</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use array data only.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def set_default_execution(\n    self,\n    do_step: bool | None = None,\n    final_time: TimeDurationType | None = None,\n    restart: bool | None = None,\n    time_step: TimeDurationType | None = None,\n    initialize_only: bool = False,\n    use_arrays_only: bool = False,\n) -&gt; None:\n    \"\"\"Change the default simulation settings.\n\n    Args:\n        do_step: Whether the model is simulated over only one `time_step`\n            when calling\n            [execute()][gemseo_fmu.disciplines.fmu_discipline.FMUDiscipline.execute].\n            Otherwise, simulate the model from current time to final time in one go.\n            If `None`, use the value considered at the instantiation.\n        final_time: The final time of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            If `None`, use the value considered at the instantiation.\n        restart: Whether to restart the model at `initial_time`\n            before executing it;\n            if `None`, use the value passed at the instantiation.\n        time_step: The time step of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            If `None`, use the value considered at the instantiation.\n        initialize_only: Whether the model simply needs to be initialized\n            (no time integration).\n        use_arrays_only: Whether to use array data only.\n    \"\"\"\n    if do_step is not None:\n        self.__do_step = do_step\n\n    if restart is not None:\n        self.__default_simulation_settings.restart = restart\n\n    if final_time is not None:\n        self.__set_final_time(final_time)\n\n    if time_step is not None:\n        time_step = TimeDuration(time_step).seconds\n        self.__default_simulation_settings.time_step = time_step\n\n    self.__default_simulation_settings.initialize_only = initialize_only\n    self.__default_simulation_settings.use_arrays_only = use_arrays_only\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/static_fmu_discipline/#gemseo_fmu.disciplines.static_fmu_discipline.StaticFMUDiscipline.set_next_execution","title":"set_next_execution","text":"<pre><code>set_next_execution(\n    restart: bool | None = None,\n    simulation_time: TimeDurationType | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None\n</code></pre> <p>Change the simulation settings for the execution.</p> <p>Parameters:</p> <ul> <li> <code>restart</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to restart the model at <code>initial_time</code> before executing it; if <code>None</code>, use the value passed at the instantiation.</p> </li> <li> <code>simulation_time</code>               (<code>TimeDurationType | None</code>, default:                   <code>None</code> )           \u2013            <p>The duration of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code> and the <code>do_step</code> passed at instantiation is <code>False</code>, execute until the final time; if <code>None</code> and the <code>do_step</code> passed at instantiation is <code>True</code>, execute during a single time step.</p> </li> <li> <code>time_step</code>               (<code>TimeDurationType | None</code>, default:                   <code>None</code> )           \u2013            <p>The time step of the simulation; either a number in seconds or a string of characters (see TimeDuration); if <code>None</code>, use the value passed at the instantiation.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/base_fmu_discipline.py</code> <pre><code>def set_next_execution(\n    self,\n    restart: bool | None = None,\n    simulation_time: TimeDurationType | None = None,\n    time_step: TimeDurationType | None = None,\n) -&gt; None:\n    \"\"\"Change the simulation settings for the execution.\n\n    Args:\n        restart: Whether to restart the model at `initial_time`\n            before executing it;\n            if `None`, use the value passed at the instantiation.\n        simulation_time: The duration of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None` and the `do_step` passed at instantiation is `False`,\n            execute until the final time;\n            if `None` and the `do_step` passed at instantiation is `True`,\n            execute during a single time step.\n        time_step: The time step of the simulation;\n            either a number in seconds or a string of characters\n            (see [TimeDuration][gemseo_fmu.utils.time_duration.TimeDuration]);\n            if `None`, use the value passed at the instantiation.\n    \"\"\"  # noqa: D205 D212 D415\n    if self.__simulation_settings is None:\n        self.__simulation_settings = copy(self.__default_simulation_settings)\n\n    if time_step is not None:\n        self.__simulation_settings.time_step = TimeDuration(time_step).seconds\n\n    if restart is not None:\n        self.__simulation_settings.restart = restart\n\n    if simulation_time is not None:\n        simulation_time = TimeDuration(simulation_time).seconds\n        self.__simulation_settings.simulation_time = simulation_time\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/time_series/","title":"Time series","text":""},{"location":"reference/gemseo_fmu/disciplines/time_series/#gemseo_fmu.disciplines.time_series","title":"time_series","text":"<p>Time series.</p>"},{"location":"reference/gemseo_fmu/disciplines/time_series/#gemseo_fmu.disciplines.time_series-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/disciplines/time_stepping_system/","title":"Time stepping system","text":""},{"location":"reference/gemseo_fmu/disciplines/time_stepping_system/#gemseo_fmu.disciplines.time_stepping_system","title":"time_stepping_system","text":"<p>A system of static and time-stepping disciplines.</p>"},{"location":"reference/gemseo_fmu/disciplines/time_stepping_system/#gemseo_fmu.disciplines.time_stepping_system-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/disciplines/time_stepping_system/#gemseo_fmu.disciplines.time_stepping_system.TimeSteppingSystem","title":"TimeSteppingSystem","text":"<pre><code>TimeSteppingSystem(\n    disciplines: Iterable[str | Path | Discipline],\n    final_time: float,\n    time_step: float,\n    apply_time_step_to_disciplines: bool = True,\n    restart: bool = True,\n    do_step: bool = False,\n    mda_name: str = \"MDAJacobi\",\n    mda_options: Mapping[str, Any] = READ_ONLY_EMPTY_DICT,\n    mda_max_iter_at_t0: int = 0,\n    **fmu_options: Any\n)\n</code></pre> <p>               Bases: <code>Discipline</code></p> <p>A system of static and time-stepping disciplines.</p> <p>A static discipline computes an output at time \\(t_k\\) from an input at time \\(t_k\\) while a time-stepping discipline computes an output at time \\(t_k\\) from an input at time \\(t_k\\) and its state at time \\(t_{k-1}\\).</p> <p>This system co-simulates the disciplines using an MDA-based master algorithm.</p> <p>Initialize self.  See help(type(self)) for accurate signature.</p> <p>Parameters:</p> <ul> <li> <code>disciplines</code>               (<code>Iterable[str | Path | Discipline]</code>)           \u2013            <p>The static and time-stepping disciplines. The disciplines will be executed circularly according to the order of their definition.</p> </li> <li> <code>final_time</code>               (<code>float</code>)           \u2013            <p>The final time of the simulation (the initial time is 0).</p> </li> <li> <code>time_step</code>               (<code>float</code>)           \u2013            <p>The time step of the system.</p> </li> <li> <code>apply_time_step_to_disciplines</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the time-stepping disciplines should use <code>time_step</code> as time step. Otherwise, their own time steps.</p> </li> <li> <code>restart</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the system is restarted at initial time after each  execution.</p> </li> <li> <code>do_step</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the model is simulated over only one <code>time_step</code> when calling the execution method. Otherwise, simulate the model from initial time to <code>final_time</code>.</p> </li> <li> <code>mda_name</code>               (<code>str</code>, default:                   <code>'MDAJacobi'</code> )           \u2013            <p>The MDA class name.</p> </li> <li> <code>mda_options</code>               (<code>Mapping[str, Any]</code>, default:                   <code>READ_ONLY_EMPTY_DICT</code> )           \u2013            <p>The options of the MDA.</p> </li> <li> <code>mda_max_iter_at_t0</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The maximum number of iterations of the MDA algorithm at initial time, to find a multidisciplinary feasible configuration.</p> </li> <li> <code>**fmu_options</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>The options to instantiate the FMU disciplines.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/time_stepping_system.py</code> <pre><code>def __init__(\n    self,\n    disciplines: Iterable[str | Path | Discipline],\n    final_time: float,\n    time_step: float,\n    apply_time_step_to_disciplines: bool = True,\n    restart: bool = True,\n    do_step: bool = False,\n    mda_name: str = \"MDAJacobi\",\n    mda_options: Mapping[str, Any] = READ_ONLY_EMPTY_DICT,\n    mda_max_iter_at_t0: int = 0,\n    **fmu_options: Any,\n) -&gt; None:\n    \"\"\"\n    Args:\n        disciplines: The static and time-stepping disciplines.\n            The disciplines will be executed circularly\n            according to the order of their definition.\n        final_time: The final time of the simulation\n            (the initial time is 0).\n        time_step: The time step of the system.\n        apply_time_step_to_disciplines: Whether the time-stepping disciplines\n            should use `time_step` as time step. Otherwise, their own time steps.\n        restart: Whether the system is restarted at initial time\n            after each  execution.\n        do_step: Whether the model is simulated over only one `time_step`\n            when calling the execution method.\n            Otherwise, simulate the model from initial time to `final_time`.\n        mda_name: The MDA class name.\n        mda_options: The options of the MDA.\n        mda_max_iter_at_t0: The maximum number of iterations of the MDA algorithm\n            at initial time, to find a multidisciplinary feasible configuration.\n        **fmu_options: The options to instantiate the FMU disciplines.\n    \"\"\"  # noqa: D205 D212 D415\n    self.__do_step = do_step\n    self.__time_manager = TimeManager(0.0, final_time, time_step)\n    self.__restart = restart\n    self.__mda_max_iter_at_t0 = mda_max_iter_at_t0\n    discipline_time_step = time_step if apply_time_step_to_disciplines else 0.0\n    all_disciplines = []\n    for discipline in disciplines:\n        if isinstance(discipline, DoStepFMUDiscipline):\n            discipline.set_default_execution(\n                final_time=final_time,\n                restart=False,\n                time_step=discipline_time_step or None,\n            )\n        elif isinstance(discipline, BaseFMUDiscipline):\n            discipline.set_default_execution(\n                final_time=final_time,\n                restart=False,\n                do_step=True,\n                time_step=discipline_time_step or None,\n            )\n        elif not isinstance(discipline, Discipline):\n            discipline = DoStepFMUDiscipline(\n                discipline,\n                time_step=discipline_time_step,\n                final_time=final_time,\n                **fmu_options,\n            )\n        all_disciplines.append(discipline)\n\n    self.__fmu_disciplines = [\n        discipline\n        for discipline in all_disciplines\n        if isinstance(discipline, BaseFMUDiscipline)\n    ]\n    super().__init__()\n    strong_couplings = CouplingStructure(all_disciplines).strong_couplings\n    for fmu_discipline in self.__fmu_disciplines:\n        input_grammar = fmu_discipline.input_grammar\n        array_strong_couplings = set()\n        for strong_coupling in strong_couplings:\n            if strong_coupling in input_grammar:\n                array_strong_couplings.add(strong_coupling)\n\n        input_grammar.update_from_names(array_strong_couplings)\n\n    self.__mda = MDAChain(\n        all_disciplines,\n        inner_mda_name=mda_name,\n        # TODO: add max_mda_iter argument when rollback will be available.\n        max_mda_iter=0,\n        inner_mda_settings=mda_options,\n    )\n    for mda in self.__mda.inner_mdas:\n        mda.settings.max_mda_iter = 0\n\n    # TimeSteppingSystem uses an MDA\n    # to co-simulate from t(k) to t(k+1) and\n    # to iterate at t(0) to find a multidisciplinary starting state.\n    # If the coupled system is an n-order ODE, with n &gt; 1,\n    # the coupling vector can remain constant during one iteration\n    # before changing at the next iteration.\n    # For this reason, we need to disable the caches.\n    cache_type = self.__mda.CacheType.NONE\n    self.__mda.set_cache(cache_type)\n    self.__mda.mdo_chain.set_cache(cache_type)\n    for mda in self.__mda.inner_mdas:\n        mda.set_cache(cache_type)\n\n    self.input_grammar.update(self.__mda.input_grammar)\n    self.output_grammar.update(self.__mda.output_grammar)\n\n    # Discipline i has priority over discipline i+1 to set the default inputs.\n    for discipline in all_disciplines[::-1]:\n        self.default_input_data.update({\n            input_name: input_value\n            for input_name, input_value in discipline.default_input_data.items()\n            if input_name in self.input_grammar.names\n        })\n</code></pre>"},{"location":"reference/gemseo_fmu/disciplines/time_stepping_system/#gemseo_fmu.disciplines.time_stepping_system.TimeSteppingSystem-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_fmu/disciplines/time_stepping_system/#gemseo_fmu.disciplines.time_stepping_system.TimeSteppingSystem.mda","title":"mda  <code>property</code>","text":"<pre><code>mda: MDAChain\n</code></pre> <p>The MDA defining the master algorithm to co-simulate the discipline.</p>"},{"location":"reference/gemseo_fmu/disciplines/time_stepping_system/#gemseo_fmu.disciplines.time_stepping_system.TimeSteppingSystem-functions","title":"Functions","text":""},{"location":"reference/gemseo_fmu/disciplines/time_stepping_system/#gemseo_fmu.disciplines.time_stepping_system.TimeSteppingSystem.execute","title":"execute","text":"<pre><code>execute(\n    input_data: Mapping[str, Any] = READ_ONLY_EMPTY_DICT,\n) -&gt; DisciplineData\n</code></pre> <p>Execute the discipline, i.e. compute output data from input data.</p> <p>If :attr:<code>.virtual_execution</code> is <code>True</code>, this method returns the :attr:<code>.default_output_data</code>. Otherwise, it calls the :meth:<code>._run</code> method performing the true execution and returns the corresponding output data. This :meth:<code>._run</code> method must be implemented in subclasses.</p> <p>Parameters:</p> <ul> <li> <code>input_data</code>               (<code>Mapping[str, Any]</code>, default:                   <code>READ_ONLY_EMPTY_DICT</code> )           \u2013            <p>The input data. Complete this dictionary with the :attr:<code>.default_input_data</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DisciplineData</code>           \u2013            <p>The input and output data.</p> </li> </ul> Source code in <code>src/gemseo_fmu/disciplines/time_stepping_system.py</code> <pre><code>def execute(  # noqa: D102\n    self, input_data: Mapping[str, Any] = READ_ONLY_EMPTY_DICT\n) -&gt; DisciplineData:\n    if self.__restart:\n        self.__mda.default_input_data.update(self.default_input_data)\n        self.__time_manager.reset()\n        for fmu_discipline in self.__fmu_disciplines:\n            fmu_discipline.set_next_execution(restart=True)\n\n        if self.cache is not None:\n            self.cache.clear()\n\n    if self.__do_step:\n        # At initial time,\n        # the default input values are the ``default_inputs``.\n        # Afterward,\n        # the default input values are the input values from the previous time,\n        # which can be found in the local data with get_input_data(),\n        # returning an empty dictionary at initial time.\n        original_input_data = input_data\n        input_data = self.get_input_data() or self.default_input_data\n        input_data.update(original_input_data)\n\n    return super().execute(input_data)\n</code></pre>"},{"location":"reference/gemseo_fmu/problems/","title":"Problems","text":""},{"location":"reference/gemseo_fmu/problems/#gemseo_fmu.problems","title":"problems","text":"<p>Problems to illustrate the features of the package.</p>"},{"location":"reference/gemseo_fmu/problems/fmu_files/","title":"Fmu files","text":""},{"location":"reference/gemseo_fmu/problems/fmu_files/#gemseo_fmu.problems.fmu_files","title":"fmu_files","text":"<p>A set of platform-dependent FMU models.</p> <p>These CS FMU models available in linux and win32 versions are used for</p> <ul> <li>testing the functionalities of <code>gemseo-fmu</code> through unit and functional tests,</li> <li>illustrating these functionalities through examples in the documentation.</li> </ul> <p>Note that <code>gemseo-fmu</code> was also used to simulate proprietary FMU models generated from Simulink, in isolation or in combination.</p> <p>Here is the list of the FMU models available in this sub-package:</p> Model FMI Description Generated from add.fmu 2 A linear combination OpenModelica FMU3Model.fmu 3 A model incrementing the output PythonFMU3 Mass_Damper.fmu 2 A mass-damper model OpenModelica MassSpringSystem.fmu 2 A model with springs and two masses OpenModelica MassSpringSubSystem1.fmu 2 A part of MassSpringSystem.fmu OpenModelica MassSpringSubSystem2.fmu 2 Another part of MassSpringSystem.fmu OpenModelica ramp.fmu 2 A ramp model OpenModelica"},{"location":"reference/gemseo_fmu/problems/fmu_files/#gemseo_fmu.problems.fmu_files-functions","title":"Functions","text":""},{"location":"reference/gemseo_fmu/problems/fmu_files/#gemseo_fmu.problems.fmu_files.get_fmu_file_path","title":"get_fmu_file_path","text":"<pre><code>get_fmu_file_path(\n    model_name: str, directory_name: str = \".\"\n) -&gt; Path\n</code></pre> <p>Return the file path of an FMU model depending on the platform.</p> <p>Parameters:</p> <ul> <li> <code>model_name</code>               (<code>str</code>)           \u2013            <p>The name of the FMU model; the corresponding file name is <code>f\"{model_name}.fmu\"</code>.</p> </li> <li> <code>directory_name</code>               (<code>str</code>, default:                   <code>'.'</code> )           \u2013            <p>The name of the directory containing the file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>           \u2013            <p>The file path of the FMU model.</p> </li> </ul> Source code in <code>src/gemseo_fmu/problems/fmu_files/__init__.py</code> <pre><code>def get_fmu_file_path(model_name: str, directory_name: str = \".\") -&gt; Path:\n    \"\"\"Return the file path of an FMU model depending on the platform.\n\n    Args:\n        model_name: The name of the FMU model;\n            the corresponding file name is `f\"{model_name}.fmu\"`.\n        directory_name: The name of the directory containing the file.\n\n    Returns:\n        The file path of the FMU model.\n    \"\"\"\n    os_dir = \"win32\" if PLATFORM_IS_WINDOWS else \"linux\"\n    return Path(__file__).parent / os_dir / directory_name / f\"{model_name}.fmu\"\n</code></pre>"},{"location":"reference/gemseo_fmu/utils/","title":"Utils","text":""},{"location":"reference/gemseo_fmu/utils/#gemseo_fmu.utils","title":"utils","text":"<p>Utils.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/","title":"Time duration","text":""},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration","title":"time_duration","text":"<p>Time duration.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration","title":"TimeDuration","text":"<pre><code>TimeDuration(duration: TimeDurationType)\n</code></pre> <p>A time duration.</p> <p>This time duration is instantiated either from a number expressed in seconds or a string of characters that is a <code>number[, , and ]unit</code> succession, e.g. <code>\"2h 34m 1s\"</code> or <code>\"2 hours, 34 minutes and 1 second\"</code>. The unit can be one of:</p> <ul> <li>y, year, years,</li> <li>m, month, months,</li> <li>w, week, weeks,</li> <li>d, day, days,</li> <li>h, hour, hours,</li> <li>min, minute, minutes,</li> <li>s, second, seconds,</li> <li>ms, millis, millisecond, milliseconds.</li> </ul> <p>The value attribute stores the numerical value of the time duration in seconds while a property whose name is a time unit, e.g. <code>years</code> or <code>minutes</code>, corresponds to the time duration expressed with this time unit.</p> <p>Lastly, TimeDuration objects can be compared, e.g. <code>assert TimeDuration(\"1 week\") &lt; TimeDuration(\"8 days\")</code>.</p> <p>Parameters:</p> <ul> <li> <code>duration</code>               (<code>TimeDurationType</code>)           \u2013            <p>The time duration.</p> </li> </ul> Source code in <code>src/gemseo_fmu/utils/time_duration.py</code> <pre><code>def __init__(self, duration: TimeDurationType) -&gt; None:\n    \"\"\"\n    Args:\n        duration: The time duration.\n    \"\"\"  # noqa: D205, D212, D415\n    self.value = duration\n</code></pre>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.days","title":"days  <code>property</code>","text":"<pre><code>days: float\n</code></pre> <p>The time duration in days.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.hours","title":"hours  <code>property</code>","text":"<pre><code>hours: float\n</code></pre> <p>The time duration in hours.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.microseconds","title":"microseconds  <code>property</code>","text":"<pre><code>microseconds: float\n</code></pre> <p>The time duration in microseconds.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.milliseconds","title":"milliseconds  <code>property</code>","text":"<pre><code>milliseconds: float\n</code></pre> <p>The time duration in milliseconds.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.minutes","title":"minutes  <code>property</code>","text":"<pre><code>minutes: float\n</code></pre> <p>The time duration in minutes.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.months","title":"months  <code>property</code>","text":"<pre><code>months: float\n</code></pre> <p>The time duration in months.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.seconds","title":"seconds  <code>property</code>","text":"<pre><code>seconds: float\n</code></pre> <p>The time duration in seconds.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value: float\n</code></pre> <p>The time duration in seconds.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.weeks","title":"weeks  <code>property</code>","text":"<pre><code>weeks: float\n</code></pre> <p>The time duration in weeks.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.years","title":"years  <code>property</code>","text":"<pre><code>years: float\n</code></pre> <p>The time duration in years.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.TimeUnit","title":"TimeUnit","text":"<p>Time unit.</p>"},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration-functions","title":"Functions","text":""},{"location":"reference/gemseo_fmu/utils/time_duration/#gemseo_fmu.utils.time_duration.TimeDuration.to","title":"to","text":"<pre><code>to(time_unit: TimeUnit) -&gt; float\n</code></pre> <p>Return the time duration with a given time unit.</p> <p>Parameters:</p> <ul> <li> <code>time_unit</code>               (<code>TimeUnit</code>)           \u2013            <p>The time unit.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The time duration.</p> </li> </ul> Source code in <code>src/gemseo_fmu/utils/time_duration.py</code> <pre><code>def to(self, time_unit: TimeUnit) -&gt; float:\n    \"\"\"Return the time duration with a given time unit.\n\n    Args:\n        time_unit: The time unit.\n\n    Returns:\n        The time duration.\n    \"\"\"\n    return getattr(self, time_unit)\n</code></pre>"},{"location":"reference/gemseo_fmu/utils/time_manager/","title":"Time manager","text":""},{"location":"reference/gemseo_fmu/utils/time_manager/#gemseo_fmu.utils.time_manager","title":"time_manager","text":"<p>Time management.</p>"},{"location":"reference/gemseo_fmu/utils/time_manager/#gemseo_fmu.utils.time_manager-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/utils/time_manager/#gemseo_fmu.utils.time_manager.TimeManager","title":"TimeManager","text":"<pre><code>TimeManager(initial: float, final: float, step: float)\n</code></pre> <p>A time manager.</p> <p>Parameters:</p> <ul> <li> <code>initial</code>               (<code>float</code>)           \u2013            <p>The initial time.</p> </li> <li> <code>final</code>               (<code>float</code>)           \u2013            <p>The final time.</p> </li> <li> <code>step</code>               (<code>float</code>)           \u2013            <p>The time step.</p> </li> </ul> Source code in <code>src/gemseo_fmu/utils/time_manager.py</code> <pre><code>def __init__(self, initial: float, final: float, step: float) -&gt; None:\n    \"\"\"\n    Args:\n        initial: The initial time.\n        final: The final time.\n        step: The time step.\n    \"\"\"  # noqa: D205, D212\n    self.__current = self.__initial = initial\n    self.final = final\n    self.step = step\n</code></pre>"},{"location":"reference/gemseo_fmu/utils/time_manager/#gemseo_fmu.utils.time_manager.TimeManager-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_fmu/utils/time_manager/#gemseo_fmu.utils.time_manager.TimeManager.current","title":"current  <code>property</code>","text":"<pre><code>current: float\n</code></pre> <p>The current time.</p>"},{"location":"reference/gemseo_fmu/utils/time_manager/#gemseo_fmu.utils.time_manager.TimeManager.final","title":"final  <code>instance-attribute</code>","text":"<pre><code>final: float = final\n</code></pre> <p>The final time.</p>"},{"location":"reference/gemseo_fmu/utils/time_manager/#gemseo_fmu.utils.time_manager.TimeManager.initial","title":"initial  <code>property</code>","text":"<pre><code>initial: float\n</code></pre> <p>The initial time.</p>"},{"location":"reference/gemseo_fmu/utils/time_manager/#gemseo_fmu.utils.time_manager.TimeManager.is_constant","title":"is_constant  <code>property</code>","text":"<pre><code>is_constant: bool\n</code></pre> <p>Whether the initial time is the final time.</p>"},{"location":"reference/gemseo_fmu/utils/time_manager/#gemseo_fmu.utils.time_manager.TimeManager.is_final","title":"is_final  <code>property</code>","text":"<pre><code>is_final: bool\n</code></pre> <p>Whether the current time is the final time.</p>"},{"location":"reference/gemseo_fmu/utils/time_manager/#gemseo_fmu.utils.time_manager.TimeManager.is_initial","title":"is_initial  <code>property</code>","text":"<pre><code>is_initial: bool\n</code></pre> <p>Whether the current time is the initial time.</p>"},{"location":"reference/gemseo_fmu/utils/time_manager/#gemseo_fmu.utils.time_manager.TimeManager.remaining","title":"remaining  <code>property</code>","text":"<pre><code>remaining: float\n</code></pre> <p>The remaining time.</p>"},{"location":"reference/gemseo_fmu/utils/time_manager/#gemseo_fmu.utils.time_manager.TimeManager.step","title":"step  <code>instance-attribute</code>","text":"<pre><code>step: float = step\n</code></pre> <p>The time step.</p>"},{"location":"reference/gemseo_fmu/utils/time_manager/#gemseo_fmu.utils.time_manager.TimeManager-functions","title":"Functions","text":""},{"location":"reference/gemseo_fmu/utils/time_manager/#gemseo_fmu.utils.time_manager.TimeManager.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the time manager to initial time.</p> Source code in <code>src/gemseo_fmu/utils/time_manager.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the time manager to initial time.\"\"\"\n    self.__current = self.__initial\n</code></pre>"},{"location":"reference/gemseo_fmu/utils/time_manager/#gemseo_fmu.utils.time_manager.TimeManager.update_current_time","title":"update_current_time","text":"<pre><code>update_current_time(\n    step: float = 0.0, return_time_manager: bool = True\n) -&gt; Self | tuple[float, float, float]\n</code></pre> <p>Increment the current time by one time step and truncate at the final time.</p> <p>Parameters:</p> <ul> <li> <code>step</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The time step. If 0, use the time step passed at instantiation.</p> </li> <li> <code>return_time_manager</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to return the time evolution as a time manager.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self | tuple[float, float, float]</code>           \u2013            <p>The current time before the update as initial time, the current time after the update as final time and the difference between the initial and final times as time step.</p> </li> </ul> Source code in <code>src/gemseo_fmu/utils/time_manager.py</code> <pre><code>def update_current_time(\n    self, step: float = 0.0, return_time_manager: bool = True\n) -&gt; Self | tuple[float, float, float]:\n    \"\"\"Increment the current time by one time step and truncate at the final time.\n\n    Args:\n        step: The time step.\n            If 0, use the time step passed at instantiation.\n        return_time_manager: Whether to return the time evolution\n            as a time manager.\n\n    Returns:\n        The current time before the update as initial time,\n        the current time after the update as final time\n        and the difference between the initial and final times as time step.\n    \"\"\"\n    if not step:\n        step = self.step\n\n    if step &gt; self.remaining:\n        LOGGER.debug(\n            \"The time step is greater than the remaining time; \"\n            \"use the remaining time instead.\"\n        )\n        step = self.remaining\n\n    if step == 0:\n        msg = (\n            \"The current time cannot be incremented \"\n            f\"as it is the final time ({self.final}).\"\n        )\n        raise ValueError(msg)\n\n    current_before_update = self.__current\n    self.__current += step\n    times = (current_before_update, self.__current, step)\n    if return_time_manager:\n        return self.__class__(*times)\n\n    return times\n</code></pre>"},{"location":"reference/gemseo_fmu/utils/time_series/","title":"Time series","text":""},{"location":"reference/gemseo_fmu/utils/time_series/#gemseo_fmu.utils.time_series","title":"time_series","text":"<p>Time series.</p>"},{"location":"reference/gemseo_fmu/utils/time_series/#gemseo_fmu.utils.time_series-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_fmu/utils/time_series/#gemseo_fmu.utils.time_series.ObservableType","title":"ObservableType  <code>module-attribute</code>","text":"<pre><code>ObservableType = Union[\n    Sequence[float], NDArrayPydantic[float]\n]\n</code></pre> <p>The type for a sequence of observable values.</p>"},{"location":"reference/gemseo_fmu/utils/time_series/#gemseo_fmu.utils.time_series.TimeType","title":"TimeType  <code>module-attribute</code>","text":"<pre><code>TimeType = Union[\n    Sequence[TimeDurationType], NDArrayPydantic\n]\n</code></pre> <p>The type for a sequence of time values.</p>"},{"location":"reference/gemseo_fmu/utils/time_series/#gemseo_fmu.utils.time_series-classes","title":"Classes","text":""},{"location":"reference/gemseo_fmu/utils/time_series/#gemseo_fmu.utils.time_series.TimeSeries","title":"TimeSeries","text":"<p>The time series of an observable.</p>"},{"location":"reference/gemseo_fmu/utils/time_series/#gemseo_fmu.utils.time_series.TimeSeries-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_fmu/utils/time_series/#gemseo_fmu.utils.time_series.TimeSeries.compute","title":"compute  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>compute: Callable[[float], float] = field(init=False)\n</code></pre> <p>The time function built from this time series.</p>"},{"location":"reference/gemseo_fmu/utils/time_series/#gemseo_fmu.utils.time_series.TimeSeries.interpolate","title":"interpolate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interpolate: bool = False\n</code></pre> <p>Whether to create a piecewise linear time function.</p> <p>Otherwise, create a piecewise constant time function.</p>"},{"location":"reference/gemseo_fmu/utils/time_series/#gemseo_fmu.utils.time_series.TimeSeries.observable","title":"observable  <code>instance-attribute</code>","text":"<pre><code>observable: ObservableType\n</code></pre> <p>The values of the observable associated to the values of the time.</p>"},{"location":"reference/gemseo_fmu/utils/time_series/#gemseo_fmu.utils.time_series.TimeSeries.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size: int = field(init=False)\n</code></pre> <p>The size of the time series.</p>"},{"location":"reference/gemseo_fmu/utils/time_series/#gemseo_fmu.utils.time_series.TimeSeries.time","title":"time  <code>instance-attribute</code>","text":"<pre><code>time: TimeType\n</code></pre> <p>The increasing values of the time.</p> <p>The components can be either numbers in seconds or strings of characters (see TimeDuration).</p>"},{"location":"reference/gemseo_fmu/utils/time_series/#gemseo_fmu.utils.time_series.TimeSeries.tolerance","title":"tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tolerance: TimeDurationType = 0.0\n</code></pre> <p>The tolerance for the piecewise constant time function.</p>"},{"location":"reference/gemseo_fmu/utils/time_series/#gemseo_fmu.utils.time_series.TimeSeries-functions","title":"Functions","text":""},{"location":"reference/gemseo_fmu/utils/time_series/#gemseo_fmu.utils.time_series.TimeSeries.from_csv","title":"from_csv  <code>classmethod</code>","text":"<pre><code>from_csv(\n    file_path: str | Path,\n    tolerance: float = 0.0,\n    header: (\n        int | Sequence[int] | Literal[\"infer\"] | None\n    ) = None,\n    sep: str | None = \";\",\n    **kwargs: Any\n) -&gt; TimeSeries\n</code></pre> <p>Create a time series from a CSV file with two columns.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>               (<code>str | Path</code>)           \u2013            <p>The CSV file path.</p> </li> <li> <code>tolerance</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The tolerance for the piecewise constant time function.</p> </li> <li> <code>header</code>               (<code>int | Sequence[int] | Literal['infer'] | None</code>, default:                   <code>None</code> )           \u2013            <p>The <code>header</code> option of the <code>pandas.read_csv</code> function. By default, no header.</p> </li> <li> <code>sep</code>               (<code>str | None</code>, default:                   <code>';'</code> )           \u2013            <p>The <code>sep</code> option of the <code>pandas.read_csv</code> function.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>The options of the <code>pandas.read_csv</code> function.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TimeSeries</code>           \u2013            <p>The time series.</p> </li> </ul> See Also <p>https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html.</p> Source code in <code>src/gemseo_fmu/utils/time_series.py</code> <pre><code>@classmethod\ndef from_csv(\n    cls,\n    file_path: str | Path,\n    tolerance: float = 0.0,\n    header: int | Sequence[int] | Literal[\"infer\"] | None = None,\n    sep: str | None = \";\",\n    **kwargs: Any,\n) -&gt; TimeSeries:\n    \"\"\"Create a time series from a CSV file with two columns.\n\n    Args:\n        file_path: The CSV file path.\n        tolerance: The tolerance for the piecewise constant time function.\n        header: The ``header`` option of the ``pandas.read_csv`` function.\n            By default, no header.\n        sep: The ``sep`` option of the ``pandas.read_csv`` function.\n        **kwargs: The options of the ``pandas.read_csv`` function.\n\n    Returns:\n        The time series.\n\n    See Also:\n        https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html.\n    \"\"\"\n    data = read_csv(file_path, header=header, sep=sep, **kwargs).to_numpy()\n    return cls(time=data[:, 0], observable=data[:, 1], tolerance=tolerance)\n</code></pre>"},{"location":"user_guide/","title":"Introduction","text":""},{"location":"user_guide/#user-guide","title":"User guide","text":""},{"location":"user_guide/co_simulation/","title":"Co-simulation","text":""},{"location":"user_guide/co_simulation/#co-simulation","title":"Co-simulation","text":"<p>A TimeSteppingSystem is a Discipline defined by a system of static and time-stepping disciplines:</p> <ul> <li>a static discipline computes an output \\(y\\) at time \\(t_k\\)   from an input \\(x\\) at time \\(t_k\\), i.e. \\(y(t_k)=f(x(t_k))\\),</li> <li>a time-stepping discipline computes an output \\(y\\) at time \\(t_k\\)   from an input \\(y\\) at time \\(t_k\\) and its state \\(s\\) at time \\(t_k\\),   i.e. \\(y(t_k)=f(x(t_k),s(t_k),t_k)\\).</li> </ul> <p>At each time step \\(t_k\\), the TimeSteppingSystem executes a collection of such disciplines using a co-simulation master algorithm based on a multidisciplinary analysis (MDA).</p>"},{"location":"user_guide/co_simulation/#basics","title":"Basics","text":""},{"location":"user_guide/co_simulation/#instantiation","title":"Instantiation","text":"<p>The instantiation of a TimeSteppingSystem only requires a list of disciplines, a final time and a time step:</p> <pre><code>from gemseo_fmu.disciplines.time_stepping_system import TimeSteppingSystem\nfrom gemseo_fmu.disciplines.dynamic_fmu_discipline import DynamicFMUDiscipline\nfrom gemseo.disciplines.analytic import AnalyticDiscipline\n\ndisciplines = [\n    \"file_path.fmu\",\n    DynamicFMUDiscipline(\"other_file_path.fmu\"),\n    AnalyticDiscipline({\"y\":\"2*x\"})\n]\nsystem = TimeSteppingSystem(disciplines, 1, 0.1)\n</code></pre> <p>The disciplines can be either an FMU file path, a static discipline or a dynamic discipline.</p>"},{"location":"user_guide/co_simulation/#restart","title":"Restart","text":"<p>By default, an execution starts from the initial time. Set <code>restart</code> to <code>False</code> if you want to restart from the initial time.</p>"},{"location":"user_guide/co_simulation/#time-stepping","title":"Time stepping","text":"<p>By default, an execution simulates from the initial time to the final time. Set <code>do_step</code> to <code>True</code> if you want to simulate with only one time step.</p>"},{"location":"user_guide/co_simulation/#time-step","title":"Time step","text":"<p>By default, the time-stepping disciplines use the time step passed at instantiation. Set <code>apply_time_step_to_disciplines</code> to <code>False</code>  if you want to use their specific time steps.</p>"},{"location":"user_guide/co_simulation/#master-algorithms","title":"Master algorithms","text":"<p>The master algorithm computes a coupling graph from the disciplines, in order to identify the strong and weak coupling variables:</p> <ul> <li>two disciplines are strongly coupled if they are directly or indirectly interdependent,</li> <li>two disciplines are weakly if one does not take as input an output from the other.</li> </ul> <p>Warning</p> <p>This identification based on input and output names implies a naming convention shared by all disciplines.</p> <p>GEMSEO provides facilities for renaming the input and output variables of a set of disciplines, which are illustrated in this example. In the specific case of FMU disciplines, the instantiation argument <code>variable_names</code> can be set to a [VariableRenamer.translators][gemseo.utils.variable_renaming.VariableRenamer.translators].</p> <p>Then, it executes the disciplines sequentially according to the coupling graph orientation and solves the cycles, i.e. groups of strongly coupled disciplines, with an MDA algorithm.</p> <p>Warning</p> <p>For the moment, the rollback mechanism for re-simulating from previous time to current time is not implemented, which prevents these algorithms from iterating at any time (see the sections Jacobi and Gauss-Seidel algorithms below for more information).</p> <p>However, at initial time, and at this time only, the MDA algorithm can iterate if the user sets the <code>max_mda_iter_at_t0</code> argument to the maximum number of iterations of the MDA algorithm (default: no iteration at initial time). This can be used to obtain multidisciplinary feasible initial conditions, in the case where the disciplines have inconsistent initial conditions.</p> <p>By default (<code>algo_name=\"MDAJacobi\"</code>), this algorithm is the Jacobi method, which enables parallel execution. One can also use the Gauss-Seidel method, which is a serial approach; initialize the TimeSteppingSystem class with <code>algo_name=\"MDAGaussSeidel\"</code> to use it.</p> <p>Tip</p> <p>Use the dictionary <code>mda_options</code> to customize the MDA algorithm and subclass BaseMDA to create a new master algorithm.</p> <p>In the following, we explain the mechanics of the Jacobi and Gauss-Seidel algorithms.</p>"},{"location":"user_guide/co_simulation/#jacobi-algorithm","title":"Jacobi algorithm","text":"<p>At initial time \\(t^0\\), this master algorithm initializes the state variables of the disciplines with common values. Then, the disciplines are executed separately, which corresponds to a simulation from time \\(t^0\\) to time \\(t^1\\). If the difference in state variable values between the two times is significant and the rollback mechanism is implemented, we return to time \\(t^0\\) and repeat the time integration from time \\(t^0\\) to time \\(t^1\\) until convergence or budget exhaustion. Lastly, we repeat this process from time \\(t^1\\) to time \\(t^2\\), from time \\(t^2\\) to time \\(t^3\\) and so on until final time.</p> <p>This master algorithm is called Jacobi algorithm because of its structural similarity with the Jacobi method used in numerical linear algebra. As the disciplines are executed separately, these executions can be parallelized and the algorithm is then qualified as parallel.</p> <p>Here is an illustration from time \\(t^n\\) to time \\(t^{n+2}\\) in the case of two strongly coupled disciplines with a budget of two iterations:</p> Jacobi iteration sequence for two disciplines, by Ssicklinger / wikipedia, CC BY-SA 3.0."},{"location":"user_guide/co_simulation/#gauss-seidel-algorithm","title":"Gauss-Seidel algorithm","text":"<p>At initial time \\(t^0\\), this master algorithm initializes the state variables of the disciplines separately. Then, the disciplines are executed sequentially, which corresponds to a simulation from time \\(t^0\\) to time \\(t^1\\). If the difference in state variable values between the two times is significant and the rollback mechanism is implemented, we return to time \\(t^0\\) and repeat the time integration from time \\(t^0\\) to time \\(t^1\\) until convergence or budget exhaustion. Lastly, we repeat this process from time \\(t^1\\) to time \\(t^2\\), from time \\(t^2\\) to time \\(t^3\\) and so on until final time.</p> <p>Note</p> <p>The results depends on the order of the disciplines, which are executed sequentially, especially when they are poorly converged.</p> <p>This master algorithm is called Gauss-Seidel algorithm because of its structural similarity with the Gauss-Seidel method used in numerical linear algebra. As the disciplines are executed sequentially, these executions cannot be parallelized and the algorithm is then qualified as serial.</p> <p>Here is an illustration from time \\(t^n\\) to time \\(t^{n+2}\\) in the case of two strongly coupled disciplines with a budget of two iterations:</p> Gauss-Seidel iteration sequence for two disciplines, by Ssicklinger / wikipedia, CC BY-SA 3.0."},{"location":"user_guide/fmu_discipline/","title":"Disciplines","text":""},{"location":"user_guide/fmu_discipline/#fmu-discipline","title":"FMU discipline","text":"<p>The functional mock-up interface (FMI) is a popular free standard to exchange dynamic simulation models. This standard defines the notion of functional mock-up unit (FMU) through a ZIP file containg a mix of XML files, binaries and C code. GEMSEO-FMU proposes new types of Discipline to simulate an FMU model:</p> <ul> <li>the StaticFMUDiscipline   to simulate a time-independent FMU model \\(f\\)   like \\(y=f(x)\\)   where \\(x\\) is the input and \\(y\\) is the output,</li> <li>the DynamicFMUDiscipline   to simulate a time-dependent FMU model \\(f\\)   like \\(y(t_k)=f(y(t_{k-1}),x(t_{k-1}),\\Delta t_k)\\)   where \\(t_{k-1}\\) is the previous time,   \\(t_k\\) is the current time   and \\(\\Delta t_k=t_k-t_{k-1}\\) is the time step,</li> <li>the FMUDiscipline   to simulate a time-independent or time-dependent FMU model \\(f\\)   like \\(y=f(x)\\) or \\(y(t_k)=f(y(t_{k-1}),x(t_{k-1}),\\Delta t_k)\\).</li> </ul> <p>Info</p> <p>FMUDiscipline is an alias of DynamicFMUDiscipline and can be used to simulate both time-dependent and time-independent FMU models. Most of the time, the FMU model are dynamic and so this naming shortcut can be useful.</p> <p>Note</p> <p><code>gemseo-fmu</code> distinguishes between static and dynamic models to facilitate use by newcomers in the FMI standard. However, it should be noted that an FMU model does not make this distinction: all FMU models include the notion of time. Thus, a model summing two operands \\(a\\) and \\(b\\) can be run with different time steps and different final times; it will then produce the same result \\(c=a+b\\) at each time step.</p> <p>In the following, we will talk about the FMUDiscipline. The content would be the same for StaticFMUDiscipline except for the parts related to the notion of time, which are specific to the DynamicFMUDiscipline. You will find examples of both StaticFMUDiscipline and DynamicFMUDiscipline. in the galleries of examples.</p>"},{"location":"user_guide/fmu_discipline/#basics","title":"Basics","text":"<p>As any Discipline, you mainly need to know how to instantiate an FMUDiscipline, and how to execute it. Advanced features will be presented later.</p>"},{"location":"user_guide/fmu_discipline/#instantiation","title":"Instantiation","text":"<p>The only mandatory argument is the path to the FMU file:</p> <pre><code>from gemseo_fmu.disciplines.fmu_discipline import FMUDiscipline\n\ndiscipline = FMUDiscipline(\"my_model.fmu\")\n</code></pre>"},{"location":"user_guide/fmu_discipline/#inputs","title":"Inputs","text":"<p>When <code>input_names</code> is <code>()</code> (default), the input variables of the discipline are all the variables of the FMU model with type input or parameter.</p> <p>When <code>input_names=None</code>, the discipline has no input variables.</p> <p>The input variables can be a subset of the inputs and parameters of the FMU model by using <code>input_names=some_input_names</code>.</p>"},{"location":"user_guide/fmu_discipline/#outputs","title":"Outputs","text":"<p>When <code>ouput_names</code> is <code>()</code> (default), the output variables of the discipline are all the outputs of the FMU model plus the time.</p> <p>The time can be excluded from the outputs with <code>add_time_to_output_grammar=False</code>.</p> <p>The output variables can be a subset of the outputs of the FMU model by using <code>output_names=some_output_names</code>.</p>"},{"location":"user_guide/fmu_discipline/#renaming-inputs-and-outputs","title":"Renaming inputs and outputs","text":"<p>Sometimes the names of variables in the FMU model are not meaningful, or are used by other FMU models in the same study to represent another quantity. In both cases, we might want to use discipline variable names that are different from those in the FMU model. That's what argument <code>variable_names</code> is for. This dictionary of the form <code>{fmu_model_variable_name: discipline_variable_name, ...}</code> defines the mapping between the variable names in the FMU model that do not suit us and the variable names that we want to use in the discipline.</p>"},{"location":"user_guide/fmu_discipline/#time-settings","title":"Time settings","text":"<p>Regarding the time settings, this minimal instantiation implies that each execution of the discipline will execute the FMU model as co-simulation FMU model from its start time to its final time with a default time step and a default solver for ordinary differential equation (ODE). If the start time is not defined in the FMU models, this is set to 0. If the final time is not defined in the FMU models, this time is set to the start time, and it is therefore advisable to use a custom value.</p> <p>The time step and the solver can be changed with the float argument <code>time_step</code> and the string argument <code>solver_name</code>.</p> <p>An execution can also advance a single time step from the start time by using <code>do_step=True</code>. When using both <code>do_step=True</code> and <code>restart=False</code>, an execution advances a single time step from the previous one.</p> <p>Info</p> <p>The DoStepFMUDiscipline is an FMUDiscipline whose execution advances a single time step from the previous time. It can be useful if you want an FMUDiscipline doing time stepping throughout its life cycle.</p> <p>Lastly, the final time can be changed with the float argument <code>final_time</code>.</p> <p>Warning</p> <p>The discipline cannot be executed after the final time.</p>"},{"location":"user_guide/fmu_discipline/#execution","title":"Execution","text":"<p>An FMUDiscipline can be easily executed with the default values of its inputs:</p> <pre><code>discipline.execute()\n</code></pre> <p>or with custom ones passed as a dictionary:</p> <pre><code>discipline.execute({\"my_input\": my_input_value})\n</code></pre>"},{"location":"user_guide/fmu_discipline/#advanced","title":"Advanced","text":""},{"location":"user_guide/fmu_discipline/#time-series","title":"Time series","text":"<p>An input value can be either a scalar or a TimeSeries.</p> <p>For instance, a discipline can take as input a signal \\(x(t)\\) known at time steps \\(t_1,t2,\\ldots,t_N\\):</p> <pre><code>from gemseo.disciplines.time_series import TimeSeries\n\nmy_time_series = TimeSeries([t1, t2, ..., tN], [x1, x2, ..., xN])\n</code></pre> <p>The values of the time \\(t\\) and observable \\(x\\) can be easily accessed:</p> <pre><code>t = my_time_series.time\nx = my_time_series.observable\n</code></pre> <p>In practice, you can use it either to set the default inputs:</p> <pre><code>discipline.default_inputs[\"my_input\"] = my_time_series\n</code></pre> <p>or to execute the discipline:</p> <pre><code>discipline.execute({\"my_input\": my_time_series})\n</code></pre>"},{"location":"user_guide/fmu_discipline/#configure-the-next-execution","title":"Configure the next execution","text":"<p>The time settings of the next execution of the discipline depends on the time settings defined at instantiation but can be changed temporarily.</p> <p>set_next_execution() allows to change the duration of the simulation associated to the next execution, change the time step used during the next execution and restart the discipline instantiated with <code>restart=False</code> (and vice-versa).</p> <p>Only the next execution</p> <p>This method only applies to the next execution. It must be used each time a different behavior from the instantiation settings is required.</p> <p>Simulation time</p> <p>The simulation time must be less than or equal to the time remaining before the final time.</p> <p>Here is an example of how to use this method:</p> <pre><code>from gemseo_fmu.disciplines.fmu_discipline import FMUDiscipline\n\n# Create a discipline from an FMU model:\n# - set the final time at 12 seconds,\n# - start an execution at the time step where the previous one stopped.\ndiscipline = FMUDiscipline(\"my_model.fmu\", final_time=12, restart=False)\n\n# Simulate with the default values of the inputs during 3 seconds\ndiscipline.set_next_execution(simulation_time=3)\ndiscipline.execute()\n\n# Simulate with custom values of the inputs during 2 seconds\ndiscipline.set_next_execution(simulation_time=2)\ndiscipline.execute({\"x\": array([12.3])})\n\n# Simulate with custome values until final time (i.e. during 7 seconds)\ndiscipline.execute({\"x\": array([16.8])})\n</code></pre>"},{"location":"user_guide/fmu_discipline/#restart","title":"Restart","text":"<p>The argument <code>restart</code> has already been introduced in this page.</p> <p>It can also be used to compare trajectories:</p> <pre><code>import matplotlib.pyplot as plt\nfrom gemseo_fmu.disciplines.fmu_discipline import FMUDiscipline\n\ndiscipline = FMUDiscipline(\"my_model.fmu\")\ndiscipline.execute()\ndefault_trajectory = discipline.local_data[\"y\"]\n\ndiscipline.execute({\"x\": array([12.3])})\nfirst_custom_trajectory = discipline.local_data[\"y\"]\n\ndiscipline.execute({\"x\": array([16.8])})\nsecond_custom_trajectory = discipline.local_data[\"y\"]\n\ntime = discipline.local_data[\"time\"]\n\nplt.plot(time, default_trajectory, label=\"Default\")\nplt.plot(time, first_custom_trajectory, label=\"Option 1\")\nplt.plot(time, second_custom_trajectory, label=\"Option 2\")\nplt.show()\n</code></pre>"}]}